/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@kurkle/color/dist/color.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@kurkle/color/dist/color.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   b2n: () => (/* binding */ b2n),
/* harmony export */   b2p: () => (/* binding */ b2p),
/* harmony export */   "default": () => (/* binding */ index_esm),
/* harmony export */   hexParse: () => (/* binding */ hexParse),
/* harmony export */   hexString: () => (/* binding */ hexString),
/* harmony export */   hsl2rgb: () => (/* binding */ hsl2rgb),
/* harmony export */   hslString: () => (/* binding */ hslString),
/* harmony export */   hsv2rgb: () => (/* binding */ hsv2rgb),
/* harmony export */   hueParse: () => (/* binding */ hueParse),
/* harmony export */   hwb2rgb: () => (/* binding */ hwb2rgb),
/* harmony export */   lim: () => (/* binding */ lim),
/* harmony export */   n2b: () => (/* binding */ n2b),
/* harmony export */   n2p: () => (/* binding */ n2p),
/* harmony export */   nameParse: () => (/* binding */ nameParse),
/* harmony export */   p2b: () => (/* binding */ p2b),
/* harmony export */   rgb2hsl: () => (/* binding */ rgb2hsl),
/* harmony export */   rgbParse: () => (/* binding */ rgbParse),
/* harmony export */   rgbString: () => (/* binding */ rgbString),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   round: () => (/* binding */ round)
/* harmony export */ });
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function b2p(v) {
  return lim(round(v / 2.55), 0, 100);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}

const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = [...'0123456789ABCDEF'];
const h1 = b => hex[b & 0xF];
const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : '';
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v
    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
    : undefined;
}

const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return ((g - b) / d) + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (
    Array.isArray(a)
      ? f(a[0], a[1], a[2])
      : f(a, b, c)
  ).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255
    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    : `hsl(${h}, ${s}%, ${l}%)`;
}

const map = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names$1 = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }
  return unpacked;
}

let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}

const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v && (
    v.a < 255
      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
      : `rgb(${v.r}, ${v.g}, ${v.b})`
  );
}

const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}

function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {r: 0, g: 0, b: 0, a: 255};
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {r: input[0], g: input[1], b: input[2], a: 255};
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, {r: 0, g: 0, b: 0, a: 1});
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}

function index_esm(input) {
  return new Color(input);
}




/***/ }),

/***/ "./node_modules/chart.js/auto/auto.js":
/*!********************************************!*\
  !*** ./node_modules/chart.js/auto/auto.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animation: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animation),
/* harmony export */   Animations: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Animations),
/* harmony export */   ArcElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ArcElement),
/* harmony export */   BarController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarController),
/* harmony export */   BarElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BarElement),
/* harmony export */   BasePlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasePlatform),
/* harmony export */   BasicPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BasicPlatform),
/* harmony export */   BubbleController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.BubbleController),
/* harmony export */   CategoryScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.CategoryScale),
/* harmony export */   Chart: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart),
/* harmony export */   Colors: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Colors),
/* harmony export */   DatasetController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DatasetController),
/* harmony export */   Decimation: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Decimation),
/* harmony export */   DomPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DomPlatform),
/* harmony export */   DoughnutController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.DoughnutController),
/* harmony export */   Element: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Element),
/* harmony export */   Filler: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Filler),
/* harmony export */   Interaction: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Interaction),
/* harmony export */   Legend: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Legend),
/* harmony export */   LineController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineController),
/* harmony export */   LineElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LineElement),
/* harmony export */   LinearScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LinearScale),
/* harmony export */   LogarithmicScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.LogarithmicScale),
/* harmony export */   PieController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PieController),
/* harmony export */   PointElement: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PointElement),
/* harmony export */   PolarAreaController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.PolarAreaController),
/* harmony export */   RadarController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadarController),
/* harmony export */   RadialLinearScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.RadialLinearScale),
/* harmony export */   Scale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Scale),
/* harmony export */   ScatterController: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.ScatterController),
/* harmony export */   SubTitle: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.SubTitle),
/* harmony export */   Ticks: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Ticks),
/* harmony export */   TimeScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeScale),
/* harmony export */   TimeSeriesScale: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeSeriesScale),
/* harmony export */   Title: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Title),
/* harmony export */   Tooltip: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Tooltip),
/* harmony export */   _adapters: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._adapters),
/* harmony export */   _detectPlatform: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__._detectPlatform),
/* harmony export */   animator: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.animator),
/* harmony export */   controllers: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.controllers),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaults: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.defaults),
/* harmony export */   elements: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.elements),
/* harmony export */   layouts: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.layouts),
/* harmony export */   plugins: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.plugins),
/* harmony export */   registerables: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables),
/* harmony export */   registry: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registry),
/* harmony export */   scales: () => (/* reexport safe */ _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.scales)
/* harmony export */ });
/* harmony import */ var _dist_chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/chart.js */ "./node_modules/chart.js/dist/chart.js");


_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(..._dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dist_chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart);


/***/ }),

/***/ "./node_modules/chart.js/dist/chart.js":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animation: () => (/* binding */ Animation),
/* harmony export */   Animations: () => (/* binding */ Animations),
/* harmony export */   ArcElement: () => (/* binding */ ArcElement),
/* harmony export */   BarController: () => (/* binding */ BarController),
/* harmony export */   BarElement: () => (/* binding */ BarElement),
/* harmony export */   BasePlatform: () => (/* binding */ BasePlatform),
/* harmony export */   BasicPlatform: () => (/* binding */ BasicPlatform),
/* harmony export */   BubbleController: () => (/* binding */ BubbleController),
/* harmony export */   CategoryScale: () => (/* binding */ CategoryScale),
/* harmony export */   Chart: () => (/* binding */ Chart),
/* harmony export */   Colors: () => (/* binding */ plugin_colors),
/* harmony export */   DatasetController: () => (/* binding */ DatasetController),
/* harmony export */   Decimation: () => (/* binding */ plugin_decimation),
/* harmony export */   DomPlatform: () => (/* binding */ DomPlatform),
/* harmony export */   DoughnutController: () => (/* binding */ DoughnutController),
/* harmony export */   Element: () => (/* binding */ Element),
/* harmony export */   Filler: () => (/* binding */ index),
/* harmony export */   Interaction: () => (/* binding */ Interaction),
/* harmony export */   Legend: () => (/* binding */ plugin_legend),
/* harmony export */   LineController: () => (/* binding */ LineController),
/* harmony export */   LineElement: () => (/* binding */ LineElement),
/* harmony export */   LinearScale: () => (/* binding */ LinearScale),
/* harmony export */   LogarithmicScale: () => (/* binding */ LogarithmicScale),
/* harmony export */   PieController: () => (/* binding */ PieController),
/* harmony export */   PointElement: () => (/* binding */ PointElement),
/* harmony export */   PolarAreaController: () => (/* binding */ PolarAreaController),
/* harmony export */   RadarController: () => (/* binding */ RadarController),
/* harmony export */   RadialLinearScale: () => (/* binding */ RadialLinearScale),
/* harmony export */   Scale: () => (/* binding */ Scale),
/* harmony export */   ScatterController: () => (/* binding */ ScatterController),
/* harmony export */   SubTitle: () => (/* binding */ plugin_subtitle),
/* harmony export */   Ticks: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM),
/* harmony export */   TimeScale: () => (/* binding */ TimeScale),
/* harmony export */   TimeSeriesScale: () => (/* binding */ TimeSeriesScale),
/* harmony export */   Title: () => (/* binding */ plugin_title),
/* harmony export */   Tooltip: () => (/* binding */ plugin_tooltip),
/* harmony export */   _adapters: () => (/* binding */ adapters),
/* harmony export */   _detectPlatform: () => (/* binding */ _detectPlatform),
/* harmony export */   animator: () => (/* binding */ animator),
/* harmony export */   controllers: () => (/* binding */ controllers),
/* harmony export */   defaults: () => (/* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   elements: () => (/* binding */ elements),
/* harmony export */   layouts: () => (/* binding */ layouts),
/* harmony export */   plugins: () => (/* binding */ plugins),
/* harmony export */   registerables: () => (/* binding */ registerables),
/* harmony export */   registry: () => (/* binding */ registry),
/* harmony export */   scales: () => (/* binding */ scales)
/* harmony export */ });
/* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.dataset.js */ "./node_modules/chart.js/dist/chunks/helpers.dataset.js");
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */



class Animator {
    constructor(){
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
 _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn)=>fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            }));
    }
 _refresh() {
        if (this._request) {
            return;
        }
        this._running = true;
        this._request = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{
            this._update();
            this._request = null;
            if (this._running) {
                this._refresh();
            }
        });
    }
 _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart)=>{
            if (!anims.running || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw = false;
            let item;
            for(; i >= 0; --i){
                item = items[i];
                if (item._active) {
                    if (item._total > anims.duration) {
                        anims.duration = item._total;
                    }
                    item.tick(date);
                    draw = true;
                } else {
                    items[i] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw) {
                chart.draw();
                this._notify(chart, anims, date, 'progress');
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, 'complete');
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
            this._running = false;
        }
    }
 _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            };
            charts.set(chart, anims);
        }
        return anims;
    }
 listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
 add(chart, items) {
        if (!items || !items.length) {
            return;
        }
        this._getAnims(chart).items.push(...items);
    }
 has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
 start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
            return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) {
            return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
            return false;
        }
        return true;
    }
 stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
            return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for(; i >= 0; --i){
            items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), 'complete');
    }
 remove(chart) {
        return this._charts.delete(chart);
    }
}
var animator = /* #__PURE__ */ new Animator();

const transparent = 'transparent';
const interpolators = {
    boolean (from, to, factor) {
        return factor > 0.5 ? to : from;
    },
 color (from, to, factor) {
        const c0 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);
        const c1 = c0.valid && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number (from, to, factor) {
        return from + (to - from) * factor;
    }
};
class Animation {
    constructor(cfg, target, prop, to){
        const currentValue = target[prop];
        to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        const from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
    active() {
        return this._active;
    }
    update(cfg, to, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            this._from = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                cfg.from,
                currentValue,
                to
            ]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from;
            return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej)=>{
            promises.push({
                res,
                rej
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? 'res' : 'rej';
        const promises = this._promises || [];
        for(let i = 0; i < promises.length; i++){
            promises[i][method]();
        }
    }
}

class Animations {
    constructor(chart, config){
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
    configure(config) {
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {
            return;
        }
        const animationOptions = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key)=>{
            const cfg = config[key];
            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {
                return;
            }
            const resolved = {};
            for (const option of animationOptions){
                resolved[option] = cfg[option];
            }
            ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [
                key
            ]).forEach((prop)=>{
                if (prop === key || !animatedProps.has(prop)) {
                    animatedProps.set(prop, resolved);
                }
            });
        });
    }
 _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
            return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(()=>{
                target.options = newOptions;
            }, ()=>{
            });
        }
        return animations;
    }
 _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for(i = props.length - 1; i >= 0; --i){
            const prop = props[i];
            if (prop.charAt(0) === '$') {
                continue;
            }
            if (prop === 'options') {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else {
                    animation.cancel();
                }
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
 update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
}
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for(let i = 0; i < keys.length; i++){
        const anim = animations[keys[i]];
        if (anim && anim.active()) {
            running.push(anim.wait());
        }
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
        return;
    }
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) {
        target.options = options = Object.assign({}, options, {
            $shared: false,
            $animations: {}
        });
    }
    return options;
}

function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === undefined ? allowedOverflow : 0;
    const max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
        return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    let t, r, b, l;
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else {
        t = r = b = l = value;
    }
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i){
        keys.push(metasets[i].index);
    }
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === 'single';
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
        return;
    }
    let found = false;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            found = true;
            if (options.all) {
                continue;
            }
            break;
        }
        otherValue = stack.values[datasetIndex];
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {
            value += otherValue;
        }
    }
    if (!found && !options.all) {
        return 0;
    }
    return value;
}
function convertObjectDataToArray(data, meta) {
    const { iScale , vScale  } = meta;
    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            [iAxisKey]: key,
            [vAxisKey]: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
        }
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart , _cachedMeta: meta  } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale , vScale , index: datasetIndex  } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for(let i = 0; i < ilen; ++i){
        const item = parsed[i];
        const { [iAxis]: index , [vAxis]: value  } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index,
        mode: 'default',
        type: 'dataset'
    });
}
function createDataContext(parent, index, element) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: 'default',
        type: 'data'
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
        return;
    }
    items = items || meta._parsed;
    for (const parsed of items){
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
            return;
        }
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
            delete stacks[axis]._visualValues[datasetIndex];
        }
    }
}
const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    };
class DatasetController {
 static defaults = {};
 static datasetElementType = null;
 static dataElementType = null;
 constructor(chart, datasetIndex){
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
         this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = undefined;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
    }
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
            console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
        const xid = meta.xAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, 'x'));
        const yid = meta.yAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, 'y'));
        const rid = meta.rAxisID = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, 'r'));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
 getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
 _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update('reset');
    }
 _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);
        }
        if (meta._stacked) {
            clearStacks(meta);
        }
    }
 _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {
            const meta = this._cachedMeta;
            this._data = convertObjectDataToArray(data, meta);
        } else if (_data !== data) {
            if (_data) {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);
            }
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
            meta.dataset = new this.datasetElementType();
        }
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(this, meta._parsed);
            meta._stacked = isStacked(meta.vScale, meta);
        }
    }
 configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
 parse(start, count) {
        const { _cachedMeta: meta , _data: data  } = this;
        const { iScale , _stacked  } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
            } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
            }
            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for(i = 0; i < count; ++i){
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) {
                        sorted = false;
                    }
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) {
            updateStacks(this, parsed);
        }
    }
 parsePrimitiveData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const { xScale , yScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),
                y: yScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)
            };
        }
        return parsed;
    }
 getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
 getDataElement(index) {
        return this._cachedMeta.data[index];
    }
 applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta.index, {
            mode
        });
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
    }
 getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for(i = 0; i < ilen; ++i){
            if (_skip()) {
                continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
                break;
            }
        }
        if (sorted) {
            for(i = ilen - 1; i >= 0; --i){
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
            }
        }
        return range;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for(i = 0, ilen = parsed.length; i < ilen; ++i){
            value = parsed[i][scale.axis];
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {
                values.push(value);
            }
        }
        return values;
    }
 getMaxOverflow() {
        return false;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
        };
    }
 _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || 'default');
        meta._clip = toClip((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
 update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) {
            meta.dataset.draw(ctx, area, start, count);
        }
        for(i = start; i < start + count; ++i){
            const element = elements[i];
            if (element.hidden) {
                continue;
            }
            if (element.active && drawActiveElementsOnTop) {
                active.push(element);
            } else {
                element.draw(ctx, area);
            }
        }
        for(i = 0; i < active.length; ++i){
            active[i].draw(ctx, area);
        }
    }
 getStyle(index, active) {
        const mode = active ? 'active' : 'default';
        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
 getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
 resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
 resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
 _resolveElementOptions(elementType, mode = 'default', index) {
        const active = mode === 'active';
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + '-' + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(index);
        if (cached) {
            return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
            `${elementType}Hover`,
            'hover',
            elementType,
            ''
        ] : [
            elementType,
            ''
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);
        const context = ()=>this.getContext(index, active, mode);
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
 _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
            return cached;
        }
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
    }
 getSharedOptions(options) {
        if (!options.$shared) {
            return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
 includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
 _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
            sharedOptions,
            includeOptions
        };
    }
 updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
        } else {
            this._resolveAnimations(index, mode).update(element, properties);
        }
    }
 updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
        }
    }
 _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', true);
    }
 _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', false);
        }
    }
 _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
            this._setStyle(element, undefined, 'active', true);
        }
    }
 _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList){
            this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
            this.parse(0, count);
        }
        if (numData > numMeta) {
            this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
            this._removeElements(numData, numMeta - numData);
        }
    }
 _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr)=>{
            arr.length += count;
            for(i = arr.length - 1; i >= end; i--){
                arr[i] = arr[i - count];
            }
        };
        move(data);
        for(i = start; i < end; ++i){
            data[i] = new this.dataElementType();
        }
        if (this._parsing) {
            move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
            this.updateElements(data, start, count, 'reset');
        }
    }
    updateElements(element, start, count, mode) {}
 _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) {
                clearStacks(meta, removed);
            }
        }
        meta.data.splice(start, count);
    }
 _sync(args) {
        if (this._parsing) {
            this._syncList.push(args);
        } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
            this.index,
            ...args
        ]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync([
            '_insertElements',
            this.getDataset().data.length - count,
            count
        ]);
    }
    _onDataPop() {
        this._sync([
            '_removeElements',
            this._cachedMeta.data.length - 1,
            1
        ]);
    }
    _onDataShift() {
        this._sync([
            '_removeElements',
            0,
            1
        ]);
    }
    _onDataSplice(start, count) {
        if (count) {
            this._sync([
                '_removeElements',
                start,
                count
            ]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
            this._sync([
                '_insertElements',
                start,
                newCount
            ]);
        }
    }
    _onDataUnshift() {
        this._sync([
            '_insertElements',
            0,
            arguments.length
        ]);
    }
}

function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));
    }
    return scale._cache.$bar;
}
 function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = ()=>{
        if (curr === 32767 || curr === -32768) {
            return;
        }
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
 function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
    };
}
 function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
        next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
    };
}
function parseValue(entry, item, vScale, i) {
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {
        parseFloatBar(entry, item, vScale, i);
    } else {
        item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = 'left';
        end = 'right';
    } else {
        reverse = properties.base < properties.y;
        start = 'bottom';
        end = 'top';
    }
    if (reverse) {
        top = 'end';
        bottom = 'start';
    } else {
        top = 'start';
        bottom = 'end';
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
        };
        return;
    }
    const { start , end , reverse , top , bottom  } = borderProps(properties);
    if (edge === 'middle' && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
            edge = top;
        } else if ((stack._bottom || 0) === index) {
            edge = bottom;
        } else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else {
        edge = startEnd(edge, a, b);
    }
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, { inflateAmount  }, ratio) {
    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
    static id = 'bar';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'bar',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'base',
                    'width',
                    'height'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category',
                offset: true,
                grid: {
                    offset: true
                }
            },
            _value_: {
                type: 'linear',
                beginAtZero: true
            }
        }
    };
 parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
 parseObjectData(meta, data, start, count) {
        const { iScale , vScale  } = meta;
        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for(i = start, ilen = start + count; i < ilen; ++i){
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);
            parsed.push(parseValue((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
    }
 updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
        }
    }
 getMaxOverflow() {
        return 0;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale , vScale  } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
            value
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset = mode === 'reset';
        const { index , _cachedMeta: { vScale  }  } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        for(let i = start; i < start + count; i++){
            const parsed = this.getParsed(i);
            const vpixels = reset || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {
                base,
                head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
            }
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
        }
    }
 _getStacks(last, dataIndex) {
        const { iScale  } = this._cachedMeta;
        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
        const stacked = iScale.options.stacked;
        const stacks = [];
        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
        const iScaleValue = currentParsed && currentParsed[iScale.axis];
        const skipNull = (meta)=>{
            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
            const val = parsed && parsed[meta.vScale.axis];
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {
                return true;
            }
        };
        for (const meta of metasets){
            if (dataIndex !== undefined && skipNull(meta)) {
                continue;
            }
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
                stacks.push(meta.stack);
            }
            if (meta.index === last) {
                break;
            }
        }
        if (!stacks.length) {
            stacks.push(undefined);
        }
        return stacks;
    }
 _getStackCount(index) {
        return this._getStacks(undefined, index).length;
    }
    _getAxisCount() {
        return this._getAxis().length;
    }
    getFirstScaleIdForIndexAxis() {
        const scales = this.chart.scales;
        const indexScaleId = this.chart.options.indexAxis;
        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();
    }
    _getAxis() {
        const axis = {};
        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
        for (const dataset of this.chart.data.datasets){
            axis[(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;
        }
        return Object.keys(axis);
    }
 _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== undefined ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
 _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for(i = 0, ilen = meta.data.length; i < ilen; ++i){
            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
    }
 _calculateBarValuePixels(index) {
        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {
                start = 0;
            }
            start += value;
        }
        const startValue = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
            head = vScale.getPixelForValue(start + length);
        } else {
            head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
                base -= size / 2;
            }
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) {
                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
            }
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2
        };
    }
 _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);
        let center, size;
        const axisCount = this._getAxisCount();
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);
            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;
            const axisNumber = this._getAxis().indexOf((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(axisID, this.getFirstScaleIdForIndexAxis()));
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for(; i < ilen; ++i){
            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                rects[i].draw(this._ctx);
            }
        }
    }
}

class BubbleController extends DatasetController {
    static id = 'bubble';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'borderWidth',
                    'radius'
                ]
            }
        }
    };
 static overrides = {
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
 parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        }
        return parsed;
    }
 parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
 getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for(let i = data.length - 1; i >= 0; --i){
            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
    }
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
        };
    }
    update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                if (reset) {
                    properties.options.radius = 0;
                }
            }
            this.updateElement(point, i, properties, mode);
        }
    }
 resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) {
            values = Object.assign({}, values, {
                $shared: false
            });
        }
        const radius = values.radius;
        if (mode !== 'active') {
            values.radius = 0;
        }
        values.radius += (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);
        return values;
    }
}

function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);
        const minX = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);
        const minY = calcMin(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY
    };
}
class DoughnutController extends DatasetController {
    static id = 'doughnut';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: false
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'circumference',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                    'startAngle',
                    'x',
                    'y',
                    'offset',
                    'borderWidth',
                    'spacing'
                ]
            }
        },
        cutout: '50%',
        rotation: 0,
        circumference: 360,
        radius: '100%',
        spacing: 0,
        indexAxis: 'r'
    };
    static descriptors = {
        _scriptable: (name)=>name !== 'spacing',
        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
    }
    linkScales() {}
 parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
            meta._parsed = data;
        } else {
            let getter = (i)=>+data[i];
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {
                const { key ='value'  } = this._parsing;
                getter = (i)=>+(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);
            }
            let i, ilen;
            for(i = start, ilen = start + count; i < ilen; ++i){
                meta._parsed[i] = getter(i);
            }
        }
    }
 _getRotation() {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);
    }
 _getCircumference() {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);
    }
 _getRotationExtents() {
        let min = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;
        let max = -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;
        for(let i = 0; i < this.chart.data.datasets.length; ++i){
            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
            }
        }
        return {
            rotation: min,
            circumference: max - min
        };
    }
 update(mode) {
        const chart = this.chart;
        const { chartArea  } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference , rotation  } = this._getRotationExtents();
        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
        }
        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        let startAngle = this._getRotation();
        let i;
        for(i = 0; i < start; ++i){
            startAngle += this._circumference(i, reset);
        }
        for(i = start; i < start + count; ++i){
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
            };
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
            }
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
        }
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for(i = 0; i < metaData.length; i++){
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
            }
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);
        }
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
                if (chart.isDatasetVisible(i)) {
                    meta = chart.getDatasetMeta(i);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
            }
        }
        if (!arcs) {
            return 0;
        }
        for(i = 0, ilen = arcs.length; i < ilen; ++i){
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== 'inner') {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
            }
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
 _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for(let i = 0; i < datasetIndex; ++i){
            if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
            }
        }
        return ringWeightOffset;
    }
 _getRingWeight(datasetIndex) {
        return Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
 _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
}

class LineController extends DatasetController {
    static id = 'line';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        showLine: true,
        spanGaps: false
    };
 static overrides = {
        scales: {
            _index_: {
                type: 'category'
            },
            _value_: {
                type: 'linear'
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line , data: points = [] , _dataset  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {
            start = 0;
            count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
            options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
        }, mode);
        this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        const end = start + count;
        const pointsCount = points.length;
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = 0; i < pointsCount; ++i){
            const point = points[i];
            const properties = directUpdate ? point : {};
            if (i < start || i >= end) {
                properties.skip = true;
                continue;
            }
            const parsed = this.getParsed(i);
            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
    }
}

class PolarAreaController extends DatasetController {
    static id = 'polarArea';
 static defaults = {
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: true
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'startAngle',
                    'endAngle',
                    'innerRadius',
                    'outerRadius'
                ]
            }
        },
        indexAxis: 'r',
        startAngle: 0
    };
 static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle , color  }  } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        },
        scales: {
            r: {
                type: 'radialLinear',
                angleLines: {
                    display: false
                },
                beginAtZero: true,
                grid: {
                    circular: true
                },
                pointLabels: {
                    display: false
                },
                startAngle: 0
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);
        return {
            label: labels[index] || '',
            value
        };
    }
    parseObjectData(meta, data, start, count) {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
    }
 getMinMax() {
        const meta = this._cachedMeta;
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        meta.data.forEach((element, index)=>{
            const parsed = this.getParsed(index).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                if (parsed < range.min) {
                    range.min = parsed;
                }
                if (parsed > range.max) {
                    range.max = parsed;
                }
            }
        });
        return range;
    }
 _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for(i = 0; i < start; ++i){
            angle += this._computeAngle(i, mode, defaultAngle);
        }
        for(i = start; i < start + count; i++){
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
                if (animationOpts.animateScale) {
                    outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                    startAngle = endAngle = datasetStartAngle;
                }
            }
            const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
            };
            this.updateElement(arc, i, properties, mode);
        }
    }
    countVisibleElements() {
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index)=>{
            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
                count++;
            }
        });
        return count;
    }
 _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
    }
}

class PieController extends DoughnutController {
    static id = 'pie';
 static defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: '100%'
    };
}

class RadarController extends DatasetController {
    static id = 'radar';
 static defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        indexAxis: 'r',
        showLine: true,
        elements: {
            line: {
                fill: 'start'
            }
        }
    };
 static overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: 'radialLinear'
            }
        }
    };
 getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: vScale.getLabels()[index],
            value: '' + vScale.getLabelForValue(parsed[vScale.axis])
        };
    }
    parseObjectData(meta, data, start, count) {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);
    }
    update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== 'resize') {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
                options.borderWidth = 0;
            }
            const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
            };
            this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const scale = this._cachedMeta.rScale;
        const reset = mode === 'reset';
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
            };
            this.updateElement(point, i, properties, mode);
        }
    }
}

class ScatterController extends DatasetController {
    static id = 'scatter';
 static defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        showLine: false,
        fill: false
    };
 static overrides = {
        interaction: {
            mode: 'point'
        },
        scales: {
            x: {
                type: 'linear'
            },
            y: {
                type: 'linear'
            }
        }
    };
 getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale , yScale  } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        return {
            label: labels[index] || '',
            value: '(' + x + ', ' + y + ')'
        };
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { data: points = []  } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start , count  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {
            start = 0;
            count = points.length;
        }
        if (this.options.showLine) {
            if (!this.datasetElementType) {
                this.addElements();
            }
            const { dataset: line , _dataset  } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
                animated: !animationsDisabled,
                options
            }, mode);
        } else if (this.datasetElementType) {
            delete meta.dataset;
            this.datasetElementType = false;
        }
        this.updateElements(points, start, count, mode);
    }
    addElements() {
        const { showLine  } = this.options;
        if (!this.datasetElementType && showLine) {
            this.datasetElementType = this.chart.registry.getElement('line');
        }
        super.addElements();
    }
    updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps , segment  } = this.options;
        const maxGapLength = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = start; i < start + count; ++i){
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            }
            if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
 getMaxOverflow() {
        const meta = this._cachedMeta;
        const data = meta.data || [];
        if (!this.options.showLine) {
            let max = 0;
            for(let i = data.length - 1; i >= 0; --i){
                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
        }
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        if (!data.length) {
            return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
}

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PieController: PieController,
PolarAreaController: PolarAreaController,
RadarController: RadarController,
ScatterController: ScatterController
});

/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */ function abstract() {
    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */ class DateAdapterBase {
    /**
   * Override default date adapter methods.
   * Accepts type parameter to define options type.
   * @example
   * Chart._adapters._date.override<{myAdapterOption: string}>({
   *   init() {
   *     console.log(this.options.myAdapterOption);
   *   }
   * })
   */ static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
    }
    options;
    constructor(options){
        this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {}
    formats() {
        return abstract();
    }
    parse() {
        return abstract();
    }
    format() {
        return abstract();
    }
    add() {
        return abstract();
    }
    diff() {
        return abstract();
    }
    startOf() {
        return abstract();
    }
    endOf() {
        return abstract();
    }
}
var adapters = {
    _date: DateAdapterBase
};

function binarySearch(metaset, axis, value, intersect) {
    const { controller , data , _sorted  } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B;
        if (!intersect) {
            const result = lookupMethod(data, axis, value);
            if (spanGaps) {
                const { vScale  } = controller._cachedMeta;
                const { _parsed  } = metaset;
                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));
                result.lo -= Math.max(0, distanceToDefinedLo);
                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(point[vScale.axis]));
                result.hi += Math.max(0, distanceToDefinedHi);
            }
            return result;
        } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === 'function' && el.getRange(axis);
            if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
 function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        const { index , data  } = metasets[i];
        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
        for(let j = lo; j <= hi; ++j){
            const element = data[j];
            if (!element.skip) {
                handler(element, index, j);
            }
        }
    }
}
 function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf('x') !== -1;
    const useY = axis.indexOf('y') !== -1;
    return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
 function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
    }
    const evaluationFunc = function(element, datasetIndex, index) {
        if (!includeInvisible && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(element, chart.chartArea, 0)) {
            return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
 function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle , endAngle  } = element.getProps([
            'startAngle',
            'endAngle'
        ], useFinalPosition);
        const { angle  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(element, {
            x: position.x,
            y: position.y
        });
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) {
            return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) {
            return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) {
            items.push({
                element,
                datasetIndex,
                index
            });
        }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
 function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
    }
    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
 function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) {
        return [];
    }
    return items;
}
 var Interaction = {
    evaluateInteractionItems,
    modes: {
 index (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            const axis = options.axis || 'x';
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) {
                return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) {
                    elements.push({
                        element,
                        datasetIndex: meta.index,
                        index
                    });
                }
            });
            return elements;
        },
 dataset (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(let i = 0; i < data.length; ++i){
                    items.push({
                        element: data[i],
                        datasetIndex,
                        index: i
                    });
                }
            }
            return items;
        },
 point (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
 nearest (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            const axis = options.axis || 'xy';
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
 x (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
        },
 y (chart, e, options, useFinalPosition) {
            const position = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, chart);
            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
        }
    }
};

const STATIC_POSITIONS = [
    'left',
    'top',
    'right',
    'bottom'
];
function filterByPosition(array, position) {
    return array.filter((v)=>v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
    return array.sort((a, b)=>{
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        ({ position: pos , options: { stack , stackWeight =1  }  } = box);
        layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts) {
    const stacks = {};
    for (const wrap of layouts){
        const { stack , pos , stackWeight  } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
 function setLayoutDims(layouts, params) {
    const stacks = buildStacks(layouts);
    const { vBoxMaxWidth , hBoxMaxHeight  } = params;
    let i, ilen, layout;
    for(i = 0, ilen = layouts.length; i < ilen; ++i){
        layout = layouts[i];
        const { fullSize  } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos , box  } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {
        if (layout.size) {
            chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos('top');
    chartArea.x += updatePos('left');
    updatePos('right');
    updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach((pos)=>{
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        'left',
        'right'
    ]) : marginForPositions([
        'top',
        'bottom'
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same , other  } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
            refitBoxes.push(layout);
        }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x , y  } = chartArea;
    for (const layout of boxes){
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {
                y = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {
                x = stack.start;
            }
            if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
var layouts = {
 addBox (chart, item) {
        if (!chart.boxes) {
            chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw (chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
 removeBox (chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
            chart.boxes.splice(index, 1);
        }
    },
 configure (chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
 update (chart, width, height, minPadding) {
        if (!chart) {
            return;
        }
        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(chart.boxes, (box)=>{
            if (typeof box.beforeLayout === 'function') {
                box.beforeLayout();
            }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(minPadding));
        const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(boxes.chartArea, (layout)=>{
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};

class BasePlatform {
 acquireContext(canvas, aspectRatio) {}
 releaseContext(context) {
        return false;
    }
 addEventListener(chart, type, listener) {}
 removeEventListener(chart, type, listener) {}
 getDevicePixelRatio() {
        return 1;
    }
 getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
    }
 isAttached(canvas) {
        return true;
    }
 updateConfig(config) {
    }
}

class BasicPlatform extends BasePlatform {
    acquireContext(item) {
        return item && item.getContext && item.getContext('2d') || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
}

const EXPANDO_KEY = '$chartjs';
 const EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
};
const isNullOrEmpty = (value)=>value === null || value === '';
 function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute('height');
    const renderWidth = canvas.getAttribute('width');
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || 'block';
    style.boxSizing = style.boxSizing || 'border-box';
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, 'width');
        if (displayWidth !== undefined) {
            canvas.width = displayWidth;
        }
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === '') {
            canvas.height = canvas.width / (aspectRatio || 2);
        } else {
            const displayHeight = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(canvas, 'height');
            if (displayHeight !== undefined) {
                canvas.height = displayHeight;
            }
        }
    }
    return canvas;
}
const eventListenerOptions = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
    }
}
function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x , y  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList){
        if (node === canvas || node.contains(canvas)) {
            return true;
        }
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
            listener();
        }
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
        return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart)=>{
        if (chart.currentDevicePixelRatio !== dpr) {
            resize();
        }
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
        window.addEventListener('resize', onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
        window.removeEventListener('resize', onWindowResize);
    }
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);
    if (!container) {
        return;
    }
    const resize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((width, height)=>{
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
            listener();
        }
    }, window);
    const observer = new ResizeObserver((entries)=>{
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
            return;
        }
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) {
        observer.disconnect();
    }
    if (type === 'resize') {
        unlistenDevicePixelRatioChanges(chart);
    }
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)((event)=>{
        if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
        }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
 class DomPlatform extends BasePlatform {
 acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext('2d');
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
 releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
            return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        [
            'height',
            'width'
        ].forEach((prop)=>{
            const value = initial[prop];
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {
                canvas.removeAttribute(prop);
            } else {
                canvas.setAttribute(prop, value);
            }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key)=>{
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
 addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
 removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
            return;
        }
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
 getMaximumSize(canvas, width, height, aspectRatio) {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, width, height, aspectRatio);
    }
 isAttached(canvas) {
        const container = canvas && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(canvas);
        return !!(container && container.isConnected);
    }
}

function _detectPlatform(canvas) {
    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
    }
    return DomPlatform;
}

class Element {
    static defaults = {};
    static defaultRoutes = undefined;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    hasValue() {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
            // let's not create an object, if not needed
            return this;
        }
        const ret = {};
        props.forEach((prop)=>{
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
}

function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
 function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
    }
    const factors = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N)(evenMajorSpacing);
    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
        const factor = factors[i];
        if (factor > spacing) {
            return factor;
        }
    }
    return Math.max(spacing, 1);
}
 function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++){
        if (ticks[i].major) {
            result.push(i);
        }
    }
    return result;
}
 function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
        }
    }
}
 function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);
    const end = Math.min((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++){
        if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start + count * spacing);
        }
    }
}
 function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
        return false;
    }
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) {
            return false;
        }
    }
    return diff;
}

const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
 function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for(; i < len; i += increment){
        result.push(arr[Math.floor(i)]);
    }
    return result;
}
 function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex);
    let offset;
    if (offsetGridLines) {
        if (length === 1) {
            offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
            return;
        }
    }
    return lineValue;
}
 function garbageCollect(caches, length) {
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(caches, (cache)=>{
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i){
                delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
        }
    });
}
 function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
 function getTitleHeight(options, fallback) {
    if (!options.display) {
        return 0;
    }
    const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.font, fallback);
    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);
    const lines = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        scale,
        type: 'scale'
    });
}
function createTickContext(parent, index, tick) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        tick,
        index,
        type: 'tick'
    });
}
function titleAlign(align, position, reverse) {
     let ret = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(align);
    if (reverse && position !== 'right' || !reverse && position === 'right') {
        ret = reverseAlign(ret);
    }
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top , left , bottom , right , chart  } = scale;
    const { chartArea , scales  } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === 'center') {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
            titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
    } else {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === 'center') {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
            titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);
        rotation = position === 'left' ? -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H;
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation
    };
}
class Scale extends Element {
    constructor(cfg){
        super();
         this.id = cfg.id;
         this.type = cfg.type;
         this.options = undefined;
         this.ctx = cfg.ctx;
         this.chart = cfg.chart;
         this.top = undefined;
         this.bottom = undefined;
         this.left = undefined;
         this.right = undefined;
         this.width = undefined;
         this.height = undefined;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
         this.maxWidth = undefined;
         this.maxHeight = undefined;
         this.paddingTop = undefined;
         this.paddingBottom = undefined;
         this.paddingLeft = undefined;
         this.paddingRight = undefined;
         this.axis = undefined;
         this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
         this.ticks = [];
         this._gridLineItems = null;
         this._labelItems = null;
         this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
         this._startPixel = undefined;
         this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
    }
 init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
 parse(raw, index) {
        return raw;
    }
 getUserBounds() {
        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
        _userMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, Number.POSITIVE_INFINITY);
        _userMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMin, _suggestedMin),
            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(_userMax, _suggestedMax),
            minDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),
            maxDefined: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)
        };
    }
 getMinMax(canStack) {
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
            return {
                min,
                max
            };
        }
        const metas = this.getMatchingVisibleMetas();
        for(let i = 0, ilen = metas.length; i < ilen; ++i){
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) {
                min = Math.min(min, range.min);
            }
            if (!maxDefined) {
                max = Math.max(max, range.max);
            }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, min)),
            max: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(max, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(min, max))
        };
    }
 getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        };
    }
 getTicks() {
        return this.ticks;
    }
 getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
 getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeUpdate, [
            this
        ]);
    }
 update(maxWidth, maxHeight, margins) {
        const { beginAtZero , grace , ticks: tickOpts  } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R)(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
        }
        if (samplingEnabled) {
            this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
 configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterUpdate, [
            this
        ]);
    }
    beforeSetDimensions() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeSetDimensions, [
            this
        ]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterSetDimensions, [
            this
        ]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options[name], [
            this
        ]);
    }
    beforeDataLimits() {
        this._callHooks('beforeDataLimits');
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks('afterDataLimits');
    }
    beforeBuildTicks() {
        this._callHooks('beforeBuildTicks');
    }
 buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks('afterBuildTicks');
    }
    beforeTickToLabelConversion() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeTickToLabelConversion, [
            this
        ]);
    }
 generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            tick = ticks[i];
            tick.label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(tickOpts.callback, [
                tick.value,
                i,
                ticks
            ], this);
        }
    }
    afterTickToLabelConversion() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterTickToLabelConversion, [
            this
        ]);
    }
    beforeCalculateLabelRotation() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeCalculateLabelRotation, [
            this
        ]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(Math.min(Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterCalculateLabelRotation, [
            this
        ]);
    }
    afterAutoSkip() {}
    beforeFit() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.beforeFit, [
            this
        ]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0
        };
        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first , last , widest , highest  } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const { ticks: { align , padding  } , position  } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === 'start') {
                paddingRight = last.width;
            } else if (align === 'end') {
                paddingLeft = first.width;
            } else if (align !== 'inner') {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === 'start') {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === 'end') {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
 _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.afterFit, [
            this
        ]);
    }
 isHorizontal() {
        const { axis , position  } = this.options;
        return position === 'top' || position === 'bottom' || axis === 'x';
    }
 isFullSize() {
        return this.options.fullSize;
    }
 _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
            }
        }
        this.afterTickToLabelConversion();
    }
 _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
            }
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
    }
 _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx , _longestTextCache: caches  } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for(i = 0; i < length; i += increment){
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {
                width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {
                for(j = 0, jlen = label.length; j < jlen; ++j){
                    nestedLabel =  label[j];
                    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {
                        width = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, cache.data, cache.gc, width, nestedLabel);
                        height += lineHeight;
                    }
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx)=>({
                width: widths[idx] || 0,
                height: heights[idx] || 0
            });
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
        };
    }
 getLabelForValue(value) {
        return value;
    }
 getPixelForValue(value, index) {
        return NaN;
    }
 getValueForPixel(pixel) {}
 getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
 getPixelForDecimal(decimal) {
        if (this._reversePixels) {
            decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W)(this._alignToPixels ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(this.chart, pixel, 0) : pixel);
    }
 getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
 getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
 getBaseValue() {
        const { min , max  } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
 getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
 _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
 _isVisible() {
        const display = this.options.display;
        if (display !== 'auto') {
            return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
    }
 _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid , position , border  } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === 'top') {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === 'bottom') {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === 'left') {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === 'right') {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === 'x') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === 'y') {
            if (position === 'center') {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for(i = 0; i < ticksLength; i += step){
            const context = this.getContext(i);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) {
                continue;
            }
            alignedLineValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, lineValue, lineWidth);
            if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
 _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position , ticks: optionTicks  } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align , crossAlign , padding , mirror  } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = 'middle';
        if (position === 'top') {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'bottom') {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'left') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (position === 'right') {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (axis === 'x') {
            if (position === 'center') {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === 'y') {
            if (position === 'center') {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === 'y') {
            if (align === 'start') {
                textBaseline = 'top';
            } else if (align === 'end') {
                textBaseline = 'bottom';
            }
        }
        const labelSizes = this._getLabelSizes();
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
                x = pixel;
                if (textAlign === 'inner') {
                    if (i === ilen - 1) {
                        tickTextAlign = !this.options.reverse ? 'right' : 'left';
                    } else if (i === 0) {
                        tickTextAlign = !this.options.reverse ? 'left' : 'right';
                    } else {
                        tickTextAlign = 'center';
                    }
                }
                if (position === 'top') {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = -lineCount * lineHeight + lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    } else {
                        textOffset = -labelSizes.highest.height + lineHeight / 2;
                    }
                } else {
                    if (crossAlign === 'near' || rotation !== 0) {
                        textOffset = lineHeight / 2;
                    } else if (crossAlign === 'center') {
                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    } else {
                        textOffset = labelSizes.highest.height - lineCount * lineHeight;
                    }
                }
                if (mirror) {
                    textOffset *= -1;
                }
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                    x += lineHeight / 2 * Math.sin(rotation);
                }
            } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch(textBaseline){
                    case 'middle':
                        top -= height / 2;
                        break;
                    case 'bottom':
                        top -= height;
                        break;
                }
                switch(textAlign){
                    case 'center':
                        left -= width / 2;
                        break;
                    case 'right':
                        left -= width;
                        break;
                    case 'inner':
                        if (i === ilen - 1) {
                            left -= width;
                        } else if (i > 0) {
                            left -= width / 2;
                        }
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor
                };
            }
            items.push({
                label,
                font,
                textOffset,
                options: {
                    rotation,
                    color,
                    strokeColor,
                    strokeWidth,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [
                        x,
                        y
                    ],
                    backdrop
                }
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position , ticks  } = this.options;
        const rotation = -(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);
        if (rotation) {
            return position === 'top' ? 'left' : 'right';
        }
        let align = 'center';
        if (ticks.align === 'start') {
            align = 'left';
        } else if (ticks.align === 'end') {
            align = 'right';
        } else if (ticks.align === 'inner') {
            align = 'inner';
        }
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === 'left') {
            if (mirror) {
                x = this.right + padding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x += widest;
                }
            } else {
                x = this.right - tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x = this.left;
                }
            }
        } else if (position === 'right') {
            if (mirror) {
                x = this.left + padding;
                if (crossAlign === 'near') {
                    textAlign = 'right';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x -= widest / 2;
                } else {
                    textAlign = 'left';
                    x -= widest;
                }
            } else {
                x = this.left + tickAndPadding;
                if (crossAlign === 'near') {
                    textAlign = 'left';
                } else if (crossAlign === 'center') {
                    textAlign = 'center';
                    x += widest / 2;
                } else {
                    textAlign = 'right';
                    x = this.right;
                }
            }
        } else {
            textAlign = 'right';
        }
        return {
            textAlign,
            x
        };
    }
 _computeLabelArea() {
        if (this.options.ticks.mirror) {
            return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === 'left' || position === 'right') {
            return {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right
            };
        }
        if (position === 'top' || position === 'bottom') {
            return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width
            };
        }
    }
 drawBackground() {
        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
            return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex((t)=>t.value === value);
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
 drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style)=>{
            if (!style.width || !style.color) {
                return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) {
            for(i = 0, ilen = items.length; i < ilen; ++i){
                const item = items[i];
                if (grid.drawOnChartArea) {
                    drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                }
                if (grid.drawTicks) {
                    drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
        }
    }
 drawBorder() {
        const { chart , ctx , options: { border , grid  }  } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
            return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
 drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
            return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);
        }
        const items = this.getLabelItems(chartArea);
        for (const item of items){
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y = item.textOffset;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);
        }
    }
 drawTitle() {
        const { ctx , options: { position , title , reverse  }  } = this;
        if (!title.display) {
            return;
        }
        const font = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(title.font);
        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === 'bottom' || position === 'center' || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
            offset += padding.bottom;
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
            }
        } else {
            offset += padding.top;
        }
        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) {
            return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
 _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);
        const bz = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
            return [
                {
                    z: tz,
                    draw: (chartArea)=>{
                        this.draw(chartArea);
                    }
                }
            ];
        }
        return [
            {
                z: gz,
                draw: (chartArea)=>{
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                }
            },
            {
                z: bz,
                draw: ()=>{
                    this.drawBorder();
                }
            },
            {
                z: tz,
                draw: (chartArea)=>{
                    this.drawLabels(chartArea);
                }
            }
        ];
    }
 getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + 'AxisID';
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
            }
        }
        return result;
    }
 _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);
    }
 _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
}

class TypedRegistry {
    constructor(type, scope, override){
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
 register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
            parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + '.' + id;
        if (!id) {
            throw new Error('class does not have id: ' + item);
        }
        if (id in items) {
            return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);
        }
        return scope;
    }
 get(id) {
        return this.items[id];
    }
 unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
            delete items[id];
        }
        if (scope && id in _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {
            delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];
            if (this.override) {
                delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[id];
            }
        }
    }
}
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4)(Object.create(null), [
        parentScope ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},
        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),
        item.defaults
    ]);
    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);
    if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);
    }
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property)=>{
        const propertyParts = property.split('.');
        const sourceName = propertyParts.pop();
        const sourceScope = [
            scope
        ].concat(propertyParts).join('.');
        const parts = routes[property].split('.');
        const targetName = parts.pop();
        const targetScope = parts.join('.');
        _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return 'id' in proto && 'defaults' in proto;
}

class Registry {
    constructor(){
        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
        this.elements = new TypedRegistry(Element, 'elements');
        this.plugins = new TypedRegistry(Object, 'plugins');
        this.scales = new TypedRegistry(Scale, 'scales');
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
 add(...args) {
        this._each('register', args);
    }
    remove(...args) {
        this._each('unregister', args);
    }
 addControllers(...args) {
        this._each('register', args, this.controllers);
    }
 addElements(...args) {
        this._each('register', args, this.elements);
    }
 addPlugins(...args) {
        this._each('register', args, this.plugins);
    }
 addScales(...args) {
        this._each('register', args, this.scales);
    }
 getController(id) {
        return this._get(id, this.controllers, 'controller');
    }
 getElement(id) {
        return this._get(id, this.elements, 'element');
    }
 getPlugin(id) {
        return this._get(id, this.plugins, 'plugin');
    }
 getScale(id) {
        return this._get(id, this.scales, 'scale');
    }
 removeControllers(...args) {
        this._each('unregister', args, this.controllers);
    }
 removeElements(...args) {
        this._each('unregister', args, this.elements);
    }
 removePlugins(...args) {
        this._each('unregister', args, this.plugins);
    }
 removeScales(...args) {
        this._each('unregister', args, this.scales);
    }
 _each(method, args, typedRegistry) {
        [
            ...args
        ].forEach((arg)=>{
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
            } else {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(arg, (item)=>{
                    const itemReg = typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item);
                });
            }
        });
    }
 _exec(method, registry, component) {
        const camelMethod = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5)(method);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component['before' + camelMethod], [], component);
        registry[method](component);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(component['after' + camelMethod], [], component);
    }
 _getRegistryForType(type) {
        for(let i = 0; i < this._typedRegistries.length; i++){
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
                return reg;
            }
        }
        return this.plugins;
    }
 _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) {
            throw new Error('"' + id + '" is not a registered ' + type + '.');
        }
        return item;
    }
}
var registry = /* #__PURE__ */ new Registry();

class PluginService {
    constructor(){
        this._init = [];
    }
 notify(chart, hook, args, filter) {
        if (hook === 'beforeInit') {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, 'install');
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === 'afterDestroy') {
            this._notify(descriptors, chart, 'stop');
            this._notify(this._init, chart, 'uninstall');
        }
        return result;
    }
 _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors){
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
                chart,
                args,
                descriptor.options
            ];
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(method, params, plugin) === false && args.cancelable) {
                return false;
            }
        }
        return true;
    }
    invalidate() {
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
        }
    }
 _descriptors(chart) {
        if (this._cache) {
            return this._cache;
        }
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
    }
 _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
    }
}
 function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for(let i = 0; i < keys.length; i++){
        plugins.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for(let i = 0; i < local.length; i++){
        const plugin = local[i];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins,
        localIds
    };
}
function getOpts(options, all) {
    if (!all && options === false) {
        return null;
    }
    if (options === true) {
        return {};
    }
    return options;
}
function createDescriptors(chart, { plugins , localIds  }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins){
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
            continue;
        }
        result.push({
            plugin,
            options: pluginOpts(chart.config, {
                plugin,
                local: localIds[id]
            }, opts, context)
        });
    }
    return result;
}
function pluginOpts(config, { plugin , local  }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
        scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
        ''
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}

function getIndexAxis(type, options) {
    const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === '_index_') {
        axis = indexAxis;
    } else if (id === '_value_') {
        axis = indexAxis === 'x' ? 'y' : 'x';
    }
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? '_index_' : '_value_';
}
function idMatchesAxis(id) {
    if (id === 'x' || id === 'y' || id === 'r') {
        return id;
    }
}
function axisFromPosition(position) {
    if (position === 'top' || position === 'bottom') {
        return 'x';
    }
    if (position === 'left' || position === 'right') {
        return 'y';
    }
}
function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
        return id;
    }
    for (const opts of scaleOptions){
        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
        if (axis) {
            return axis;
        }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + 'AxisID'] === id) {
        return {
            axis
        };
    }
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
        if (boundDs.length) {
            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
        }
    }
    return {};
}
function mergeScaleConfig(config, options) {
    const chartDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[config.type] || {
        scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales = Object.create(null);
    Object.keys(configScales).forEach((id)=>{
        const scaleConf = configScales[id];
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {
            return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(Object.create(null), [
            {
                axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach((dataset)=>{
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + 'AxisID'] || axis;
            scales[id] = scales[id] || Object.create(null);
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scales[id], [
                {
                    axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales).forEach((key)=>{
        const scale = scales[key];
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(scale, [
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scale
        ]);
    });
    return scales;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
const addIfFound = (set, obj, key)=>{
    const opts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);
    if (opts !== undefined) {
        set.add(opts);
    }
};
class Config {
    constructor(config){
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
 datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, ()=>[
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                [
                    `datasets.${datasetType}.transitions.${transition}`,
                    `transitions.${transition}`
                ],
                [
                    `datasets.${datasetType}`,
                    ''
                ]
            ]);
    }
 datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    ''
                ]
            ]);
    }
 pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, ()=>[
                [
                    `plugins.${id}`,
                    ...plugin.additionalOptionScopes || []
                ]
            ]);
    }
 _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
 getOptionScopes(mainScope, keyLists, resetCache) {
        const { options , type  } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
            return cached;
        }
        const scopes = new Set();
        keyLists.forEach((keys)=>{
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key)=>addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key)=>addIfFound(scopes, options, key));
            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {}, key));
            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d, key));
            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
            array.push(Object.create(null));
        }
        if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
        }
        return array;
    }
 chartOptionScopes() {
        const { options , type  } = this;
        return [
            options,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[type] || {},
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},
            {
                type
            },
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6
        ];
    }
 resolveNamedOptions(scopes, names, context, prefixes = [
        ''
    ]) {
        const result = {
            $shared: true
        };
        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
            result.$shared = false;
            context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, subResolver);
        }
        for (const prop of names){
            result[prop] = options[prop];
        }
        return result;
    }
 createResolver(scopes, context, prefixes = [
        ''
    ], descriptorDefaults) {
        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(resolver, context, undefined, descriptorDefaults) : resolver;
    }
}
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
const hasFunction = (value)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).some((key)=>(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value[key]));
function needContext(proxy, names) {
    const { isScriptable , isIndexable  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa)(proxy);
    for (const prop of names){
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {
            return true;
        }
    }
    return false;
}

var version = "4.5.0";

const KNOWN_POSITIONS = [
    'top',
    'bottom',
    'left',
    'right',
    'chartArea'
];
function positionIsHorizontal(position, axis) {
    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins('afterRender');
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(animationOptions && animationOptions.onProgress, [
        context
    ], chart);
}
 function getCanvas(item) {
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() && typeof item === 'string') {
        item = document.getElementById(item);
    } else if (item && item.length) {
        item = item[0];
    }
    if (item && item.canvas) {
        item = item.canvas;
    }
    return item;
}
const instances = {};
const getChart = (key)=>{
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys){
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
            }
        }
    }
}
 function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === 'mouseout') {
        return null;
    }
    if (isClick) {
        return lastEvent;
    }
    return e;
}
class Chart {
    static defaults = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d;
    static instances = instances;
    static overrides = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3;
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
        registry.add(...items);
        invalidatePlugins();
    }
    static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
    }
    constructor(item, userConfig){
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
            throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac)();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
         this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad)((mode)=>this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, 'complete', onAnimationsComplete);
        animator.listen(this, 'progress', onAnimationProgress);
        this._initialize();
        if (this.attached) {
            this.update();
        }
    }
    get aspectRatio() {
        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {
            return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
        }
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    get registry() {
        return registry;
    }
 _initialize() {
        this.notifyPlugins('beforeInit');
        if (this.options.responsive) {
            this.resize();
        } else {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins('afterInit');
        return this;
    }
    clear() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
 resize(width, height) {
        if (!animator.running(this)) {
            this._resize(width, height);
        } else {
            this._resizeBeforeDraw = {
                width,
                height
            };
        }
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? 'resize' : 'attach';
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this, newRatio, true)) {
            return;
        }
        this.notifyPlugins('resize', {
            size: newSize
        });
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onResize, [
            this,
            newSize
        ], this);
        if (this.attached) {
            if (this._doResize(mode)) {
                this.render();
            }
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scalesOptions, (axisOptions, axisID)=>{
            axisOptions.id = axisID;
        });
    }
 buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id)=>{
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id)=>{
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === 'r';
                const isHorizontal = axis === 'x';
                return {
                    options: scaleOptions,
                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
                };
            }));
        }
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(items, (item)=>{
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) {
                scale = scales[id];
            } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this
                });
                scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(updated, (hasUpdated, id)=>{
            if (!hasUpdated) {
                delete scales[id];
            }
        });
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(scales, (scale)=>{
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
 _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b)=>a.index - b.index);
        if (numMeta > numData) {
            for(let i = numData; i < numMeta; ++i){
                this._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
    }
 _removeUnreferencedMetasets() {
        const { _metasets: metasets , data: { datasets  }  } = this;
        if (metasets.length > datasets.length) {
            delete this._stacks;
        }
        metasets.forEach((meta, index)=>{
            if (datasets.filter((x)=>x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index);
            }
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for(i = 0, ilen = datasets.length; i < ilen; i++){
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = '' + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType , dataElementType  } = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];
                Object.assign(ControllerClass, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
 _resetElements() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.data.datasets, (dataset, datasetIndex)=>{
            this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
    }
 reset() {
        this._resetElements();
        this.notifyPlugins('reset');
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins('beforeUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins('beforeElementsUpdate');
        let minPadding = 0;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
            const { controller  } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(newControllers, (controller)=>{
                controller.reset();
            });
        }
        this._updateDatasets(mode);
        this.notifyPlugins('afterUpdate', {
            mode
        });
        this._layers.sort(compare2Level('z', '_idx'));
        const { _active , _lastEvent  } = this;
        if (_lastEvent) {
            this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
            this._updateHoverStyles(_active, _active, true);
        }
        this.render();
    }
 _updateScales() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.scales, (scale)=>{
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
 _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
 _updateHiddenIndices() {
        const { _hiddenIndices  } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method , start , count  } of changes){
            const move = method === '_removeElements' ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
 _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
            return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
        const changeSet = makeSet(0);
        for(let i = 1; i < datasetCount; i++){
            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(changeSet, makeSet(i))) {
                return;
            }
        }
        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
                method: a[1],
                start: +a[2],
                count: +a[3]
            }));
    }
 _updateLayout(minPadding) {
        if (this.notifyPlugins('beforeLayout', {
            cancelable: true
        }) === false) {
            return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.boxes, (box)=>{
            if (noArea && box.position === 'chartArea') {
                return;
            }
            if (box.configure) {
                box.configure();
            }
            this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index)=>{
            item._idx = index;
        });
        this.notifyPlugins('afterLayout');
    }
 _updateDatasets(mode) {
        if (this.notifyPlugins('beforeDatasetsUpdate', {
            mode,
            cancelable: true
        }) === false) {
            return;
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this.getDatasetMeta(i).controller.configure();
        }
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._updateDataset(i, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(mode) ? mode({
                datasetIndex: i
            }) : mode);
        }
        this.notifyPlugins('afterDatasetsUpdate', {
            mode
        });
    }
 _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
            return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetUpdate', args);
    }
    render() {
        if (this.notifyPlugins('beforeRender', {
            cancelable: true
        }) === false) {
            return;
        }
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) {
                animator.start(this);
            }
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this
            });
        }
    }
    draw() {
        let i;
        if (this._resizeBeforeDraw) {
            const { width , height  } = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null;
            this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
            return;
        }
        if (this.notifyPlugins('beforeDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const layers = this._layers;
        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
            layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for(; i < layers.length; ++i){
            layers[i].draw(this.chartArea);
        }
        this.notifyPlugins('afterDraw');
    }
 _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
                result.push(meta);
            }
        }
        return result;
    }
 getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
 _drawDatasets() {
        if (this.notifyPlugins('beforeDatasetsDraw', {
            cancelable: true
        }) === false) {
            return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            this._drawDataset(metasets[i]);
        }
        this.notifyPlugins('afterDatasetsDraw');
    }
 _drawDataset(meta) {
        const ctx = this.ctx;
        const args = {
            meta,
            index: meta.index,
            cancelable: true
        };
        const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(this, meta);
        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
            return;
        }
        if (clip) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, clip);
        }
        meta.controller.draw();
        if (clip) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins('afterDatasetDraw', args);
    }
 isPointInArea(point) {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === 'function') {
            return method(this, e, options, useFinalPosition);
        }
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return this.$context || (this.$context = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(null, {
            chart: this,
            type: 'chart'
        }));
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
            return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
 _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? 'show' : 'hide';
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible
            });
            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
 _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
            meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
            this._destroyDatasetMeta(i);
        }
    }
    destroy() {
        this.notifyPlugins('beforeDestroy');
        const { canvas , ctx  } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins('afterDestroy');
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
 bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
            this.bindResponsiveEvents();
        } else {
            this.attached = true;
        }
    }
 bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const listener = (e, x, y)=>{
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
        };
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.options.events, (type)=>_add(type, listener));
    }
 bindResponsiveEvents() {
        if (!this._responsiveListeners) {
            this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const _remove = (type, listener)=>{
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
            }
        };
        const listener = (width, height)=>{
            if (this.canvas) {
                this.resize(width, height);
            }
        };
        let detached;
        const attached = ()=>{
            _remove('attach', attached);
            this.attached = true;
            this.resize();
            _add('resize', listener);
            _add('detach', detached);
        };
        detached = ()=>{
            this.attached = false;
            _remove('resize', listener);
            this._stop();
            this._resize(0, 0);
            _add('attach', attached);
        };
        if (platform.isAttached(this.canvas)) {
            attached();
        } else {
            detached();
        }
    }
 unbindEvents() {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._listeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this._responsiveListeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? 'set' : 'remove';
        let meta, item, i, ilen;
        if (mode === 'dataset') {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller['_' + prefix + 'DatasetHoverStyle']();
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
            }
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('No dataset found at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
 notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
    }
 isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
    }
 _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
            this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
    }
 _eventHandler(e, replay) {
        const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
            return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins('afterEvent', args, eventFilter);
        if (changed || args.changed) {
            this.render();
        }
        return this;
    }
 _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [] , options  } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj)(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onHover, [
                e,
                active,
                this
            ], this);
            if (isClick) {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(options.onClick, [
                    e,
                    active,
                    this
                ], this);
            }
        }
        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
 _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
}
function invalidatePlugins() {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(Chart.instances, (chart)=>chart._plugins.invalidate());
}

function clipSelf(ctx, element, endAngle) {
    const { startAngle , x , y , outerRadius , innerRadius , options  } = element;
    const { borderWidth , borderJoinStyle  } = options;
    const outerAngleClip = Math.min(borderWidth / outerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));
    ctx.beginPath();
    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);
    if (innerRadius > 0) {
        const innerAngleClip = Math.min(borderWidth / innerRadius, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));
        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);
    } else {
        const clipWidth = Math.min(borderWidth / 2, outerRadius * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(startAngle - endAngle));
        if (borderJoinStyle === 'round') {
            ctx.arc(x, y, clipWidth, endAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2, true);
        } else if (borderJoinStyle === 'bevel') {
            const r = 2 * clipWidth * clipWidth;
            const endX = -r * Math.cos(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;
            const endY = -r * Math.sin(endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;
            const startX = r * Math.cos(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + x;
            const startY = r * Math.sin(startAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / 2) + y;
            ctx.lineTo(endX, endY);
            ctx.lineTo(startX, startY);
        }
    }
    ctx.closePath();
    ctx.moveTo(0, 0);
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.clip('evenodd');
}
function clipArc(ctx, element, endAngle) {
    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
    let angleMargin = pixelMargin / outerRadius;
    // Draw an inner border by clipping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);
    }
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am)(value, [
        'outerStart',
        'outerEnd',
        'innerStart',
        'innerEnd'
    ]);
}
/**
 * Parse border radius from the provided options
 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    // Outer limits are complicated. We want to compute the available angular distance at
    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
    //
    // If the borderRadius is large, that value can become negative.
    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
    // we know that the thickness term will dominate and compute the limits at that point
    const computeOuterLimit = (val)=>{
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerStart, 0, innerLimit),
        innerEnd: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(o.innerEnd, 0, innerLimit)
    };
}
/**
 * Convert (r, ) to (x, y)
 */ function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */ function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha = end - start;
    if (spacing) {
        // When spacing is present, it is the same for all items
        // So we adjust the start and end angle of the arc such that
        // the distance is the same as it would be without the spacing
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;
    const angleOffset = (alpha - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        // The first arc segments from point 1 to point a to point 2
        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        // The corner segment from point 2 to point 3
        if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);
        }
        // The line from point 3 to point 4
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        // The corner segment from point 4 to point 5
        if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);
        }
        // The inner arc from point 5 to point b to point 6
        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
        // The corner segment from point 6 to point 7
        if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H);
        }
        // The line from point 7 to point 8
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        // The corner segment from point 8 to point 1
        if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);
        }
    } else {
        ctx.moveTo(x, y);
        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerStartX, outerStartY);
        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference  } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.fill();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
        }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles , startAngle , circumference , options  } = element;
    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset , borderRadius  } = options;
    const inner = options.borderAlign === 'inner';
    if (!borderWidth) {
        return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || 'round';
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || 'bevel';
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i){
            ctx.stroke();
        }
        if (!isNaN(circumference)) {
            endAngle = startAngle + (circumference % _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
        }
    }
    if (inner) {
        clipArc(ctx, element, endAngle);
    }
    if (options.selfJoin && endAngle - startAngle >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P && borderRadius === 0 && borderJoinStyle !== 'miter') {
        clipSelf(ctx, element, endAngle);
    }
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
class ArcElement extends Element {
    static id = 'arc';
    static defaults = {
        borderAlign: 'center',
        borderColor: '#fff',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: undefined,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: undefined,
        circular: true,
        selfJoin: false
    };
    static defaultRoutes = {
        backgroundColor: 'backgroundColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash'
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg){
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        const { angle , distance  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(point, {
            x: chartX,
            y: chartY
        });
        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius',
            'circumference'
        ], useFinalPosition);
        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
        const _circumference = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);
        const nonZeroBetween = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle) && startAngle !== endAngle;
        const betweenAngles = _circumference >= _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T || nonZeroBetween;
        const withinRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
            'x',
            'y',
            'startAngle',
            'endAngle',
            'innerRadius',
            'outerRadius'
        ], useFinalPosition);
        const { offset , spacing  } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options , circumference  } = this;
        const offset = (options.offset || 0) / 4;
        const spacing = (options.spacing || 0) / 2;
        const circular = options.circular;
        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
        this.fullCircles = circumference > _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
            return;
        }
        ctx.save();
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
        const fix = 1 - Math.sin(Math.min(_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P, circumference || 0));
        const radiusOffset = offset * fix;
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        drawArc(ctx, this, radiusOffset, spacing, circular);
        drawBorder(ctx, this, radiusOffset, spacing, circular);
        ctx.restore();
    }
}

function setStyle(ctx, options, style = options) {
    ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));
    ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
 function getLineMethod(options) {
    if (options.stepped) {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au;
    }
    return lineTo;
}
function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
    const { start: segmentStart , end: segmentEnd  } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
 function pathSegment(ctx, line, segment, params) {
    const { points , options  } = line;
    const { count , start , loop , ilen  } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move =true , reverse  } = params || {};
    let i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
            continue;
        } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else {
            lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
 function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count , start , ilen  } = pathVars(points, segment, params);
    const { move =true , reverse  } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
    const drawX = ()=>{
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) {
            continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
            } else if (y > maxY) {
                maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
 function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
 function _getInterpolationMethod(options) {
    if (options.stepped) {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq;
    }
    if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar;
    }
    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as;
}
function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) {
            path.closePath();
        }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    const { segments , options  } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments){
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
        })) {
            ctx.closePath();
        }
        ctx.stroke();
    }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
    } else {
        strokePathDirect(ctx, line, start, count);
    }
}
class LineElement extends Element {
    static id = 'line';
 static defaults = {
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: 'default',
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
    };
    constructor(cfg){
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an)(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
        }
    }
    set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
    }
    get points() {
        return this._points;
    }
    get segments() {
        return this._segments || (this._segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(this, this.options.segment));
    }
 first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
    }
 last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
    }
 interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(this, {
            property,
            start: value,
            end: value
        });
        if (!segments.length) {
            return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for(i = 0, ilen = segments.length; i < ilen; ++i){
            const { start , end  } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
                result.push(p1);
                continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
    }
 pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
    }
 path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments){
            loop &= segmentMethod(ctx, this, segment, {
                start,
                end: start + count - 1
            });
        }
        return !!loop;
    }
 draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
        }
        if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
        }
    }
}

function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value  } = el.getProps([
        axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
    static id = 'point';
    parsed;
    skip;
    stop;
    /**
   * @type {any}
   */ static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: 'circle',
        radius: 3,
        rotation: 0
    };
    /**
   * @type {any}
   */ static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, 'x', useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, 'y', useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y  } = this.getProps([
            'x',
            'y'
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, area, this.size(options) / 2)) {
            return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, options, this.x, this.y);
    }
    getRange() {
        const options = this.options || {};
        // @ts-expect-error Fallbacks should never be hit in practice
        return options.radius + options.hitRadius;
    }
}

function getBarBounds(bar, useFinalPosition) {
    const { x , y , base , width , height  } =  bar.getProps([
        'x',
        'y',
        'base',
        'width',
        'height'
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left,
        top,
        right,
        bottom
    };
}
function skipOrLimit(skip, value, min, max) {
    return skip ? 0 : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip = bar.borderSkipped;
    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(value);
    return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius  } = bar.getProps([
        'enableBorderRadius'
    ]);
    const value = bar.options.borderRadius;
    const o = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(value);
    const maxR = Math.min(maxW, maxH);
    const skip = bar.borderSkipped;
    const enableBorder = enableBorderRadius || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
 function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
class BarElement extends Element {
    static id = 'bar';
 static defaults = {
        borderSkipped: 'start',
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: 'auto',
        pointStyle: undefined
    };
 static defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor'
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    draw(ctx) {
        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
        const { inner , outer  } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill('evenodd');
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x , y , base , horizontal  } =  this.getProps([
            'x',
            'y',
            'base',
            'horizontal'
        ], useFinalPosition);
        return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
        };
    }
    getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
    }
}

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
BarElement: BarElement,
LineElement: LineElement,
PointElement: PointElement
});

const BORDER_COLORS = [
    'rgb(54, 162, 235)',
    'rgb(255, 99, 132)',
    'rgb(255, 159, 64)',
    'rgb(255, 205, 86)',
    'rgb(75, 192, 192)',
    'rgb(153, 102, 255)',
    'rgb(201, 203, 207)' // grey
];
// Border colors with 50% transparency
const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
    return i;
}
function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
    return i;
}
function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex)=>{
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        if (controller instanceof DoughnutController) {
            i = colorizeDoughnutDataset(dataset, i);
        } else if (controller instanceof PolarAreaController) {
            i = colorizePolarAreaDataset(dataset, i);
        } else if (controller) {
            i = colorizeDefaultDataset(dataset, i);
        }
    };
}
function containsColorsDefinitions(descriptors) {
    let k;
    for(k in descriptors){
        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
            return true;
        }
    }
    return false;
}
function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
    return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.borderColor !== 'rgba(0,0,0,0.1)' || _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.backgroundColor !== 'rgba(0,0,0,0.1)';
}
var plugin_colors = {
    id: 'colors',
    defaults: {
        enabled: true,
        forceOverride: false
    },
    beforeLayout (chart, _args, options) {
        if (!options.enabled) {
            return;
        }
        const { data: { datasets  } , options: chartOptions  } = chart.config;
        const { elements  } = chartOptions;
        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
        if (!options.forceOverride && containsColorDefenition) {
            return;
        }
        const colorizer = getColorizer(chart);
        datasets.forEach(colorizer);
    }
};

function lttbDecimation(data, start, count, availableWidth, options) {
 const samples = options.samples || availableWidth;
    if (samples >= count) {
        return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const { x: pointAx , y: pointAy  } = data[a];
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            const lastIndex = i - 1;
            if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex1],
                        x: avgX
                    });
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                    decimated.push({
                        ...data[intermediateIndex2],
                        x: avgX
                    });
                }
            }
            if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, 'data', {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset)=>{
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale  } = meta;
    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
    if (minDefined) {
        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
        count = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
        count = pointCount - start;
    }
    return {
        start,
        count
    };
}
var plugin_decimation = {
    id: 'decimation',
    defaults: {
        algorithm: 'min-max',
        enabled: false
    },
    beforeElementsUpdate: (chart, args, options)=>{
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
            const { _data , indexAxis  } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                indexAxis,
                chart.options.indexAxis
            ]) === 'y') {
                return;
            }
            if (!meta.controller.supportsDecimation) {
                return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                return;
            }
            if (chart.options.parsing) {
                return;
            }
            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, 'data', {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this._decimated;
                    },
                    set: function(d) {
                        this._data = d;
                    }
                });
            }
            let decimated;
            switch(options.algorithm){
                case 'lttb':
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case 'min-max':
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
        });
    },
    destroy (chart) {
        cleanDecimatedData(chart);
    }
};

function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments){
        let { start , end  } = segment;
        end = _findSegmentEnd(start, end, points);
        const bounds = _getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
            parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
            });
            continue;
        }
        const targetSegments = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap)(target, bounds);
        for (const tgt of targetSegments){
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(segment, points, subBounds);
            for (const fillSource of fillSources){
                parts.push({
                    source: fillSource,
                    target: tgt,
                    start: {
                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                    },
                    end: {
                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                    }
                });
            }
        }
    }
    return parts;
}
function _getBounds(property, first, last, loop) {
    if (loop) {
        return;
    }
    let start = first[property];
    let end = last[property];
    if (property === 'angle') {
        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(start);
        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(end);
    }
    return {
        property,
        start,
        end
    };
}
function _pointsFromSegments(boundary, line) {
    const { x =null , y =null  } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start , end  })=>{
        end = _findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y
            });
            points.push({
                x: last.x,
                y
            });
        } else if (x !== null) {
            points.push({
                x,
                y: first.y
            });
            points.push({
                x,
                y: last.y
            });
        }
    });
    return points;
}
function _findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
        }
    }
    return end;
}
function _getEdge(a, b, prop, fn) {
    if (a && b) {
        return fn(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
}

function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {
        _loop = true;
        points = boundary;
    } else {
        points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
        points,
        options: {
            tension: 0
        },
        _loop,
        _fullLoop: _loop
    }) : null;
}
function _shouldApplyFill(source) {
    return source && source.fill !== false;
}

function _resolveTarget(sources, index, propagate) {
    const source = sources[index];
    let fill = source.fill;
    const visited = [
        index
    ];
    let target;
    if (!propagate) {
        return fill;
    }
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {
            return fill;
        }
        target = sources[fill];
        if (!target) {
            return false;
        }
        if (target.visible) {
            return fill;
        }
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
 function _decodeFill(line, index, count) {
     const fill = parseFillOption(line);
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
        return isNaN(fill.value) ? false : fill;
    }
    let target = parseFloat(fill);
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {
        return decodeTargetIndex(fill[0], index, target, count);
    }
    return [
        'origin',
        'start',
        'end',
        'stack',
        'shape'
    ].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
    if (firstCh === '-' || firstCh === '+') {
        target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
        return false;
    }
    return target;
}
 function _getTargetPixel(fill, scale) {
    let pixel = null;
    if (fill === 'start') {
        pixel = scale.bottom;
    } else if (fill === 'end') {
        pixel = scale.top;
    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
        pixel = scale.getPixelForValue(fill.value);
    } else if (scale.getBasePixel) {
        pixel = scale.getBasePixel();
    }
    return pixel;
}
 function _getTargetValue(fill, scale, startValue) {
    let value;
    if (fill === 'start') {
        value = startValue;
    } else if (fill === 'end') {
        value = scale.options.reverse ? scale.min : scale.max;
    } else if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
        value = fill.value;
    } else {
        value = scale.getBaseValue();
    }
    return value;
}
 function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);
    if (fill === undefined) {
        fill = !!options.backgroundColor;
    }
    if (fill === false || fill === null) {
        return false;
    }
    if (fill === true) {
        return 'origin';
    }
    return fill;
}

function _buildStackLine(source) {
    const { scale , index , line  } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index);
    linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        for(let j = segment.start; j <= segment.end; j++){
            addPointsBelow(points, sourcePoints[j], linesBelow);
        }
    }
    return new LineElement({
        points,
        options: {}
    });
}
 function getLinesBelow(scale, index) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas('line');
    for(let i = 0; i < metas.length; i++){
        const meta = metas[i];
        if (meta.index === index) {
            break;
        }
        if (!meta.hidden) {
            below.unshift(meta.dataset);
        }
    }
    return below;
}
 function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for(let j = 0; j < linesBelow.length; j++){
        const line = linesBelow[j];
        const { first , last , point  } = findPoint(line, sourcePoint, 'x');
        if (!point || first && last) {
            continue;
        }
        if (first) {
            postponed.unshift(point);
        } else {
            points.push(point);
            if (!last) {
                break;
            }
        }
    }
    points.push(...postponed);
}
 function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
        return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first,
        last,
        point
    };
}

class simpleArc {
    constructor(opts){
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
        const { x , y , radius  } = this;
        bounds = bounds || {
            start: 0,
            end: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
    }
    interpolate(point) {
        const { x , y , radius  } = this;
        const angle = point.angle;
        return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
        };
    }
}

function _getTarget(source) {
    const { chart , fill , line  } = source;
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {
        return getLineByIndex(chart, fill);
    }
    if (fill === 'stack') {
        return _buildStackLine(source);
    }
    if (fill === 'shape') {
        return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
        return boundary;
    }
    return _createBoundaryLine(boundary, line);
}
 function getLineByIndex(chart, index) {
    const meta = chart.getDatasetMeta(index);
    const visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
    const { scale ={} , fill  } = source;
    const pixel = _getTargetPixel(fill, scale);
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
        };
    }
    return null;
}
function computeCircularBoundary(source) {
    const { scale , fill  } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill, scale, start);
    const target = [];
    if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(let i = 0; i < length; ++i){
        target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
}

function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { chart , index , line , scale , axis  } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color = lineOpts.backgroundColor;
    const { above =color , below =color  } = fillOption || {};
    const meta = chart.getDatasetMeta(index);
    const clip = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(chart, meta);
    if (target && line.points.length) {
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, area);
        doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis,
            clip
        });
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);
    }
}
function doFill(ctx, cfg) {
    const { line , target , above , below , area , scale , clip  } = cfg;
    const property = line._loop ? 'angle' : cfg.axis;
    ctx.save();
    let fillColor = below;
    if (below !== above) {
        if (property === 'x') {
            clipVertical(ctx, target, area.top);
            fill(ctx, {
                line,
                target,
                color: above,
                scale,
                property,
                clip
            });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
        } else if (property === 'y') {
            clipHorizontal(ctx, target, area.left);
            fill(ctx, {
                line,
                target,
                color: below,
                scale,
                property,
                clip
            });
            ctx.restore();
            ctx.save();
            clipHorizontal(ctx, target, area.right);
            fillColor = above;
        }
    }
    fill(ctx, {
        line,
        target,
        color: fillColor,
        scale,
        property,
        clip
    });
    ctx.restore();
}
function clipVertical(ctx, target, clipY) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) {
            ctx.closePath();
        } else {
            ctx.lineTo(lastPoint.x, clipY);
        }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function clipHorizontal(ctx, target, clipX) {
    const { segments , points  } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start , end  } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(clipX, firstPoint.y);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) {
            ctx.closePath();
        } else {
            ctx.lineTo(clipX, lastPoint.y);
        }
    }
    ctx.lineTo(clipX, target.first().y);
    ctx.closePath();
    ctx.clip();
}
function fill(ctx, cfg) {
    const { line , target , property , color , scale , clip  } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src , target: tgt , start , end  } of segments){
        const { style: { backgroundColor =color  } = {}  } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
            if (lineLoop) {
                ctx.closePath();
            } else {
                interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
            }
        }
        ctx.closePath();
        ctx.fill(loop ? 'evenodd' : 'nonzero');
        ctx.restore();
    }
}
function clipBounds(ctx, scale, clip, bounds) {
    const chartArea = scale.chart.chartArea;
    const { property , start , end  } = bounds || {};
    if (property === 'x' || property === 'y') {
        let left, top, right, bottom;
        if (property === 'x') {
            left = start;
            top = chartArea.top;
            right = end;
            bottom = chartArea.bottom;
        } else {
            left = chartArea.left;
            top = start;
            right = chartArea.right;
            bottom = end;
        }
        ctx.beginPath();
        if (clip) {
            left = Math.max(left, clip.left);
            right = Math.min(right, clip.right);
            top = Math.max(top, clip.top);
            bottom = Math.min(bottom, clip.bottom);
        }
        ctx.rect(left, top, right - left, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
}

var index = {
    id: 'filler',
    afterDatasetsUpdate (chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
                source = {
                    visible: chart.isDatasetVisible(i),
                    index: i,
                    fill: _decodeFill(line, i, count),
                    chart,
                    axis: meta.controller.options.indexAxis,
                    scale: meta.vScale,
                    line
                };
            }
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) {
                continue;
            }
            source.fill = _resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw (chart, _args, options) {
        const draw = options.drawTime === 'beforeDraw';
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (!source) {
                continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) {
                _drawfill(chart.ctx, source, area);
            }
        }
    },
    beforeDatasetsDraw (chart, _args, options) {
        if (options.drawTime !== 'beforeDatasetsDraw') {
            return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) {
                _drawfill(chart.ctx, source, chart.chartArea);
            }
        }
    },
    beforeDatasetDraw (chart, args, options) {
        const source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
            return;
        }
        _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: 'beforeDatasetDraw'
    }
};

const getBoxSize = (labelOpts, fontSize)=>{
    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
 constructor(config){
        super();
        this._added = false;
        this.legendHitBoxes = [];
 this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(labelOpts.generateLabels, [
            this.chart
        ], this) || [];
        if (labelOpts.filter) {
            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
            legendItems.reverse();
        }
        this.legendItems = legendItems;
    }
    fit() {
        const { options , ctx  } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
 _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
            0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i)=>{
            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) {
            return;
        }
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes){
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes){
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === 'top' || this.options.position === 'bottom';
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx, this);
            this._draw();
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);
        }
    }
 _draw() {
        const { options: opts , columnSizes , lineWidths , ctx  } = this;
        const { align , labels: labelOpts  } = opts;
        const defaultColor = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.color;
        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);
        const labelFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(labelOpts.font);
        const { padding  } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign('left');
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
            }
            ctx.save();
            const lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);
            ctx.fillStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);
            ctx.lineCap = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, 'butt');
            ctx.lineDashOffset = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);
            ctx.lineJoin = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, 'miter');
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: boxHeight * Math.SQRT2 / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v)=>v !== 0)) {
                    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {
                        x: xBoxLeft,
                        y: yBoxTop,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius
                    });
                } else {
                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                    ctx.stroke();
                }
            }
            ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
            cursor = {
                x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
            };
        } else {
            cursor = {
                x: this.left + padding,
                y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
            };
        }
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i)=>{
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                    y = cursor.y += lineHeight;
                    cursor.line++;
                    x = cursor.x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
            } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
                cursor.x += width + padding;
            } else if (typeof legendItem.text !== 'string') {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
            } else {
                cursor.y += lineHeight;
            }
        });
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);
    }
 drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);
        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);
        if (!titleOpts.display) {
            return;
        }
        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(position));
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, titleOpts.text, x, y, titleFont);
    }
 _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(titleOpts.font);
        const titlePadding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
 _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for(i = 0; i < lh.length; ++i){
                hitBox = lh[i];
                if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {
                    return this.legendItems[i];
                }
            }
        }
        return null;
    }
 handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
            return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === 'mousemove' || e.type === 'mouseout') {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onLeave, [
                    e,
                    previous,
                    this
                ], this);
            }
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onHover, [
                    e,
                    hoveredItem,
                    this
                ], this);
            }
        } else if (hoveredItem) {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(opts.onClick, [
                e,
                hoveredItem,
                this
            ], this);
        }
    }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth,
        itemHeight
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== 'string') {
        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== 'string') {
        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
        return true;
    }
    if (opts.onClick && (type === 'click' || type === 'mouseup')) {
        return true;
    }
    return false;
}
var plugin_legend = {
    id: 'legend',
 _element: Legend,
    start (chart, _args, options) {
        const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop (chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate (chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate (chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent (chart, args) {
        if (!args.replay) {
            chart.legend.handleEvent(args.event);
        }
    },
    defaults: {
        display: true,
        position: 'top',
        align: 'center',
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick (e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx)=>ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels (chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta)=>{
                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    const borderWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: (ctx)=>ctx.chart.options.color,
            display: false,
            position: 'center',
            text: ''
        }
    },
    descriptors: {
        _scriptable: (name)=>!name.startsWith('on'),
        labels: {
            _scriptable: (name)=>![
                    'generateLabels',
                    'filter',
                    'sort'
                ].includes(name)
        }
    }
};

class Title extends Element {
 constructor(config){
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;
        this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.padding);
        const textSize = lineCount * (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
            this.height = textSize;
        } else {
            this.width = textSize;
        }
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
    }
    _drawArgs(offset) {
        const { top , left , bottom , right , options  } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === 'left') {
                titleX = left + offset;
                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, bottom, top);
                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;
            } else {
                titleX = right - offset;
                titleY = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(align, top, bottom);
                rotation = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
            return;
        }
        const fontOpts = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(opts.align),
            textBaseline: 'middle',
            translation: [
                titleX,
                titleY
            ]
        });
    }
}
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: 'title',
 _element: Title,
    start (chart, _args, options) {
        createTitle(chart, options);
    },
    stop (chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate (chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'bold'
        },
        fullSize: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const map = new WeakMap();
var plugin_subtitle = {
    id: 'subtitle',
    start (chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop (chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate (chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: 'center',
        display: false,
        font: {
            weight: 'normal'
        },
        fullSize: true,
        padding: 0,
        position: 'top',
        text: '',
        weight: 1500
    },
    defaultRoutes: {
        color: 'color'
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};

const positioners = {
 average (items) {
        if (!items.length) {
            return false;
        }
        let i, len;
        let xSet = new Set();
        let y = 0;
        let count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                xSet.add(pos.x);
                y += pos.y;
                ++count;
            }
        }
        if (count === 0 || xSet.size === 0) {
            return false;
        }
        const xAverage = [
            ...xSet
        ].reduce((a, b)=>a + b) / xSet.size;
        return {
            x: xAverage,
            y: y / count
        };
    },
 nearest (items, eventPosition) {
        if (!items.length) {
            return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF)(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x,
            y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {
            Array.prototype.push.apply(base, toPush);
        } else {
            base.push(toPush);
        }
    }
    return base;
}
 function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
    }
    return str;
}
 function createTooltipItem(chart, item) {
    const { element , datasetIndex , index  } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label , value  } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
    };
}
 function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body , footer , title  } = tooltip;
    const { boxWidth , boxHeight  } = options;
    const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);
    const titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);
    const footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(body, (bodyItem)=>{
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, maxLineWidth);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.lines, maxLineWidth);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height
    };
}
function determineYAlign(chart, size) {
    const { y , height  } = size;
    if (y < height / 2) {
        return 'top';
    } else if (y > chart.height - height / 2) {
        return 'bottom';
    }
    return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x , width  } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === 'left' && x + width + caret > chart.width) {
        return true;
    }
    if (xAlign === 'right' && x - width - caret < 0) {
        return true;
    }
}
function determineXAlign(chart, options, size, yAlign) {
    const { x , width  } = size;
    const { width: chartWidth , chartArea: { left , right  }  } = chart;
    let xAlign = 'center';
    if (yAlign === 'center') {
        xAlign = x <= (left + right) / 2 ? 'left' : 'right';
    } else if (x <= width / 2) {
        xAlign = 'left';
    } else if (x >= chartWidth - width / 2) {
        xAlign = 'right';
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = 'center';
    }
    return xAlign;
}
 function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
    };
}
function alignX(size, xAlign) {
    let { x , width  } = size;
    if (xAlign === 'right') {
        x -= width;
    } else if (xAlign === 'center') {
        x -= width / 2;
    }
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y , height  } = size;
    if (yAlign === 'top') {
        y += paddingAndSize;
    } else if (yAlign === 'bottom') {
        y -= height + paddingAndSize;
    } else {
        y -= height / 2;
    }
    return y;
}
 function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize , caretPadding , cornerRadius  } = options;
    const { xAlign , yAlign  } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft , topRight , bottomLeft , bottomRight  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === 'center') {
        if (xAlign === 'left') {
            x += paddingAndSize;
        } else if (xAlign === 'right') {
            x -= paddingAndSize;
        }
    } else if (xAlign === 'left') {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === 'right') {
        x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
        x: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(x, 0, chart.width - size.width),
        y: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);
    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
 function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        tooltip,
        tooltipItems,
        type: 'tooltip'
    });
}
function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
    beforeTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    title (tooltipItems) {
        if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === 'dataset') {
                return item.dataset.label || '';
            } else if (item.label) {
                return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
            }
        }
        return '';
    },
    afterTitle: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    beforeBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    beforeLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    label (tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
            label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {
            label += value;
        }
        return label;
    },
    labelColor (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
        };
    },
    labelTextColor () {
        return this.options.bodyColor;
    },
    labelPointStyle (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
        };
    },
    afterLabel: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    afterBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    beforeFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    footer: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
    afterFooter: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG
};
 function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === 'undefined') {
        return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
}
class Tooltip extends Element {
 static positioners = positioners;
    constructor(config){
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
    }
    initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
    }
 _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
            return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
            this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
    }
 getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
        const { callbacks  } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
    }
    getBody(tooltipItems, options) {
        const { callbacks  } = options;
        const bodyItems = [];
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{
            const bodyItem = {
                before: [],
                lines: [],
                after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
        const { callbacks  } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
 _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for(i = 0, len = active.length; i < len; ++i){
            tooltipItems.push(createTooltipItem(this.chart, active[i]));
        }
        if (options.filter) {
            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
        }
        if (options.itemSort) {
            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
        }
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(tooltipItems, (context)=>{
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) {
                properties = {
                    opacity: 0
                };
            }
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) {
            this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
            options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay
            });
        }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign , yAlign  } = this;
        const { caretSize , cornerRadius  } = options;
        const { topLeft , topRight , bottomLeft , bottomRight  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(cornerRadius);
        const { x: ptX , y: ptY  } = tooltipPoint;
        const { width , height  } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === 'center') {
            y2 = ptY + height / 2;
            if (xAlign === 'left') {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === 'left') {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            } else if (xAlign === 'right') {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            } else {
                x2 = this.caretX;
            }
            if (yAlign === 'top') {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
        };
    }
    drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = 'middle';
            titleFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                    pt.y += options.titleMarginBottom - titleSpacing;
                }
            }
        }
    }
 _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColor = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight , boxWidth  } = options;
        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);
        const colorX = getAlignedX(this, 'left', options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v)=>v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
        const { body  } = this;
        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
        const bodyFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'middle';
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for(i = 0, ilen = body.length; i < ilen; ++i){
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for(j = 0, jlen = lines.length; j < jlen; ++j){
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
            const rtlHelper = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = 'middle';
            footerFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign , yAlign  } = this;
        const { x , y  } = pt;
        const { width , height  } = tooltipSize;
        const { topLeft , topRight , bottomLeft , bottomRight  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === 'top') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === 'center' && xAlign === 'right') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === 'bottom') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === 'center' && xAlign === 'left') {
            this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
 _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) {
                return;
            }
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
 _willRender() {
        return !!this.opacity;
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
            return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height
        };
        const pt = {
            x: this.x,
            y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);
            ctx.restore();
        }
    }
 getActiveElements() {
        return this._active || [];
    }
 setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex , index  })=>{
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) {
                throw new Error('Cannot find a dataset at index ' + datasetIndex);
            }
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
 handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
            return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e.x,
                    y: e.y
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
 _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === 'mouseout') {
            return [];
        }
        if (!inChartArea) {
            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
        }
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
            active.reverse();
        }
        return active;
    }
 _positionChanged(active, e) {
        const { caretX , caretY , options  } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
}
var plugin_tooltip = {
    id: 'tooltip',
    _element: Tooltip,
    positioners,
    afterInit (chart, _args, options) {
        if (options) {
            chart.tooltip = new Tooltip({
                chart,
                options
            });
        }
    },
    beforeUpdate (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    reset (chart, _args, options) {
        if (chart.tooltip) {
            chart.tooltip.initialize(options);
        }
    },
    afterDraw (chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            const args = {
                tooltip
            };
            if (chart.notifyPlugins('beforeTooltipDraw', {
                ...args,
                cancelable: true
            }) === false) {
                return;
            }
            tooltip.draw(chart.ctx);
            chart.notifyPlugins('afterTooltipDraw', args);
        }
    },
    afterEvent (chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
            }
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: 'average',
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleColor: '#fff',
        titleFont: {
            weight: 'bold'
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: 'left',
        bodyColor: '#fff',
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: 'left',
        footerColor: '#fff',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: 'bold'
        },
        footerAlign: 'left',
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts)=>opts.bodyFont.size,
        boxWidth: (ctx, opts)=>opts.bodyFont.size,
        multiKeyBackground: '#fff',
        displayColors: true,
        boxPadding: 0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: 'easeOutQuart'
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'width',
                    'height',
                    'caretX',
                    'caretY'
                ]
            },
            opacity: {
                easing: 'linear',
                duration: 200
            }
        },
        callbacks: defaultCallbacks
    },
    defaultRoutes: {
        bodyFont: 'font',
        footerFont: 'font',
        titleFont: 'font'
    },
    descriptors: {
        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: 'animation'
        }
    },
    additionalOptionScopes: [
        'interaction'
    ]
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Colors: plugin_colors,
Decimation: plugin_decimation,
Filler: index,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels)=>{
    if (typeof raw === 'string') {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw
        });
    } else if (isNaN(raw)) {
        index = null;
    }
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
        return addIfString(labels, raw, index, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
const validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(Math.round(index), 0, max);
function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
        return labels[value];
    }
    return value;
}
class CategoryScale extends Scale {
    static id = 'category';
 static defaults = {
        ticks: {
            callback: _getLabelForValue
        }
    };
    constructor(cfg){
        super(cfg);
         this._startValue = undefined;
        this._valueRange = 0;
        this._addedLabels = [];
    }
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index , label  } of added){
                if (labels[index] === label) {
                    labels.splice(index, 1);
                }
            }
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {
            return null;
        }
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this.getMinMax(true);
        if (this.options.bounds === 'ticks') {
            if (!minDefined) {
                min = 0;
            }
            if (!maxDefined) {
                max = this.getLabels().length - 1;
            }
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for(let value = min; value <= max; value++){
            ticks.push({
                value
            });
        }
        return ticks;
    }
    getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
    }
 configure() {
        super.configure();
        if (!this.isHorizontal()) {
            this._reversePixels = !this._reversePixels;
        }
    }
    getPixelForValue(value) {
        if (typeof value !== 'number') {
            value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
            return null;
        }
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
}

function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin , max: rmax  } = dataRange;
    const minDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);
    const maxDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);
    const countDefined = !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
            {
                value: rmin
            },
            {
                value: rmax
            }
        ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
        spacing = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === 'ticks') {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {
            numSpaces = Math.round(numSpaces);
        } else {
            numSpaces = Math.ceil(numSpaces);
        }
    }
    const decimalPlaces = Math.max((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));
    factor = Math.pow(10, (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) {
                j++;
            }
            if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
            }
        } else if (niceMin < min) {
            j++;
        }
    }
    for(; j < numSpaces; ++j){
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) {
            break;
        }
        ticks.push({
            value: tickValue
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
        } else {
            ticks.push({
                value: max
            });
        }
    } else if (!maxDefined || niceMax === max) {
        ticks.push({
            value: niceMax
        });
    }
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
    const rad = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    const length = 0.75 * minSpacing * ('' + value).length;
    return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
         this._endValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {
            return null;
        }
        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
            return null;
        }
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero  } = this.options;
        const { minDefined , maxDefined  } = this.getUserBounds();
        let { min , max  } = this;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (beginAtZero) {
            const minSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);
            const maxSign = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);
            if (minSign < 0 && maxSign < 0) {
                setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
            }
        }
        if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) {
                setMin(min - offset);
            }
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit , stepSize  } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1000;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
    }
 computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === 'ticks') {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);
    }
}

class LinearScale extends LinearScaleBase {
    static id = 'linear';
 static defaults = {
        ticks: {
            callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric
        }
    };
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;
        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
}

const log10Floor = (v)=>Math.floor((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(v));
const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while(steps(min, max, rangeExp) > 10){
        rangeExp++;
    }
    while(steps(min, max, rangeExp) < 10){
        rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
}
 function generateTicks(generationOptions, { min , max  }) {
    min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while(value < max){
        ticks.push({
            value,
            major: isMajor(value),
            significand
        });
        if (significand >= 10) {
            significand = significand < 15 ? 15 : 20;
        } else {
            significand++;
        }
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand
    });
    return ticks;
}
class LogarithmicScale extends Scale {
    static id = 'logarithmic';
 static defaults = {
        ticks: {
            callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.logarithmic,
            major: {
                enabled: true
            }
        }
    };
    constructor(cfg){
        super(cfg);
         this.start = undefined;
         this.end = undefined;
         this._startValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
        ]);
        if (value === 0) {
            this._zero = true;
            return undefined;
        }
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(true);
        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;
        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
            this._zero = true;
        }
        if (this._zero && this.min !== this._suggestedMin && !(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(this._userMin)) {
            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
        }
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined , maxDefined  } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, +1));
            }
        }
        if (min <= 0) {
            setMin(changeExponent(max, -1));
        }
        if (max <= 0) {
            setMax(changeExponent(min, +1));
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === 'ticks') {
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, 'value');
        }
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
 getLabelForValue(value) {
        return value === undefined ? '0' : (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);
    }
 configure() {
        const start = this.min;
        super.configure();
        this._startValue = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);
        this._valueRange = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(this.max) - (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);
    }
    getPixelForValue(value) {
        if (value === undefined || value === 0) {
            value = this.min;
        }
        if (value === null || isNaN(value)) {
            return NaN;
        }
        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
}

function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(tickOpts.backdropPadding);
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [
        label
    ];
    return {
        w: (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO)(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
        return {
            start: pos - size / 2,
            end: pos + size / 2
        };
    } else if (angle < min || angle > max) {
        return {
            start: pos - size,
            end: pos
        };
    }
    return {
        start: pos,
        end: pos + size
    };
}
 function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra , additionalAngle , padding , size  } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(pointLabelPosition.angle + _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y,
        textAlign,
        left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
    };
}
function isNotOverlapped(item, area) {
    if (!area) {
        return true;
    }
    const { left , top , right , bottom  } = item;
    const apexesInArea = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({
        x: left,
        y: top
    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({
        x: left,
        y: bottom
    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({
        x: right,
        y: top
    }, area) || (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)({
        x: right,
        y: bottom
    }, area);
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels , display  } = opts.pointLabels;
    const itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0
    };
    let area;
    for(let i = 0; i < valueCount; i++){
        itemOpts.padding = padding[i];
        itemOpts.size = labelSizes[i];
        const item = createPointLabelItem(scale, i, itemOpts);
        items.push(item);
        if (display === 'auto') {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) {
                area = item;
            }
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
        return 'center';
    } else if (angle < 180) {
        return 'left';
    }
    return 'right';
}
function leftForTextAlign(x, w, align) {
    if (align === 'right') {
        x -= w;
    } else if (align === 'center') {
        x -= w / 2;
    }
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
        y -= h / 2;
    } else if (angle > 270 || angle < 90) {
        y -= h;
    }
    return y;
}
function drawPointLabelBox(ctx, opts, item) {
    const { left , top , right , bottom  } = item;
    const { backdropColor  } = opts;
    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {
        const borderRadius = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(opts.borderRadius);
        const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v)=>v !== 0)) {
            ctx.beginPath();
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
            });
            ctx.fill();
        } else {
            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
    }
}
function drawPointLabels(scale, labelCount) {
    const { ctx , options: { pointLabels  }  } = scale;
    for(let i = labelCount - 1; i >= 0; i--){
        const item = scale._pointLabelItems[i];
        if (!item.visible) {
            continue;
        }
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        drawPointLabelBox(ctx, optsAtIndex, item);
        const plFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);
        const { x , y , textAlign  } = item;
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: 'middle'
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx  } = scale;
    if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
    } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(let i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color , lineWidth  } = gridLineOpts;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
        return;
    }
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(parent, {
        label,
        index,
        type: 'pointLabel'
    });
}
class RadialLinearScale extends LinearScaleBase {
    static id = 'radialLinear';
 static defaults = {
        display: true,
        animate: true,
        position: 'chartArea',
        angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0.0
        },
        grid: {
            circular: false
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: true,
            callback: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM.formatters.numeric
        },
        pointLabels: {
            backdropColor: undefined,
            backdropPadding: 2,
            display: true,
            font: {
                size: 10
            },
            callback (label) {
                return label;
            },
            padding: 5,
            centerPointLabels: false
        }
    };
    static defaultRoutes = {
        'angleLines.color': 'borderColor',
        'pointLabels.color': 'color',
        'ticks.color': 'color'
    };
    static descriptors = {
        angleLines: {
            _fallback: 'grid'
        }
    };
    constructor(cfg){
        super(cfg);
         this.xCenter = undefined;
         this.yCenter = undefined;
         this.drawingArea = undefined;
         this._pointLabels = [];
        this._pointLabelItems = [];
    }
    setDimensions() {
        const padding = this._padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
        const { min , max  } = this.getMinMax(false);
        this.min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;
        this.max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
 computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index)=>{
            const label = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.pointLabels.callback, [
                value,
                index
            ], this);
            return label || label === 0 ? label : '';
        }).filter((v, i)=>this.chart.getDataVisibility(i));
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(this);
        } else {
            this.setCenterPoint(0, 0, 0, 0);
        }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
        const angleMultiplier = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(index * angleMultiplier + (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {
            return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
            return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {
            return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left , top , right , bottom  } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom
        };
    }
 drawBackground() {
        const { backgroundColor , grid: { circular  }  } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
 drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines , grid , border  } = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) {
            drawPointLabels(this, labelCount);
        }
        if (grid.display) {
            this.ticks.forEach((tick, index)=>{
                if (index !== 0 || index === 0 && this.min < 0) {
                    offset = this.getDistanceFromCenterForValue(tick.value);
                    const context = this.getContext(index);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                }
            });
        }
        if (angleLines.display) {
            ctx.save();
            for(i = labelCount - 1; i >= 0; i--){
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color , lineWidth  } = optsAtIndex;
                if (!lineWidth || !color) {
                    continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
 drawBorder() {}
 drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
            return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        this.ticks.forEach((tick, index)=>{
            if (index === 0 && this.min >= 0 && !opts.reverse) {
                return;
            }
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
                strokeColor: optsAtIndex.textStrokeColor,
                strokeWidth: optsAtIndex.textStrokeWidth
            });
        });
        ctx.restore();
    }
 drawTitle() {}
}

const INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
 const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
 function sorter(a, b) {
    return a - b;
}
 function parse(scale, input) {
    if ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {
        return null;
    }
    const adapter = scale._adapter;
    const { parser , round , isoWeekday  } = scale._parseOpts;
    let value = input;
    if (typeof parser === 'function') {
        value = parser(value);
    }
    if (!(0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {
        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
        return null;
    }
    if (round) {
        value = round === 'week' && ((0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
    }
    return +value;
}
 function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
        }
    }
    return UNITS[ilen - 1];
}
 function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
        }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
 function determineMajorUnit(unit) {
    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
        }
    }
}
 function addTick(ticks, time, timestamps) {
    if (!timestamps) {
        ticks[time] = true;
    } else if (timestamps.length) {
        const { lo , hi  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
 function setMajorTicks(scale, ticks, map, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map[major];
        if (index >= 0) {
            ticks[index].major = true;
        }
    }
    return ticks;
}
 function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
     const map = {};
    const ilen = values.length;
    let i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map[value] = i;
        ticks.push({
            value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
    static id = 'time';
 static defaults = {
 bounds: 'data',
        adapters: {},
        time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: 'millisecond',
            displayFormats: {}
        },
        ticks: {
 source: 'auto',
            callback: false,
            major: {
                enabled: false
            }
        }
    };
 constructor(props){
        super(props);
         this._cache = {
            data: [],
            labels: [],
            all: []
        };
         this._unit = 'day';
         this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
    }
    init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
 parse(raw, index) {
        if (raw === undefined) {
            return null;
        }
        return parse(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || 'day';
        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
 function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
            }
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
                _applyBounds(this.getMinMax(false));
            }
        }
        min = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
 _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max
        };
    }
 buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === 'ticks' && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP)(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
            ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
            this.initOffsets(this.ticks.map((tick)=>+tick.value));
        }
    }
 initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
                start = 1 - first;
            } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
                end = last;
            } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(start, 0, limit);
        end = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
        };
    }
 _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.stepSize, 1);
        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        const hasWeekday = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
            first = +adapter.startOf(first, 'isoWeek', weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) {
            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
        }
        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
            addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === 'ticks' || count === 1) {
            addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort(sorter).map((x)=>+x);
    }
 getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
 format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
    }
 _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
            return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(formatter, [
                time,
                index,
                ticks
            ], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
 generateTickLabels(ticks) {
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
    }
 getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
 getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
 _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
    }
 _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
 getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
            return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
    }
 getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
            return timestamps;
        }
        const labels = this.getLabels();
        for(i = 0, ilen = labels.length; i < ilen; ++i){
            timestamps.push(parse(this, labels[i]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
 normalize(values) {
        return (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));
    }
}

function interpolate(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo , hi  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, 'pos', val));
        }
        ({ pos: prevSource , time: prevTarget  } = table[lo]);
        ({ pos: nextSource , time: nextTarget  } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo , hi  } = (0,_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(table, 'time', val));
        }
        ({ time: prevSource , pos: prevTarget  } = table[lo]);
        ({ time: nextSource , pos: nextTarget  } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
    static id = 'timeseries';
 static defaults = TimeScale.defaults;
 constructor(props){
        super(props);
         this._table = [];
         this._minPos = undefined;
         this._tableRange = undefined;
    }
 initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
 buildLookupTable(timestamps) {
        const { min , max  } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
                items.push(curr);
            }
        }
        if (items.length < 2) {
            return [
                {
                    time: min,
                    pos: 0
                },
                {
                    time: max,
                    pos: 1
                }
            ];
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
                table.push({
                    time: curr,
                    pos: i / (ilen - 1)
                });
            }
        }
        return table;
    }
 _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) {
            timestamps.splice(0, 0, min);
        }
        if (!timestamps.includes(max) || timestamps.length === 1) {
            timestamps.push(max);
        }
        return timestamps.sort((a, b)=>a - b);
    }
 _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
            return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
            timestamps = this.normalize(data.concat(label));
        } else {
            timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
 getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
    }
 getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
    }
}

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
    controllers,
    elements,
    plugins,
    scales
];


//# sourceMappingURL=chart.js.map


/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.dataset.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ unclipArea),
/* harmony export */   A: () => (/* binding */ _rlookupByKey),
/* harmony export */   B: () => (/* binding */ _lookupByKey),
/* harmony export */   C: () => (/* binding */ _isPointInArea),
/* harmony export */   D: () => (/* binding */ getAngleFromPoint),
/* harmony export */   E: () => (/* binding */ toPadding),
/* harmony export */   F: () => (/* binding */ each),
/* harmony export */   G: () => (/* binding */ getMaximumSize),
/* harmony export */   H: () => (/* binding */ HALF_PI),
/* harmony export */   I: () => (/* binding */ _getParentNode),
/* harmony export */   J: () => (/* binding */ readUsedSize),
/* harmony export */   K: () => (/* binding */ supportsEventListenerOptions),
/* harmony export */   L: () => (/* binding */ throttled),
/* harmony export */   M: () => (/* binding */ _isDomSupported),
/* harmony export */   N: () => (/* binding */ _factorize),
/* harmony export */   O: () => (/* binding */ finiteOrDefault),
/* harmony export */   P: () => (/* binding */ PI),
/* harmony export */   Q: () => (/* binding */ callback),
/* harmony export */   R: () => (/* binding */ _addGrace),
/* harmony export */   S: () => (/* binding */ _limitValue),
/* harmony export */   T: () => (/* binding */ TAU),
/* harmony export */   U: () => (/* binding */ toDegrees),
/* harmony export */   V: () => (/* binding */ _measureText),
/* harmony export */   W: () => (/* binding */ _int16Range),
/* harmony export */   X: () => (/* binding */ _alignPixel),
/* harmony export */   Y: () => (/* binding */ clipArea),
/* harmony export */   Z: () => (/* binding */ renderText),
/* harmony export */   _: () => (/* binding */ _arrayUnique),
/* harmony export */   a: () => (/* binding */ resolve),
/* harmony export */   a$: () => (/* binding */ getStyle),
/* harmony export */   a0: () => (/* binding */ toFont),
/* harmony export */   a1: () => (/* binding */ _toLeftRightCenter),
/* harmony export */   a2: () => (/* binding */ _alignStartEnd),
/* harmony export */   a3: () => (/* binding */ overrides),
/* harmony export */   a4: () => (/* binding */ merge),
/* harmony export */   a5: () => (/* binding */ _capitalize),
/* harmony export */   a6: () => (/* binding */ descriptors),
/* harmony export */   a7: () => (/* binding */ isFunction),
/* harmony export */   a8: () => (/* binding */ _attachContext),
/* harmony export */   a9: () => (/* binding */ _createResolver),
/* harmony export */   aA: () => (/* binding */ getRtlAdapter),
/* harmony export */   aB: () => (/* binding */ overrideTextDirection),
/* harmony export */   aC: () => (/* binding */ _textX),
/* harmony export */   aD: () => (/* binding */ restoreTextDirection),
/* harmony export */   aE: () => (/* binding */ drawPointLegend),
/* harmony export */   aF: () => (/* binding */ distanceBetweenPoints),
/* harmony export */   aG: () => (/* binding */ noop),
/* harmony export */   aH: () => (/* binding */ _setMinAndMaxByKey),
/* harmony export */   aI: () => (/* binding */ niceNum),
/* harmony export */   aJ: () => (/* binding */ almostWhole),
/* harmony export */   aK: () => (/* binding */ almostEquals),
/* harmony export */   aL: () => (/* binding */ _decimalPlaces),
/* harmony export */   aM: () => (/* binding */ Ticks),
/* harmony export */   aN: () => (/* binding */ log10),
/* harmony export */   aO: () => (/* binding */ _longestText),
/* harmony export */   aP: () => (/* binding */ _filterBetween),
/* harmony export */   aQ: () => (/* binding */ _lookup),
/* harmony export */   aR: () => (/* binding */ isPatternOrGradient),
/* harmony export */   aS: () => (/* binding */ getHoverColor),
/* harmony export */   aT: () => (/* binding */ clone),
/* harmony export */   aU: () => (/* binding */ _merger),
/* harmony export */   aV: () => (/* binding */ _mergerIf),
/* harmony export */   aW: () => (/* binding */ _deprecated),
/* harmony export */   aX: () => (/* binding */ _splitKey),
/* harmony export */   aY: () => (/* binding */ toFontString),
/* harmony export */   aZ: () => (/* binding */ splineCurve),
/* harmony export */   a_: () => (/* binding */ splineCurveMonotone),
/* harmony export */   aa: () => (/* binding */ _descriptors),
/* harmony export */   ab: () => (/* binding */ mergeIf),
/* harmony export */   ac: () => (/* binding */ uid),
/* harmony export */   ad: () => (/* binding */ debounce),
/* harmony export */   ae: () => (/* binding */ retinaScale),
/* harmony export */   af: () => (/* binding */ clearCanvas),
/* harmony export */   ag: () => (/* binding */ setsEqual),
/* harmony export */   ah: () => (/* binding */ getDatasetClipArea),
/* harmony export */   ai: () => (/* binding */ _elementsEqual),
/* harmony export */   aj: () => (/* binding */ _isClickEvent),
/* harmony export */   ak: () => (/* binding */ _isBetween),
/* harmony export */   al: () => (/* binding */ _normalizeAngle),
/* harmony export */   am: () => (/* binding */ _readValueToProps),
/* harmony export */   an: () => (/* binding */ _updateBezierControlPoints),
/* harmony export */   ao: () => (/* binding */ _computeSegments),
/* harmony export */   ap: () => (/* binding */ _boundSegments),
/* harmony export */   aq: () => (/* binding */ _steppedInterpolation),
/* harmony export */   ar: () => (/* binding */ _bezierInterpolation),
/* harmony export */   as: () => (/* binding */ _pointInLine),
/* harmony export */   at: () => (/* binding */ _steppedLineTo),
/* harmony export */   au: () => (/* binding */ _bezierCurveTo),
/* harmony export */   av: () => (/* binding */ drawPoint),
/* harmony export */   aw: () => (/* binding */ addRoundedRectPath),
/* harmony export */   ax: () => (/* binding */ toTRBL),
/* harmony export */   ay: () => (/* binding */ toTRBLCorners),
/* harmony export */   az: () => (/* binding */ _boundSegment),
/* harmony export */   b: () => (/* binding */ isArray),
/* harmony export */   b0: () => (/* binding */ fontString),
/* harmony export */   b1: () => (/* binding */ toLineHeight),
/* harmony export */   b2: () => (/* binding */ PITAU),
/* harmony export */   b3: () => (/* binding */ INFINITY),
/* harmony export */   b4: () => (/* binding */ RAD_PER_DEG),
/* harmony export */   b5: () => (/* binding */ QUARTER_PI),
/* harmony export */   b6: () => (/* binding */ TWO_THIRDS_PI),
/* harmony export */   b7: () => (/* binding */ _angleDiff),
/* harmony export */   c: () => (/* binding */ color),
/* harmony export */   d: () => (/* binding */ defaults),
/* harmony export */   e: () => (/* binding */ effects),
/* harmony export */   f: () => (/* binding */ resolveObjectKey),
/* harmony export */   g: () => (/* binding */ isNumberFinite),
/* harmony export */   h: () => (/* binding */ defined),
/* harmony export */   i: () => (/* binding */ isObject),
/* harmony export */   j: () => (/* binding */ createContext),
/* harmony export */   k: () => (/* binding */ isNullOrUndef),
/* harmony export */   l: () => (/* binding */ listenArrayEvents),
/* harmony export */   m: () => (/* binding */ toPercentage),
/* harmony export */   n: () => (/* binding */ toDimension),
/* harmony export */   o: () => (/* binding */ formatNumber),
/* harmony export */   p: () => (/* binding */ _angleBetween),
/* harmony export */   q: () => (/* binding */ _getStartAndCountOfVisiblePoints),
/* harmony export */   r: () => (/* binding */ requestAnimFrame),
/* harmony export */   s: () => (/* binding */ sign),
/* harmony export */   t: () => (/* binding */ toRadians),
/* harmony export */   u: () => (/* binding */ unlistenArrayEvents),
/* harmony export */   v: () => (/* binding */ valueOrDefault),
/* harmony export */   w: () => (/* binding */ _scaleRangesChanged),
/* harmony export */   x: () => (/* binding */ isNumber),
/* harmony export */   y: () => (/* binding */ _parseObjectDataRadialScale),
/* harmony export */   z: () => (/* binding */ getRelativePosition)
/* harmony export */ });
/* harmony import */ var _kurkle_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kurkle/color */ "./node_modules/@kurkle/color/dist/color.esm.js");
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */


/**
 * @namespace Chart.helpers
 */ /**
 * An empty function that can be used, for example, for optional callback.
 */ function noop() {
/* noop */ }
/**
 * Returns a unique id, sequentially generated from a global variable.
 */ const uid = (()=>{
    let id = 0;
    return ()=>id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isNullOrUndef(value) {
    return value === null || value === undefined;
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */ function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
        return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
        return true;
    }
    return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */ function isNumberFinite(value) {
    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */ function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */ function valueOrDefault(value, defaultValue) {
    return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */ function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
    }
}
function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) {
            for(i = len - 1; i >= 0; i--){
                fn.call(thisArg, loopable[i], i);
            }
        } else {
            for(i = 0; i < len; i++){
                fn.call(thisArg, loopable[i], i);
            }
        }
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++){
            fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
    }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */ function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
    }
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
        }
    }
    return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */ function clone(source) {
    if (isArray(source)) {
        return source.map(clone);
    }
    if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for(; k < klen; ++k){
            target[keys[k]] = clone(source[keys[k]]);
        }
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        '__proto__',
        'prototype',
        'constructor'
    ].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */ function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        merge(tval, sval, options);
    } else {
        target[key] = clone(sval);
    }
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [
        source
    ];
    const ilen = sources.length;
    if (!isObject(target)) {
        return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for(let i = 0; i < ilen; ++i){
        current = sources[i];
        if (!isObject(current)) {
            continue;
        }
        const keys = Object.keys(current);
        for(let k = 0, klen = keys.length; k < klen; ++k){
            merger(keys[k], target, current, options);
        }
    }
    return target;
}
function mergeIf(target, source) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return merge(target, source, {
        merger: _mergerIf
    });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */ function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
        return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone(sval);
    }
}
/**
 * @private
 */ function _deprecated(scope, value, previous, current) {
    if (value !== undefined) {
        console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
    }
}
// resolveObjectKey resolver cache
const keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    '': (v)=>v,
    // default resolvers
    x: (o)=>o.x,
    y: (o)=>o.y
};
/**
 * @private
 */ function _splitKey(key) {
    const parts = key.split('.');
    const keys = [];
    let tmp = '';
    for (const part of parts){
        tmp += part;
        if (tmp.endsWith('\\')) {
            tmp = tmp.slice(0, -1) + '.';
        } else {
            keys.push(tmp);
            tmp = '';
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj)=>{
        for (const k of keys){
            if (k === '') {
                break;
            }
            obj = obj && obj[k];
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
/**
 * @private
 */ function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value)=>typeof value !== 'undefined';
const isFunction = (value)=>typeof value === 'function';
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
const setsEqual = (a, b)=>{
    if (a.size !== b.size) {
        return false;
    }
    for (const item of a){
        if (!b.has(item)) {
            return false;
        }
    }
    return true;
};
/**
 * @param e - The event
 * @private
 */ function _isClickEvent(e) {
    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

/**
 * @alias Chart.helpers.math
 * @namespace
 */ const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */ function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */ function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for(i = 1; i < sqrt; i++){
        if (value % i === 0) {
            result.push(i);
            result.push(value / i);
        }
    }
    if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
    }
    result.sort((a, b)=>a - b).pop();
    return result;
}
/**
 * Verifies that attempting to coerce n to string or number won't throw a TypeError.
 */ function isNonPrimitive(n) {
    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);
}
function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */ function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */ function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
        return;
    }
    let e = 1;
    let p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    }
    return {
        angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */ function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */ function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */ function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */ function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */ function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function _lookup(table, value, cmp) {
    cmp = cmp || ((index)=>table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return {
        lo,
        hi
    };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
        const ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
    } : (index)=>table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */ function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while(start < end && values[start] < min){
        start++;
    }
    while(end > start && values[end - 1] > max){
        end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
    'push',
    'pop',
    'shift',
    'splice',
    'unshift'
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach((key)=>{
        const method = '_onData' + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value (...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object)=>{
                    if (typeof object[method] === 'function') {
                        object[method](...args);
                    }
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
        return;
    }
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) {
        listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
        return;
    }
    arrayEvents.forEach((key)=>{
        delete array[key];
    });
    delete array._chartjs;
}
/**
 * @param items
 */ function _arrayUnique(items) {
    const set = new Set(items);
    if (set.size === items.length) {
        return items;
    }
    return Array.from(set);
}

function fontString(pixelSize, fontStyle, fontFamily) {
    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
/**
* Request animation polyfill
*/ const requestAnimFrame = function() {
    if (typeof window === 'undefined') {
        return function(callback) {
            return callback();
        };
    }
    return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */ function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
        // Save the args for use later
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, ()=>{
                ticking = false;
                fn.apply(thisArg, argsToUse);
            });
        }
    };
}
/**
 * Debounces calling `fn` for `delay` ms
 */ function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else {
            fn.apply(this, args);
        }
        return delay;
    };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */ const _textX = (align, left, right, rtl)=>{
    const check = rtl ? 'left' : 'right';
    return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
        const { iScale , vScale , _parsed  } = meta;
        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
        const axis = iScale.axis;
        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
        if (minDefined) {
            start = Math.min(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);
            if (spanGaps) {
                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                start -= Math.max(0, distanceToDefinedLo);
            }
            start = _limitValue(start, 0, pointCount - 1);
        }
        if (maxDefined) {
            let end = Math.max(// @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);
            if (spanGaps) {
                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));
                end += Math.max(0, distanceToDefinedHi);
            }
            count = _limitValue(end, start, pointCount) - start;
        } else {
            count = pointCount - start;
        }
    }
    return {
        start,
        count
    };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */ function _scaleRangesChanged(meta) {
    const { xScale , yScale , _scaleRanges  } = meta;
    const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}

const atEdge = (t)=>t === 0 || t === 1;
const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */ const effects = {
    linear: (t)=>t,
    easeInQuad: (t)=>t * t,
    easeOutQuad: (t)=>-t * (t - 2),
    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t)=>t * t * t,
    easeOutCubic: (t)=>(t -= 1) * t * t + 1,
    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t)=>t * t * t * t,
    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t)=>t * t * t * t * t,
    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t)=>Math.sin(t * HALF_PI),
    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic (t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack (t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack (t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack (t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
    easeOutBounce (t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) {
            return m * t * t;
        }
        if (t < 2 / d) {
            return m * (t -= 1.5 / d) * t + 0.75;
        }
        if (t < 2.5 / d) {
            return m * (t -= 2.25 / d) * t + 0.9375;
        }
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};

function isPatternOrGradient(value) {
    if (value && typeof value === 'object') {
        const type = value.toString();
        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value).saturate(0.5).darken(0.1).hexString();
}

const numbers = [
    'x',
    'y',
    'borderWidth',
    'radius',
    'tension'
];
const colors = [
    'color',
    'borderColor',
    'backgroundColor'
];
function applyAnimationsDefaults(defaults) {
    defaults.set('animation', {
        delay: undefined,
        duration: 1000,
        easing: 'easeOutQuart',
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
    });
    defaults.describe('animation', {
        _fallback: false,
        _indexable: false,
        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
    });
    defaults.set('animations', {
        colors: {
            type: 'color',
            properties: colors
        },
        numbers: {
            type: 'number',
            properties: numbers
        }
    });
    defaults.describe('animations', {
        _fallback: 'animation'
    });
    defaults.set('transitions', {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: 'transparent'
                },
                visible: {
                    type: 'boolean',
                    easing: 'linear',
                    fn: (v)=>v | 0
                }
            }
        }
    });
}

function applyLayoutsDefaults(defaults) {
    defaults.set('layout', {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}

const formatters = {
 values (value) {
        return isArray(value) ?  value : '' + value;
    },
 numeric (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) {
                notation = 'scientific';
            }
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
    },
 logarithmic (tickValue, index, ticks) {
        if (tickValue === 0) {
            return '0';
        }
        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
            1,
            2,
            3,
            5,
            10,
            15
        ].includes(remain) || index > 0.8 * ticks.length) {
            return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return '';
    }
};
function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
    }
    return delta;
}
 var Ticks = {
    formatters
};

function applyScaleDefaults(defaults) {
    defaults.set('scale', {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
 bounds: 'ticks',
        clip: true,
 grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options)=>options.lineWidth,
            tickColor: (_ctx, options)=>options.color,
            offset: false
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0.0,
            width: 1
        },
        title: {
            display: false,
            text: '',
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: '',
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: 'center',
            crossAlign: 'near',
            showLabelBackdrop: false,
            backdropColor: 'rgba(255, 255, 255, 0.75)',
            backdropPadding: 2
        }
    });
    defaults.route('scale.ticks', 'color', '', 'color');
    defaults.route('scale.grid', 'color', '', 'borderColor');
    defaults.route('scale.border', 'color', '', 'borderColor');
    defaults.route('scale.title', 'color', '', 'color');
    defaults.describe('scale', {
        _fallback: false,
        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
    });
    defaults.describe('scales', {
        _fallback: 'scale'
    });
    defaults.describe('scale.ticks', {
        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
        _indexable: (name)=>name !== 'backdropPadding'
    });
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
 function getScope$1(node, key) {
    if (!key) {
        return node;
    }
    const keys = key.split('.');
    for(let i = 0, n = keys.length; i < n; ++i){
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === 'string') {
        return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ''), scope);
}
 class Defaults {
    constructor(_descriptors, _appliers){
        this.animation = undefined;
        this.backgroundColor = 'rgba(0,0,0,0.1)';
        this.borderColor = 'rgba(0,0,0,0.1)';
        this.color = '#666';
        this.datasets = {};
        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
            'mousemove',
            'mouseout',
            'click',
            'touchstart',
            'touchmove'
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: 'normal',
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options)=>getHoverColor(options.color);
        this.indexAxis = 'x';
        this.interaction = {
            mode: 'nearest',
            intersect: true,
            includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors);
        this.apply(_appliers);
    }
 set(scope, values) {
        return set(this, scope, values);
    }
 get(scope) {
        return getScope$1(this, scope);
    }
 describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
 route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = '_' + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true
            },
            [name]: {
                enumerable: true,
                get () {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) {
                        return Object.assign({}, target, local);
                    }
                    return valueOrDefault(local, target);
                },
                set (value) {
                    this[privateName] = value;
                }
            }
        });
    }
    apply(appliers) {
        appliers.forEach((apply)=>apply(this));
    }
}
var defaults = /* #__PURE__ */ new Defaults({
    _scriptable: (name)=>!name.startsWith('on'),
    _indexable: (name)=>name !== 'events',
    hover: {
        _fallback: 'interaction'
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
}, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
]);

/**
 * Converts the given font object into a CSS font string.
 * @param font - A font object.
 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */ function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
    }
    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}
/**
 * @private
 */ function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) {
        longest = textWidth;
    }
    return longest;
}
/**
 * @private
 */ // eslint-disable-next-line complexity
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && !isArray(thing)) {
            longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            for(j = 0, jlen = thing.length; j < jlen; j++){
                nestedThing = thing[j];
                // Undefined strings and arrays should not be measured
                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
                    longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++){
            delete data[gc[i]];
        }
        gc.splice(0, gcLen);
    }
    return longest;
}
/**
 * Returns the aligned pixel value to avoid anti-aliasing blur
 * @param chart - The chart instance.
 * @param pixel - A pixel value.
 * @param width - The width of the element.
 * @returns The aligned pixel value.
 * @private
 */ function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
/**
 * Clears the entire canvas.
 */ function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
        return;
    }
    ctx = ctx || canvas.getContext('2d');
    ctx.save();
    // canvas.width and canvas.height do not consider the canvas transform,
    // while clearRect does
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    drawPointLegend(ctx, options, x, y, null);
}
// eslint-disable-next-line complexity
function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) {
        return;
    }
    ctx.beginPath();
    switch(style){
        // Default includes circle
        default:
            if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            } else {
                ctx.arc(x, y, radius, 0, TAU);
            }
            ctx.closePath();
            break;
        case 'triangle':
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case 'rect':
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */ case 'rectRot':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
        case 'crossRot':
            rad += QUARTER_PI;
        /* falls through */ case 'cross':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'star':
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case 'line':
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
        ctx.stroke();
    }
}
/**
 * Returns true if the point is inside the rectangle
 * @param point - The point to test
 * @param area - The rectangle
 * @param margin - allowed margin
 * @private
 */ function _isPointInArea(point, area, margin) {
    margin = margin || 0.5; // margin - default is to match rounded decimals
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
/**
 * @private
 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    if (mode === 'middle') {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === 'after' !== !!flip) {
        ctx.lineTo(previous.x, target.y);
    } else {
        ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
}
/**
 * @private
 */ function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
        return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
    }
    if (opts.color) {
        ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
    }
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        /**
     * Now that IE11 support has been dropped, we can use more
     * of the TextMetrics object. The actual bounding boxes
     * are unflagged in Chrome, Firefox, Edge, and Safari so they
     * can be safely used.
     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
     */ const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
/**
 * Render text onto the canvas
 */ function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
        text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (opts.backdrop) {
            drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
            if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
    }
    ctx.restore();
}
/**
 * Add a path of a rectangle with rounded corners to the current sub-path
 * @param ctx - Context
 * @param rect - Bounding rect
 */ function addRoundedRectPath(ctx, rect) {
    const { x , y , w , h , radius  } = rect;
    // top left arc
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    // line from top left to bottom left
    ctx.lineTo(x, y + h - radius.bottomLeft);
    // bottom left arc
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    // line from bottom left to bottom right
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    // bottom right arc
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    // line from bottom right to top right
    ctx.lineTo(x + w, y + radius.topRight);
    // top right arc
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    // line from top right to top left
    ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
 * Converts the given line height `value` in pixels for a specific font `size`.
 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 * @param size - The font size (in pixels) used to resolve relative `value`.
 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 * @since 2.7.0
 */ function toLineHeight(value, size) {
    const matches = ('' + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === 'normal') {
        return size * 1.2;
    }
    value = +matches[2];
    switch(matches[3]){
        case 'px':
            return value;
        case '%':
            value /= 100;
            break;
    }
    return size * value;
}
const numberOrZero = (v)=>+v || 0;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
    for (const prop of keys){
        ret[prop] = numberOrZero(read(prop));
    }
    return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */ function toTRBL(value) {
    return _readValueToProps(value, {
        top: 'y',
        right: 'x',
        bottom: 'y',
        left: 'x'
    });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */ function toTRBLCorners(value) {
    return _readValueToProps(value, [
        'topLeft',
        'topRight',
        'bottomLeft',
        'bottomRight'
    ]);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */ function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */ function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === 'string') {
        size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !('' + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = undefined;
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ''
    };
    font.string = toFontString(font);
    return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */ function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) {
            continue;
        }
        if (context !== undefined && typeof value === 'function') {
            value = value(context);
            cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== undefined) {
            if (info && !cacheable) {
                info.cacheable = false;
            }
            return value;
        }
    }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */ function _addGrace(minmax, grace, beginAtZero) {
    const { min , max  } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}

/**
 * Creates a Proxy for resolving raw values for options.
 * @param scopes - The option scopes to look for values, in resolution order
 * @param prefixes - The prefixes for values, in resolution order.
 * @param rootScopes - The root option scopes
 * @param fallback - Parent scopes fallback
 * @param getTarget - callback for getting the target for changed values
 * @returns Proxy
 * @private
 */ function _createResolver(scopes, prefixes = [
    ''
], rootScopes, fallback, getTarget = ()=>scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === 'undefined') {
        fallback = _resolve('_fallback', scopes);
    }
    const cache = {
        [Symbol.toStringTag]: 'Object',
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope)=>_createResolver([
                scope,
                ...scopes
            ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete target._keys; // remove cached keys
            delete scopes[0][prop]; // remove from top level scope
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop) {
            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys (target) {
            return getKeysFromAllScopes(target);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value; // set to top level scope + cache
            delete target._keys; // remove cached keys
            return true;
        }
    });
}
/**
 * Returns an Proxy for resolving option values with context.
 * @param proxy - The Proxy returned by `_createResolver`
 * @param context - Context object for scriptable/indexable options
 * @param subProxy - The proxy provided for scriptable options
 * @param descriptorDefaults - Defaults for descriptors
 * @private
 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete proxy[prop]; // remove from proxy
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop, receiver) {
            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys () {
            return Reflect.ownKeys(proxy);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            proxy[prop] = value; // set to proxy
            delete target[prop]; // remove from cache
            return true;
        }
    });
}
/**
 * @private
 */ function _descriptors(proxy, defaults = {
    scriptable: true,
    indexable: true
}) {
    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
    };
}
const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
        return target[prop];
    }
    const value = resolve();
    // cache the resolved value
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    let value = _proxy[prop]; // resolve from proxy
    // resolve with context
    if (isFunction(value) && descriptors.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
        // if the resolved value is an object, create a sub resolver for it
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
    }
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy , _context , _subProxy , _stack  } = target;
    if (_stack.has(prop)) {
        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
        // When scriptable option returns an object, create a resolver on that.
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
        return value[_context.index % value.length];
    } else if (isObject(value[0])) {
        // Array of objects, return array or resolvers
        const arr = value;
        const scopes = _proxy._scopes.filter((s)=>s !== arr);
        value = [];
        for (const item of arr){
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes){
        const scope = getScope(key, parent);
        if (scope) {
            set.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
                // When we reach the descriptor that defines a new _fallback, return that.
                // The fallback will resume to that new scope.
                return fallback;
            }
        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
            // Fallback to `false` results to `false`, when falling back to different key.
            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
            return null;
        }
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
        ...parentScopes,
        ...rootScopes
    ];
    const set = new Set();
    set.add(value);
    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
    if (key === null) {
        return false;
    }
    if (typeof fallback !== 'undefined' && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key, value);
        if (key === null) {
            return false;
        }
    }
    return _createResolver(Array.from(set), [
        ''
    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
    while(key){
        key = addScopes(set, allScopes, key, fallback, item);
    }
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
        parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
        // For array of objects, the object is used to store updated values
        return value;
    }
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes){
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== 'undefined') {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes){
        if (!scope) {
            continue;
        }
        const value = scope[key];
        if (typeof value !== 'undefined') {
            return value;
        }
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set = new Set();
    for (const scope of scopes){
        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
            set.add(key);
        }
    }
    return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale  } = meta;
    const { key ='r'  } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for(i = 0, ilen = count; i < ilen; ++i){
        index = i + start;
        item = data[index];
        parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
        };
    }
    return parsed;
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    // If all points are the same, s01 & s02 will be inf
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01; // scaling factor for triangle Ta
    const fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
/**
 * Adjust tangents to ensure monotonic properties
 */ function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
            continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
            continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
    }
}
/**
 * This function calculates Bzier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */ function splineCurveMonotone(points, indexAxis = 'x') {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    // Calculate slopes (deltaK) and initialize tangents (mK)
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
            continue;
        }
        if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
            continue;
        }
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
/**
 * @private
 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    // Only consider points that are drawn in case the spanGaps option is used
    if (options.spanGaps) {
        points = points.filter((pt)=>!pt.skip);
    }
    if (options.cubicInterpolationMode === 'monotone') {
        splineCurveMonotone(points, indexAxis);
    } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) {
        capBezierPoints(points, area);
    }
}

/**
 * @private
 */ function _isDomSupported() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * @private
 */ function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
    }
    return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */ function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
    } else {
        valueInPixels = styleValue;
    }
    return valueInPixels;
}
const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
    'top',
    'right',
    'bottom',
    'left'
];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? '-' + suffix : '';
    for(let i = 0; i < 4; i++){
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */ function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX , offsetY  } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x,
        y,
        box
    };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */ function getRelativePosition(event, chart) {
    if ('native' in event) {
        return event;
    }
    const { canvas , currentDevicePixelRatio  } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === 'border-box';
    const paddings = getPositionedStyle(style, 'padding');
    const borders = getPositionedStyle(style, 'border', 'width');
    const { x , y , box  } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width , height  } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect(); // this is the border box of the container
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
            const containerPadding = getPositionedStyle(containerStyle, 'padding');
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
const round1 = (v)=>Math.round(v * 10) / 10;
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, 'margin');
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width , height  } = containerSize;
    if (style.boxSizing === 'content-box') {
        const borders = getPositionedStyle(style, 'border', 'width');
        const paddings = getPositionedStyle(style, 'padding');
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
        // https://github.com/chartjs/Chart.js/issues/4659
        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
        height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width,
        height
    };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */ function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */ const supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
        const options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        if (_isDomSupported()) {
            window.addEventListener('test', null, options);
            window.removeEventListener('test', null, options);
        }
    } catch (e) {
    // continue regardless of error
    }
    return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */ function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}

/**
 * @private
 */ function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
/**
 * @private
 */ function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
/**
 * @private
 */ function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}

const getRightToLeftAdapter = function(rectX, width) {
    return {
        x (x) {
            return rectX + rectX + width - x;
        },
        setWidth (w) {
            width = w;
        },
        textAlign (align) {
            if (align === 'center') {
                return align;
            }
            return align === 'right' ? 'left' : 'right';
        },
        xPlus (x, value) {
            return x - value;
        },
        leftForLtr (x, itemWidth) {
            return x - itemWidth;
        }
    };
};
const getLeftToRightAdapter = function() {
    return {
        x (x) {
            return x;
        },
        setWidth (w) {},
        textAlign (align) {
            return align;
        },
        xPlus (x, value) {
            return x + value;
        },
        leftForLtr (x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === 'ltr' || direction === 'rtl') {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue('direction'),
            style.getPropertyPriority('direction')
        ];
        style.setProperty('direction', direction, 'important');
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty('direction', original[0], original[1]);
    }
}

function propertyFn(property) {
    if (property === 'angle') {
        return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
        };
    }
    return {
        between: _isBetween,
        compare: (a, b)=>a - b,
        normalize: (x)=>x
    };
}
function normalizeSegment({ start , end , count , loop , style  }) {
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
    };
}
function getSegment(segment, points, bounds) {
    const { property , start: startBound , end: endBound  } = bounds;
    const { between , normalize  } = propertyFn(property);
    const count = points.length;
    let { start , end , loop  } = segment;
    let i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
            }
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) {
        end += count;
    }
    return {
        start,
        end,
        loop,
        style: segment.style
    };
}
 function _boundSegment(segment, points, bounds) {
    if (!bounds) {
        return [
            segment
        ];
    }
    const { property , start: startBound , end: endBound  } = bounds;
    const count = points.length;
    const { compare , between , normalize  } = propertyFn(property);
    const { start , end , loop , style  } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = ()=>inside || startIsBefore();
    const shouldStop = ()=>!inside || endIsBefore();
    for(let i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) {
            continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
            continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop,
                count,
                style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) {
        result.push(normalizeSegment({
            start: subStart,
            end,
            loop,
            count,
            style
        }));
    }
    return result;
}
 function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for(let i = 0; i < segments.length; i++){
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
            result.push(...sub);
        }
    }
    return result;
}
 function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
        while(start < count && !points[start].skip){
            start++;
        }
    }
    while(start < count && points[start].skip){
        start++;
    }
    start %= count;
    if (loop) {
        end += start;
    }
    while(end > start && points[end % count].skip){
        end--;
    }
    end %= count;
    return {
        start,
        end
    };
}
 function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for(end = start + 1; end <= max; ++end){
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) {
                start = end;
            }
        }
        prev = cur;
    }
    if (last !== null) {
        result.push({
            start: start % count,
            end: last % count,
            loop
        });
    }
    return result;
}
 function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
        return [];
    }
    const loop = !!line._loop;
    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
        return splitByStyles(line, [
            {
                start,
                end,
                loop
            }
        ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
 function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
}
 function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
            return;
        }
        s += count;
        while(points[s % count].skip){
            s -= dir;
        }
        while(points[e % count].skip){
            e += dir;
        }
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    for (const segment of segments){
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for(i = start + 1; i <= segment.end; i++){
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: 'segment',
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
            })));
            if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
            }
            prev = pt;
            prevStyle = style;
        }
        if (start < i - 1) {
            addStyle(start, i - 1, segment.loop, prevStyle);
        }
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    if (!prevStyle) {
        return false;
    }
    const cache = [];
    const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) {
            return value;
        }
        if (!cache.includes(value)) {
            cache.push(value);
        }
        return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    const { xScale , yScale  } = meta;
    if (xScale && yScale) {
        return {
            left: getSizeForArea(xScale, chartArea, 'left'),
            right: getSizeForArea(xScale, chartArea, 'right'),
            top: getSizeForArea(yScale, chartArea, 'top'),
            bottom: getSizeForArea(yScale, chartArea, 'bottom')
        };
    }
    return chartArea;
}
function getDatasetClipArea(chart, meta) {
    const clip = meta._clip;
    if (clip.disabled) {
        return false;
    }
    const area = getDatasetArea(meta, chart.chartArea);
    return {
        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
    };
}


//# sourceMappingURL=helpers.dataset.js.map


/***/ }),

/***/ "./src/config/dashboardWidgets.js":
/*!****************************************!*\
  !*** ./src/config/dashboardWidgets.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DASHBOARD_WIDGETS: () => (/* binding */ DASHBOARD_WIDGETS)
/* harmony export */ });
/**
 * Dashboard widget registry - defines all available widgets
 */
var DASHBOARD_WIDGETS = {
  hero: {
    netWorth: {
      id: 'hero-net-worth',
      name: 'Net Worth',
      size: 'hero',
      defaultVisible: true
    },
    income: {
      id: 'hero-income',
      name: 'Income This Month',
      size: 'hero',
      defaultVisible: true
    },
    expenses: {
      id: 'hero-expenses',
      name: 'Expenses This Month',
      size: 'hero',
      defaultVisible: true
    },
    savings: {
      id: 'hero-savings',
      name: 'Net Savings',
      size: 'hero',
      defaultVisible: true
    },
    pension: {
      id: 'hero-pension',
      name: 'Pension Worth',
      size: 'hero',
      defaultVisible: true
    },
    // Phase 1 - Quick Wins (use existing data)
    savingsRate: {
      id: 'hero-savings-rate',
      name: 'Savings Rate',
      size: 'hero',
      defaultVisible: false,
      category: 'insights'
    },
    cashFlow: {
      id: 'hero-cash-flow',
      name: 'Cash Flow',
      size: 'hero',
      defaultVisible: false,
      category: 'insights'
    },
    budgetRemaining: {
      id: 'hero-budget-remaining',
      name: 'Budget Remaining',
      size: 'hero',
      defaultVisible: false,
      category: 'budgeting'
    },
    budgetHealth: {
      id: 'hero-budget-health',
      name: 'Budget Health',
      size: 'hero',
      defaultVisible: false,
      category: 'budgeting'
    },
    // Phase 2 - Moderate Complexity (lazy loaded)
    uncategorizedCount: {
      id: 'hero-uncategorized',
      name: 'Uncategorized',
      size: 'hero',
      defaultVisible: false,
      category: 'alerts'
    },
    lowBalanceAlert: {
      id: 'hero-low-balance',
      name: 'Low Balance Alert',
      size: 'hero',
      defaultVisible: false,
      category: 'alerts'
    },
    // Phase 3 - Advanced Features (lazy loaded with charts)
    burnRate: {
      id: 'hero-burn-rate',
      name: 'Burn Rate',
      size: 'hero',
      defaultVisible: false,
      category: 'forecasting'
    },
    daysUntilDebtFree: {
      id: 'hero-debt-free',
      name: 'Days Until Debt Free',
      size: 'hero',
      defaultVisible: false,
      category: 'debts'
    }
  },
  widgets: {
    trendChart: {
      id: 'trend-chart-card',
      name: 'Income vs Expenses',
      size: 'large',
      defaultVisible: true
    },
    spendingChart: {
      id: 'spending-chart-card',
      name: 'Spending by Category',
      size: 'medium',
      defaultVisible: true
    },
    netWorthHistory: {
      id: 'net-worth-history-card',
      name: 'Net Worth History',
      size: 'medium',
      defaultVisible: true
    },
    recentTransactions: {
      id: 'recent-transactions-card',
      name: 'Recent Transactions',
      size: 'medium',
      defaultVisible: true
    },
    accounts: {
      id: 'accounts-card',
      name: 'Accounts',
      size: 'small',
      defaultVisible: true
    },
    budgetAlerts: {
      id: 'budget-alerts-card',
      name: 'Budget Alerts',
      size: 'small',
      defaultVisible: true
    },
    upcomingBills: {
      id: 'upcoming-bills-card',
      name: 'Upcoming Bills',
      size: 'small',
      defaultVisible: true
    },
    budgetProgress: {
      id: 'budget-progress-card',
      name: 'Budget Progress',
      size: 'small',
      defaultVisible: true
    },
    savingsGoals: {
      id: 'savings-goals-card',
      name: 'Savings Goals',
      size: 'small',
      defaultVisible: true
    },
    debtPayoff: {
      id: 'debt-payoff-card',
      name: 'Debt Payoff',
      size: 'small',
      defaultVisible: true
    },
    // Phase 1 - Quick Wins (use existing data)
    topCategories: {
      id: 'top-categories-card',
      name: 'Top Spending Categories',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    accountPerformance: {
      id: 'account-performance-card',
      name: 'Account Performance',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    budgetBreakdown: {
      id: 'budget-breakdown-card',
      name: 'Budget Breakdown',
      size: 'medium',
      defaultVisible: false,
      category: 'budgeting'
    },
    goalsSummary: {
      id: 'goals-summary-card',
      name: 'Savings Goals Summary',
      size: 'small',
      defaultVisible: false,
      category: 'goals'
    },
    paymentBreakdown: {
      id: 'payment-breakdown-card',
      name: 'Payment Methods',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    reconciliationStatus: {
      id: 'reconciliation-card',
      name: 'Reconciliation Status',
      size: 'small',
      defaultVisible: false,
      category: 'transactions'
    },
    // Phase 2 - Moderate Complexity (lazy loaded)
    monthlyComparison: {
      id: 'monthly-comparison-card',
      name: 'Monthly Comparison',
      size: 'medium',
      defaultVisible: false,
      category: 'insights'
    },
    largeTransactions: {
      id: 'large-transactions-card',
      name: 'Large Transactions',
      size: 'medium',
      defaultVisible: false,
      category: 'transactions'
    },
    weeklyTrend: {
      id: 'weekly-trend-card',
      name: 'Weekly Spending',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    unmatchedTransfers: {
      id: 'unmatched-transfers-card',
      name: 'Unmatched Transfers',
      size: 'small',
      defaultVisible: false,
      category: 'transactions'
    },
    categoryTrends: {
      id: 'category-trends-card',
      name: 'Category Trends',
      size: 'medium',
      defaultVisible: false,
      category: 'insights'
    },
    billsDueSoon: {
      id: 'bills-due-soon-card',
      name: 'Bills Due Soon',
      size: 'small',
      defaultVisible: false,
      category: 'bills'
    },
    // Phase 3 - Advanced Features (lazy loaded with charts)
    cashFlowForecast: {
      id: 'cash-flow-forecast-card',
      name: 'Cash Flow Forecast',
      size: 'large',
      defaultVisible: false,
      category: 'forecasting'
    },
    yoyComparison: {
      id: 'yoy-comparison-card',
      name: 'Year-over-Year',
      size: 'large',
      defaultVisible: false,
      category: 'insights'
    },
    incomeTracking: {
      id: 'income-tracking-card',
      name: 'Income Tracking',
      size: 'medium',
      defaultVisible: false,
      category: 'income'
    },
    recentImports: {
      id: 'recent-imports-card',
      name: 'Recent Imports',
      size: 'small',
      defaultVisible: false,
      category: 'transactions'
    },
    ruleEffectiveness: {
      id: 'rule-effectiveness-card',
      name: 'Rule Effectiveness',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    spendingVelocity: {
      id: 'spending-velocity-card',
      name: 'Spending Velocity',
      size: 'small',
      defaultVisible: false,
      category: 'insights'
    },
    // Phase 4 - Interactive Widgets
    quickAdd: {
      id: 'quick-add-card',
      name: 'Quick Add Transaction',
      size: 'medium',
      defaultVisible: false,
      category: 'interactive'
    }
  }
};

/***/ }),

/***/ "./src/core/Router.js":
/*!****************************!*\
  !*** ./src/core/Router.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Router)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Router - Client-side navigation and view management
 */
var Router = /*#__PURE__*/function () {
  function Router(app) {
    _classCallCheck(this, Router);
    this.app = app;
  }
  return _createClass(Router, [{
    key: "setupNavigation",
    value: function setupNavigation() {
      var _this = this;
      document.querySelectorAll('.app-navigation-entry a').forEach(function (link) {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          var view = link.getAttribute('href').substring(1);
          _this.showView(view);

          // Update active state on parent li
          document.querySelectorAll('.app-navigation-entry').forEach(function (entry) {
            return entry.classList.remove('active');
          });
          link.parentElement.classList.add('active');
        });
      });
    }
  }, {
    key: "showView",
    value: function showView(viewName) {
      // Hide all views
      document.querySelectorAll('.view').forEach(function (view) {
        view.classList.remove('active');
        view.style.display = ''; // Clear any inline display styles
      });

      // Show selected view
      var view = document.getElementById("".concat(viewName, "-view"));
      if (view) {
        view.classList.add('active');
        this.app.currentView = viewName;

        // Load view-specific data
        switch (viewName) {
          case 'dashboard':
            this.app.loadDashboard();
            break;
          case 'accounts':
            this.app.loadAccounts();
            break;
          case 'transactions':
            this.app.loadTransactions();
            break;
          case 'categories':
            this.app.loadCategories();
            break;
          case 'budget':
            this.app.loadBudgetView();
            break;
          case 'forecast':
            this.app.loadForecastView();
            break;
          case 'reports':
            this.app.loadReportsView();
            break;
          case 'bills':
            this.app.loadBillsView();
            break;
          case 'rules':
            this.app.loadRulesView();
            break;
          case 'income':
            this.app.loadIncomeView();
            break;
          case 'savings-goals':
            this.app.loadSavingsGoalsView();
            break;
          case 'debt-payoff':
            this.app.loadDebtPayoffView();
            break;
          case 'shared-expenses':
            this.app.loadSharedExpensesView();
            break;
          case 'pensions':
            this.app.loadPensionsView();
            break;
          case 'settings':
            this.app.loadSettingsView();
            break;
        }
      }
    }
  }, {
    key: "reloadCurrentView",
    value: function reloadCurrentView() {
      // Reload the current view to apply setting changes
      switch (this.app.currentView) {
        case 'dashboard':
          this.app.loadDashboard();
          break;
        case 'accounts':
          this.app.loadAccounts();
          break;
        case 'transactions':
          this.app.loadTransactions();
          break;
        case 'categories':
          this.app.loadCategories();
          break;
        case 'budget':
          this.app.loadBudgetView();
          break;
        case 'forecast':
          this.app.loadForecastView();
          break;
        case 'reports':
          this.app.loadReportsView();
          break;
        case 'bills':
          this.app.loadBillsView();
          break;
        case 'rules':
          this.app.loadRulesView();
          break;
        case 'income':
          this.app.loadIncomeView();
          break;
        case 'savings-goals':
          this.app.loadSavingsGoalsView();
          break;
        case 'debt-payoff':
          this.app.loadDebtPayoffView();
          break;
        case 'shared-expenses':
          this.app.loadSharedExpensesView();
          break;
        case 'pensions':
          this.app.loadPensionsView();
          break;
        case 'settings':
          // Don't reload settings view (we're already in it)
          break;
      }
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/accounts/AccountsModule.js":
/*!************************************************!*\
  !*** ./src/modules/accounts/AccountsModule.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AccountsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Accounts Module - Account management and visualization
 */


var AccountsModule = /*#__PURE__*/function () {
  function AccountsModule(app) {
    _classCallCheck(this, AccountsModule);
    this.app = app;

    // Account details state
    this.currentAccount = null;
    this.accountTransactions = [];
    this.accountCurrentPage = 1;
    this.accountRowsPerPage = 50;
    this.accountFilters = {};
    this.accountSort = {
      field: 'date',
      direction: 'desc'
    };
    this.accountTotalPages = 1;
    this.accountTotal = 0;
  }

  // ============================================
  // State Proxies
  // ============================================
  return _createClass(AccountsModule, [{
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    },
    set: function set(value) {
      this.app.accounts = value;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "data",
    get: function get() {
      return this.app.data;
    }

    // ============================================
    // Helper Method Proxies
    // ============================================
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(date) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(date);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return this.app.getPrimaryCurrency();
    }
  }, {
    key: "populateAccountDropdowns",
    value: function populateAccountDropdowns() {
      return this.app.populateAccountDropdowns();
    }
  }, {
    key: "loadTransactions",
    value: function loadTransactions() {
      return this.app.loadTransactions();
    }
  }, {
    key: "showView",
    value: function showView(viewName) {
      return this.app.router.showView(viewName);
    }
  }, {
    key: "hideModals",
    value: function hideModals() {
      return this.app.hideModals();
    }
  }, {
    key: "loadInitialData",
    value: function loadInitialData() {
      return this.app.loadInitialData();
    }
  }, {
    key: "editTransaction",
    value: function editTransaction(id) {
      return this.app.editTransaction(id);
    }
  }, {
    key: "deleteTransaction",
    value: function deleteTransaction(id) {
      return this.app.deleteTransaction(id);
    }
  }, {
    key: "loadAndDisplayTransactionTags",
    value: function loadAndDisplayTransactionTags() {
      return this.app.loadAndDisplayTransactionTags();
    }
  }, {
    key: "getSelectedTransactionTags",
    value: function getSelectedTransactionTags() {
      return this.app.getSelectedTransactionTags();
    }
  }, {
    key: "saveTransactionTags",
    value: function saveTransactionTags(transactionId, tagIds) {
      return this.app.saveTransactionTags(transactionId, tagIds);
    }
  }, {
    key: "setupCategoriesEventListeners",
    value: function setupCategoriesEventListeners() {
      return this.app.setupCategoriesEventListeners();
    }
  }, {
    key: "renderCategoriesTree",
    value: function renderCategoriesTree() {
      return this.app.renderCategoriesTree();
    }
  }, {
    key: "loadDashboard",
    value: function loadDashboard() {
      return this.app.loadDashboard();
    }

    // ============================================
    // Accounts Module Methods
    // ============================================
  }, {
    key: "loadAccounts",
    value: function () {
      var _loadAccounts = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, accounts, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/accounts'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context.v;
              if (response.ok) {
                _context.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              _context.n = 3;
              return response.json();
            case 3:
              accounts = _context.v;
              if (!(accounts && accounts.message === "CSRF check failed")) {
                _context.n = 4;
                break;
              }
              throw new Error('CSRF check failed - please refresh the page');
            case 4:
              if (Array.isArray(accounts)) {
                _context.n = 5;
                break;
              }
              console.error('API returned non-array:', accounts);
              throw new Error('API returned invalid data format');
            case 5:
              // Update the instance accounts array
              this.accounts = accounts;

              // Render the accounts page with new layout
              this.renderAccountsPage(accounts);

              // Also update account dropdowns
              this.populateAccountDropdowns();
              // Add click handlers for account cards
              this.setupAccountCardClickHandlers();
              _context.n = 7;
              break;
            case 6:
              _context.p = 6;
              _t = _context.v;
              console.error('Failed to load accounts:', _t);
            case 7:
              return _context.a(2);
          }
        }, _callee, this, [[0, 6]]);
      }));
      function loadAccounts() {
        return _loadAccounts.apply(this, arguments);
      }
      return loadAccounts;
    }()
  }, {
    key: "renderAccountsPage",
    value: function renderAccountsPage(accounts) {
      var _this = this;
      // Helper function to get field with both camelCase and snake_case support
      var getField = function getField(obj, camelName) {
        var snakeName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!snakeName) {
          snakeName = camelName.replace(/[A-Z]/g, function (letter) {
            return "_".concat(letter.toLowerCase());
          });
        }
        return obj[camelName] || obj[snakeName] || null;
      };

      // Categorize accounts into assets and liabilities
      var assetTypes = ['checking', 'savings', 'investment', 'cash'];
      var liabilityTypes = ['credit_card', 'loan'];
      var assets = accounts.filter(function (acc) {
        return assetTypes.includes(getField(acc, 'type'));
      });
      var liabilities = accounts.filter(function (acc) {
        return liabilityTypes.includes(getField(acc, 'type'));
      });

      // Calculate totals
      var primaryCurrency = this.getPrimaryCurrency();
      var totalAssets = 0;
      var totalLiabilities = 0;
      assets.forEach(function (acc) {
        totalAssets += parseFloat(getField(acc, 'balance')) || 0;
      });
      liabilities.forEach(function (acc) {
        // Liabilities are typically negative or represent debt
        var balance = parseFloat(getField(acc, 'balance')) || 0;
        totalLiabilities += Math.abs(balance);
      });
      var netWorth = totalAssets - totalLiabilities;

      // Update summary cards
      var totalAssetsEl = document.getElementById('summary-total-assets');
      var totalLiabilitiesEl = document.getElementById('summary-total-liabilities');
      var netWorthEl = document.getElementById('summary-net-worth');
      var assetsSubtotalEl = document.getElementById('assets-subtotal');
      var liabilitiesSubtotalEl = document.getElementById('liabilities-subtotal');
      if (totalAssetsEl) totalAssetsEl.textContent = this.formatCurrency(totalAssets, primaryCurrency);
      if (totalLiabilitiesEl) totalLiabilitiesEl.textContent = this.formatCurrency(totalLiabilities, primaryCurrency);
      if (netWorthEl) {
        netWorthEl.textContent = this.formatCurrency(netWorth, primaryCurrency);
        netWorthEl.classList.toggle('positive', netWorth >= 0);
        netWorthEl.classList.toggle('negative', netWorth < 0);
      }
      if (assetsSubtotalEl) assetsSubtotalEl.textContent = this.formatCurrency(totalAssets, primaryCurrency);
      if (liabilitiesSubtotalEl) liabilitiesSubtotalEl.textContent = this.formatCurrency(totalLiabilities, primaryCurrency);

      // Render account cards for each section
      var assetsGrid = document.getElementById('accounts-assets-grid');
      var liabilitiesGrid = document.getElementById('accounts-liabilities-grid');
      var assetsSection = document.getElementById('accounts-assets-section');
      var liabilitiesSection = document.getElementById('accounts-liabilities-section');
      if (assetsGrid) {
        if (assets.length > 0) {
          assetsGrid.innerHTML = assets.map(function (account) {
            return _this.renderAccountCard(account, getField);
          }).join('');
          assetsSection.style.display = 'block';
        } else {
          assetsGrid.innerHTML = '<div class="accounts-empty-state">No asset accounts yet</div>';
        }
      }
      if (liabilitiesGrid) {
        if (liabilities.length > 0) {
          liabilitiesGrid.innerHTML = liabilities.map(function (account) {
            return _this.renderAccountCard(account, getField);
          }).join('');
          liabilitiesSection.style.display = 'block';
        } else {
          liabilitiesSection.style.display = 'none';
        }
      }

      // Load sparklines asynchronously
      this.loadAccountSparklines(accounts);
    }
  }, {
    key: "renderAccountCard",
    value: function renderAccountCard(account, getField) {
      var accountType = getField(account, 'type') || 'unknown';
      var accountName = getField(account, 'name') || 'Unnamed Account';
      var accountBalance = parseFloat(getField(account, 'balance')) || 0;
      var accountCurrency = getField(account, 'currency') || this.getPrimaryCurrency();
      var accountId = getField(account, 'id') || 0;
      var institution = getField(account, 'institution') || '';
      var typeInfo = this.getAccountTypeInfo(accountType);
      var healthStatus = this.getAccountHealthStatus(account);

      // For liabilities (credit cards, loans), display balance differently
      var isLiability = ['credit_card', 'loan'].includes(accountType);
      var displayBalance = isLiability ? Math.abs(accountBalance) : accountBalance;
      var balanceClass = isLiability ? 'negative' : accountBalance >= 0 ? 'positive' : 'negative';
      return "\n            <div class=\"account-card\" data-type=\"".concat(accountType, "\" data-account-id=\"").concat(accountId, "\">\n                <div class=\"account-card-header\">\n                    <div class=\"account-icon\" style=\"background-color: ").concat(typeInfo.color, ";\">\n                        <span class=\"").concat(typeInfo.icon, "\" aria-hidden=\"true\"></span>\n                    </div>\n                    <div class=\"account-details\">\n                        <h3 class=\"account-name\">").concat(accountName, "</h3>\n                        <div class=\"account-meta\">\n                            <span class=\"account-type-badge\">").concat(typeInfo.label, "</span>\n                            ").concat(institution ? "<span class=\"account-institution\">".concat(institution, "</span>") : '', "\n                        </div>\n                    </div>\n                </div>\n\n                <div class=\"account-card-balance\">\n                    <div class=\"balance-info\">\n                        <span class=\"balance-label\">").concat(isLiability ? 'Owed' : 'Balance', "</span>\n                        <span class=\"balance-amount ").concat(balanceClass, "\">\n                            ").concat(isLiability ? '-' : '').concat(this.formatCurrency(displayBalance, accountCurrency), "\n                        </span>\n                    </div>\n                    <div class=\"account-sparkline\" data-account-id=\"").concat(accountId, "\">\n                        <svg viewBox=\"0 0 80 32\" preserveAspectRatio=\"none\">\n                            <path class=\"sparkline-path neutral\" d=\"M0,16 L80,16\"></path>\n                        </svg>\n                    </div>\n                </div>\n\n                <div class=\"account-card-footer\">\n                    <div class=\"account-status\">\n                        <span class=\"account-status-dot ").concat(healthStatus["class"], "\"></span>\n                        <span>").concat(healthStatus.tooltip, "</span>\n                    </div>\n                    <div class=\"account-actions\">\n                        <button class=\"account-action-btn edit-btn edit-account-btn\" data-account-id=\"").concat(accountId, "\" title=\"Edit Account\">\n                            <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                        </button>\n                        <button class=\"account-action-btn delete-btn delete-account-btn\" data-account-id=\"").concat(accountId, "\" title=\"Delete Account\">\n                            <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n        ");
    }
  }, {
    key: "loadAccountSparklines",
    value: function () {
      var _loadAccountSparklines = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(accounts) {
        var _iterator, _step, account, accountId, endDate, startDate, response, transactions, balanceHistory, _t2, _t3;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              // Load balance history for each account and render sparklines
              _iterator = _createForOfIteratorHelper(accounts);
              _context2.p = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context2.n = 11;
                break;
              }
              account = _step.value;
              _context2.p = 3;
              accountId = account.id || account.Id;
              if (accountId) {
                _context2.n = 4;
                break;
              }
              return _context2.a(3, 10);
            case 4:
              // Get transactions for this account from the last 7 days
              endDate = new Date();
              startDate = new Date();
              startDate.setDate(startDate.getDate() - 7);
              _context2.n = 5;
              return fetch(OC.generateUrl("/apps/budget/api/transactions?account=".concat(accountId, "&startDate=").concat(startDate.toISOString().split('T')[0], "&endDate=").concat(endDate.toISOString().split('T')[0])), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 5:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 6;
                break;
              }
              return _context2.a(3, 10);
            case 6:
              _context2.n = 7;
              return response.json();
            case 7:
              transactions = _context2.v;
              if (Array.isArray(transactions)) {
                _context2.n = 8;
                break;
              }
              return _context2.a(3, 10);
            case 8:
              // Calculate daily balances
              balanceHistory = this.calculateBalanceHistory(account, transactions, 7); // Render sparkline
              this.renderSparkline(accountId, balanceHistory);
              _context2.n = 10;
              break;
            case 9:
              _context2.p = 9;
              _t2 = _context2.v;
              console.error("Failed to load sparkline for account ".concat(account.id, ":"), _t2);
            case 10:
              _context2.n = 2;
              break;
            case 11:
              _context2.n = 13;
              break;
            case 12:
              _context2.p = 12;
              _t3 = _context2.v;
              _iterator.e(_t3);
            case 13:
              _context2.p = 13;
              _iterator.f();
              return _context2.f(13);
            case 14:
              return _context2.a(2);
          }
        }, _callee2, this, [[3, 9], [1, 12, 13, 14]]);
      }));
      function loadAccountSparklines(_x) {
        return _loadAccountSparklines.apply(this, arguments);
      }
      return loadAccountSparklines;
    }()
  }, {
    key: "calculateBalanceHistory",
    value: function calculateBalanceHistory(account, transactions, days) {
      var currentBalance = parseFloat(account.balance) || 0;
      var balances = [];

      // Sort transactions by date descending
      var sortedTxns = _toConsumableArray(transactions).sort(function (a, b) {
        return new Date(b.date || b.Date) - new Date(a.date || a.Date);
      });

      // Start with current balance and work backwards
      var runningBalance = currentBalance;
      var today = new Date();
      today.setHours(23, 59, 59, 999);
      var _loop = function _loop() {
        var date = new Date(today);
        date.setDate(date.getDate() - i);
        date.setHours(0, 0, 0, 0);

        // Find transactions on this day and reverse their effect
        var dayTxns = sortedTxns.filter(function (t) {
          var txnDate = new Date(t.date || t.Date);
          txnDate.setHours(0, 0, 0, 0);
          return txnDate.getTime() === date.getTime();
        });

        // Store the balance at end of this day
        balances.unshift(runningBalance);

        // Reverse transactions to get previous day's balance
        dayTxns.forEach(function (t) {
          var amount = parseFloat(t.amount || t.Amount) || 0;
          runningBalance -= amount;
        });
      };
      for (var i = 0; i < days; i++) {
        _loop();
      }
      return balances;
    }
  }, {
    key: "renderSparkline",
    value: function renderSparkline(accountId, balances) {
      var sparklineEl = document.querySelector(".account-sparkline[data-account-id=\"".concat(accountId, "\"] svg"));
      if (!sparklineEl || balances.length < 2) return;
      var width = 80;
      var height = 32;
      var padding = 2;

      // Find min and max for scaling
      var min = Math.min.apply(Math, _toConsumableArray(balances));
      var max = Math.max.apply(Math, _toConsumableArray(balances));
      var range = max - min || 1;

      // Generate path points
      var points = balances.map(function (val, i) {
        var x = padding + i / (balances.length - 1) * (width - padding * 2);
        var y = padding + (1 - (val - min) / range) * (height - padding * 2);
        return "".concat(x, ",").concat(y);
      });
      var pathD = "M".concat(points.join(' L'));

      // Determine trend color
      var trend = balances[balances.length - 1] - balances[0];
      var trendClass = trend > 0 ? 'positive' : trend < 0 ? 'negative' : 'neutral';
      sparklineEl.innerHTML = "<path class=\"sparkline-path ".concat(trendClass, "\" d=\"").concat(pathD, "\"></path>");
    }
  }, {
    key: "setupAccountCardClickHandlers",
    value: function setupAccountCardClickHandlers() {
      var _this2 = this;
      var accountCards = document.querySelectorAll('.account-card');
      accountCards.forEach(function (card) {
        card.addEventListener('click', function (e) {
          // Don't trigger if clicking on action buttons
          if (e.target.closest('.account-actions, button')) {
            return;
          }
          var accountId = parseInt(card.dataset.accountId);
          if (accountId) {
            _this2.showAccountDetails(accountId);
          }
        });
      });
    }
  }, {
    key: "showAccountDetails",
    value: function () {
      var _showAccountDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(accountId) {
        var account, _t4;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              // Find the account in our cached data
              account = this.accounts.find(function (acc) {
                return acc.id === accountId;
              });
              if (account) {
                _context3.n = 1;
                break;
              }
              throw new Error('Account not found');
            case 1:
              // Hide accounts list and show account details
              document.getElementById('accounts-view').style.display = 'none';
              document.getElementById('account-details-view').style.display = 'block';

              // Store current account for context
              this.currentAccount = account;

              // Populate account overview
              this.populateAccountOverview(account);

              // Load account transactions and metrics
              _context3.n = 2;
              return this.loadAccountTransactions(accountId);
            case 2:
              _context3.n = 3;
              return this.loadAccountMetrics(accountId);
            case 3:
              // Setup account details event listeners
              this.setupAccountDetailsEventListeners();
              _context3.n = 5;
              break;
            case 4:
              _context3.p = 4;
              _t4 = _context3.v;
              console.error('Failed to show account details:', _t4);
              OC.Notification.showTemporary('Failed to load account details');
            case 5:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 4]]);
      }));
      function showAccountDetails(_x2) {
        return _showAccountDetails.apply(this, arguments);
      }
      return showAccountDetails;
    }()
  }, {
    key: "populateAccountOverview",
    value: function populateAccountOverview(account) {
      // Update title and breadcrumb
      document.getElementById('account-details-title').textContent = account.name;

      // Get account type info
      var typeInfo = this.getAccountTypeInfo(account.type);
      var healthStatus = this.getAccountHealthStatus(account);

      // Update account header
      var typeIcon = document.getElementById('account-type-icon');
      if (typeIcon) {
        typeIcon.className = "account-type-icon ".concat(typeInfo.icon);
        typeIcon.style.color = typeInfo.color;
      }
      document.getElementById('account-display-name').textContent = account.name;
      document.getElementById('account-type-label').textContent = typeInfo.label;
      var institutionEl = document.getElementById('account-institution');
      if (account.institution) {
        institutionEl.textContent = account.institution;
        institutionEl.style.display = 'inline';
      } else {
        institutionEl.style.display = 'none';
      }

      // Update health indicator
      var healthIndicator = document.getElementById('account-health-indicator');
      if (healthIndicator) {
        healthIndicator.className = "health-indicator ".concat(healthStatus["class"]);
        if (healthStatus.tooltip) {
          healthIndicator.title = healthStatus.tooltip;
        }
      }

      // Update balance information
      var currentBalance = account.balance || 0;
      var currency = account.currency || this.getPrimaryCurrency();
      document.getElementById('account-current-balance').textContent = this.formatCurrency(currentBalance, currency);
      document.getElementById('account-current-balance').className = "balance-amount ".concat(currentBalance >= 0 ? 'positive' : 'negative');

      // Calculate available balance
      var availableBalance = currentBalance;
      if (account.type === 'credit_card' && account.creditLimit) {
        availableBalance = account.creditLimit - Math.abs(currentBalance);
        // Show credit info
        document.getElementById('credit-info').style.display = 'block';
        document.getElementById('account-credit-limit').textContent = this.formatCurrency(account.creditLimit, currency);
      } else {
        document.getElementById('credit-info').style.display = 'none';
      }
      document.getElementById('account-available-balance').textContent = this.formatCurrency(availableBalance, currency);
      document.getElementById('account-available-balance').className = "balance-amount ".concat(availableBalance >= 0 ? 'positive' : 'negative');

      // Update account details
      document.getElementById('account-number').textContent = account.accountNumber ? '***' + account.accountNumber.slice(-4) : 'Not provided';
      document.getElementById('routing-number').textContent = account.routingNumber || 'Not provided';
      document.getElementById('account-iban').textContent = account.iban || 'Not provided';
      document.getElementById('sort-code').textContent = account.sortCode || 'Not provided';
      document.getElementById('swift-bic').textContent = account.swiftBic || 'Not provided';
      document.getElementById('account-display-currency').textContent = currency;
      document.getElementById('account-opened').textContent = account.openedDate ? this.formatDate(account.openedDate) : 'Not provided';
      document.getElementById('last-reconciled').textContent = account.lastReconciled ? this.formatDate(account.lastReconciled) : 'Never';
    }
  }, {
    key: "loadAccountTransactions",
    value: function () {
      var _loadAccountTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(accountId) {
        var params, response, result, _t5;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              // Initialize account-specific state
              this.accountCurrentPage = 1;
              this.accountRowsPerPage = 50;
              this.accountFilters = {};
              this.accountSort = {
                field: 'date',
                direction: 'desc'
              };

              // Build query for account-specific transactions
              params = new URLSearchParams({
                accountId: accountId,
                limit: this.accountRowsPerPage,
                page: this.accountCurrentPage,
                sort: this.accountSort.field,
                direction: this.accountSort.direction
              });
              _context4.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/transactions?' + params.toString()), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context4.v;
              if (!response.ok) {
                _context4.n = 3;
                break;
              }
              _context4.n = 2;
              return response.json();
            case 2:
              result = _context4.v;
              this.accountTransactions = result.transactions || result; // Handle both formats
              this.accountTotalPages = result.totalPages || 1;
              this.accountTotal = result.total || this.accountTransactions.length;
              _context4.n = 5;
              break;
            case 3:
              _context4.n = 4;
              return this.loadTransactions();
            case 4:
              this.accountTransactions = this.transactions.filter(function (t) {
                return t.accountId === accountId;
              });
              this.accountTotal = this.accountTransactions.length;
              this.accountTotalPages = Math.ceil(this.accountTotal / this.accountRowsPerPage);
            case 5:
              // Render account transactions
              this.renderAccountTransactions();
              this.updateAccountPagination();
              _context4.n = 7;
              break;
            case 6:
              _context4.p = 6;
              _t5 = _context4.v;
              console.error('Failed to load account transactions:', _t5);
              // Show empty state
              this.accountTransactions = [];
              this.renderAccountTransactions();
            case 7:
              return _context4.a(2);
          }
        }, _callee4, this, [[0, 6]]);
      }));
      function loadAccountTransactions(_x3) {
        return _loadAccountTransactions.apply(this, arguments);
      }
      return loadAccountTransactions;
    }()
  }, {
    key: "renderAccountTransactions",
    value: function renderAccountTransactions() {
      var _this$currentAccount,
        _this3 = this;
      var tbody = document.getElementById('account-transactions-body');
      if (!tbody) return;
      if (!this.accountTransactions || this.accountTransactions.length === 0) {
        tbody.innerHTML = "\n                <tr>\n                    <td colspan=\"6\" class=\"empty-state\">\n                        <div class=\"empty-content\">\n                            <span class=\"icon-menu\" aria-hidden=\"true\"></span>\n                            <h3>No transactions found</h3>\n                            <p>This account doesn't have any transactions yet.</p>\n                        </div>\n                    </td>\n                </tr>\n            ";
        return;
      }

      // Calculate running balance
      var runningBalance = ((_this$currentAccount = this.currentAccount) === null || _this$currentAccount === void 0 ? void 0 : _this$currentAccount.balance) || 0;
      var transactionsWithBalance = _toConsumableArray(this.accountTransactions).reverse().map(function (transaction) {
        var amount = parseFloat(transaction.amount) || 0;
        if (transaction.type === 'credit') {
          runningBalance -= amount; // Remove to get previous balance
        } else {
          runningBalance += amount; // Add back to get previous balance
        }
        var balanceAtTime = runningBalance;

        // Adjust for next iteration
        if (transaction.type === 'credit') {
          runningBalance += amount;
        } else {
          runningBalance -= amount;
        }
        return _objectSpread(_objectSpread({}, transaction), {}, {
          balanceAtTime: balanceAtTime
        });
      }).reverse();
      tbody.innerHTML = transactionsWithBalance.map(function (transaction) {
        var _this3$currentAccount, _this3$categories;
        var amount = parseFloat(transaction.amount) || 0;
        var currency = ((_this3$currentAccount = _this3.currentAccount) === null || _this3$currentAccount === void 0 ? void 0 : _this3$currentAccount.currency) || _this3.getPrimaryCurrency();
        var category = (_this3$categories = _this3.categories) === null || _this3$categories === void 0 ? void 0 : _this3$categories.find(function (c) {
          return c.id === transaction.categoryId;
        });
        return "\n                <tr class=\"transaction-row\" data-transaction-id=\"".concat(transaction.id, "\">\n                    <td class=\"date-column\">\n                        <span class=\"transaction-date\">").concat(_this3.formatDate(transaction.date), "</span>\n                    </td>\n                    <td class=\"description-column\">\n                        <div class=\"transaction-description\">\n                            <span class=\"description-main\">").concat(transaction.description || 'No description', "</span>\n                            ").concat(transaction.vendor ? "<span class=\"vendor-name\">".concat(transaction.vendor, "</span>") : '', "\n                        </div>\n                    </td>\n                    <td class=\"category-column\">\n                        <span class=\"category-name ").concat(category ? '' : 'uncategorized', "\">\n                            ").concat(category ? category.name : 'Uncategorized', "\n                        </span>\n                        <div class=\"transaction-tags-display\" data-transaction-id=\"").concat(transaction.id, "\" style=\"margin-top: 4px;\"></div>\n                    </td>\n                    <td class=\"amount-column\">\n                        <span class=\"transaction-amount ").concat(transaction.type, "\">\n                            ").concat(transaction.type === 'credit' ? '+' : '-').concat(_this3.formatCurrency(Math.abs(amount), currency), "\n                        </span>\n                    </td>\n                    <td class=\"balance-column\">\n                        <span class=\"transaction-balance ").concat(transaction.balanceAtTime >= 0 ? 'positive' : 'negative', "\">\n                            ").concat(_this3.formatCurrency(transaction.balanceAtTime, currency), "\n                        </span>\n                    </td>\n                    <td class=\"actions-column\">\n                        <div class=\"transaction-actions\">\n                            <button class=\"icon-rename edit-transaction-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Edit transaction\"></button>\n                            <button class=\"icon-delete delete-transaction-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Delete transaction\"></button>\n                        </div>\n                    </td>\n                </tr>\n            ");
      }).join('');

      // Add event listeners for transaction actions
      this.setupAccountTransactionActionListeners();

      // Load and display tags for visible transactions
      this.loadAndDisplayTransactionTags();
    }
  }, {
    key: "setupAccountTransactionActionListeners",
    value: function setupAccountTransactionActionListeners() {
      var _this4 = this;
      // Edit transaction buttons
      document.querySelectorAll('.edit-transaction-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          var transactionId = parseInt(e.target.dataset.transactionId);
          _this4.editTransaction(transactionId);
        });
      });

      // Delete transaction buttons
      document.querySelectorAll('.delete-transaction-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          var transactionId = parseInt(e.target.dataset.transactionId);
          _this4.deleteTransaction(transactionId);
        });
      });
    }
  }, {
    key: "loadAccountMetrics",
    value: function () {
      var _loadAccountMetrics = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(accountId) {
        var _this$currentAccount2, now, startOfMonth, endOfMonth, thisMonthTransactions, totalTransactions, thisMonthIncome, thisMonthExpenses, avgTransaction, currency;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              try {
                // Calculate metrics from transactions
                now = new Date();
                startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Filter transactions for this month
                thisMonthTransactions = this.accountTransactions.filter(function (t) {
                  var transDate = new Date(t.date);
                  return transDate >= startOfMonth && transDate <= endOfMonth;
                }); // Calculate metrics
                totalTransactions = this.accountTransactions.length;
                thisMonthIncome = thisMonthTransactions.filter(function (t) {
                  return t.type === 'credit';
                }).reduce(function (sum, t) {
                  return sum + (parseFloat(t.amount) || 0);
                }, 0);
                thisMonthExpenses = thisMonthTransactions.filter(function (t) {
                  return t.type === 'debit';
                }).reduce(function (sum, t) {
                  return sum + (parseFloat(t.amount) || 0);
                }, 0);
                avgTransaction = totalTransactions > 0 ? this.accountTransactions.reduce(function (sum, t) {
                  return sum + Math.abs(parseFloat(t.amount) || 0);
                }, 0) / totalTransactions : 0;
                currency = ((_this$currentAccount2 = this.currentAccount) === null || _this$currentAccount2 === void 0 ? void 0 : _this$currentAccount2.currency) || this.getPrimaryCurrency(); // Update metrics display
                document.getElementById('total-transactions').textContent = totalTransactions.toLocaleString();
                document.getElementById('total-income').textContent = this.formatCurrency(thisMonthIncome, currency);
                document.getElementById('total-expenses').textContent = this.formatCurrency(thisMonthExpenses, currency);
                document.getElementById('avg-transaction').textContent = this.formatCurrency(avgTransaction, currency);
              } catch (error) {
                console.error('Failed to calculate account metrics:', error);
                // Show zeros on error
                document.getElementById('total-transactions').textContent = '0';
                document.getElementById('total-income').textContent = this.formatCurrency(0);
                document.getElementById('total-expenses').textContent = this.formatCurrency(0);
                document.getElementById('avg-transaction').textContent = this.formatCurrency(0);
              }
            case 1:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function loadAccountMetrics(_x4) {
        return _loadAccountMetrics.apply(this, arguments);
      }
      return loadAccountMetrics;
    }()
  }, {
    key: "updateAccountPagination",
    value: function updateAccountPagination() {
      var prevBtn = document.getElementById('account-prev-page');
      var nextBtn = document.getElementById('account-next-page');
      var pageInfo = document.getElementById('account-page-info');
      if (prevBtn) prevBtn.disabled = this.accountCurrentPage <= 1;
      if (nextBtn) nextBtn.disabled = this.accountCurrentPage >= this.accountTotalPages;
      if (pageInfo) pageInfo.textContent = "Page ".concat(this.accountCurrentPage, " of ").concat(this.accountTotalPages);
    }
  }, {
    key: "setupAccountDetailsEventListeners",
    value: function setupAccountDetailsEventListeners() {
      var _this5 = this;
      // Back to accounts button
      var backBtn = document.getElementById('back-to-accounts-btn');
      if (backBtn) {
        backBtn.addEventListener('click', function () {
          return _this5.hideAccountDetails();
        });
      }

      // Edit account button
      var editBtn = document.getElementById('edit-account-btn');
      if (editBtn) {
        editBtn.addEventListener('click', function () {
          return _this5.editAccount(_this5.currentAccount.id);
        });
      }

      // Reconcile account button
      var reconcileBtn = document.getElementById('reconcile-account-btn');
      if (reconcileBtn) {
        reconcileBtn.addEventListener('click', function () {
          return _this5.reconcileAccount(_this5.currentAccount.id);
        });
      }

      // Account filter event listeners
      this.setupAccountFilterEventListeners();

      // Account pagination event listeners
      var prevBtn = document.getElementById('account-prev-page');
      var nextBtn = document.getElementById('account-next-page');
      if (prevBtn) {
        prevBtn.addEventListener('click', function () {
          if (_this5.accountCurrentPage > 1) {
            _this5.accountCurrentPage--;
            _this5.loadAccountTransactions(_this5.currentAccount.id);
          }
        });
      }
      if (nextBtn) {
        nextBtn.addEventListener('click', function () {
          if (_this5.accountCurrentPage < _this5.accountTotalPages) {
            _this5.accountCurrentPage++;
            _this5.loadAccountTransactions(_this5.currentAccount.id);
          }
        });
      }
    }
  }, {
    key: "setupAccountFilterEventListeners",
    value: function setupAccountFilterEventListeners() {
      var _this6 = this;
      // Apply filters button
      var applyBtn = document.getElementById('account-apply-filters-btn');
      if (applyBtn) {
        applyBtn.addEventListener('click', function () {
          return _this6.applyAccountFilters();
        });
      }

      // Clear filters button
      var clearBtn = document.getElementById('account-clear-filters-btn');
      if (clearBtn) {
        clearBtn.addEventListener('click', function () {
          return _this6.clearAccountFilters();
        });
      }

      // Auto-populate category filter
      var categoryFilter = document.getElementById('account-filter-category');
      if (categoryFilter && this.categories) {
        categoryFilter.innerHTML = '<option value="">All Categories</option><option value="uncategorized">Uncategorized</option>';
        this.categories.forEach(function (category) {
          categoryFilter.innerHTML += "<option value=\"".concat(category.id, "\">").concat(category.name, "</option>");
        });
      }
    }
  }, {
    key: "applyAccountFilters",
    value: function applyAccountFilters() {
      var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4, _document$getElementB5, _document$getElementB6, _document$getElementB7;
      // Collect filter values
      this.accountFilters = {
        category: ((_document$getElementB = document.getElementById('account-filter-category')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || '',
        type: ((_document$getElementB2 = document.getElementById('account-filter-type')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value) || '',
        dateFrom: ((_document$getElementB3 = document.getElementById('account-filter-date-from')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.value) || '',
        dateTo: ((_document$getElementB4 = document.getElementById('account-filter-date-to')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value) || '',
        amountMin: ((_document$getElementB5 = document.getElementById('account-filter-amount-min')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value) || '',
        amountMax: ((_document$getElementB6 = document.getElementById('account-filter-amount-max')) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.value) || '',
        search: ((_document$getElementB7 = document.getElementById('account-filter-search')) === null || _document$getElementB7 === void 0 ? void 0 : _document$getElementB7.value) || ''
      };

      // Reset to first page and reload
      this.accountCurrentPage = 1;
      this.loadAccountTransactions(this.currentAccount.id);
    }
  }, {
    key: "clearAccountFilters",
    value: function clearAccountFilters() {
      // Clear all filter inputs
      document.getElementById('account-filter-category').value = '';
      document.getElementById('account-filter-type').value = '';
      document.getElementById('account-filter-date-from').value = '';
      document.getElementById('account-filter-date-to').value = '';
      document.getElementById('account-filter-amount-min').value = '';
      document.getElementById('account-filter-amount-max').value = '';
      document.getElementById('account-filter-search').value = '';

      // Clear filters and reload
      this.accountFilters = {};
      this.accountCurrentPage = 1;
      this.loadAccountTransactions(this.currentAccount.id);
    }
  }, {
    key: "hideAccountDetails",
    value: function hideAccountDetails() {
      document.getElementById('account-details-view').style.display = 'none';
      document.getElementById('accounts-view').style.display = 'block';
      this.currentAccount = null;
    }

    // Additional missing methods
  }, {
    key: "toggleTransactionReconciliation",
    value: function toggleTransactionReconciliation(transactionId, reconciled) {
      // This would update the transaction's reconciliation status
      // Implementation depends on backend API
      console.log("Toggle reconciliation for transaction ".concat(transactionId, ": ").concat(reconciled));
    }
  }, {
    key: "finishReconciliation",
    value: function finishReconciliation() {
      if (!this.reconcileData || !this.reconcileData.isBalanced) {
        OC.Notification.showTemporary('Cannot finish reconciliation - balances do not match');
        return;
      }

      // Mark all checked transactions as reconciled and finish reconciliation
      this.cancelReconciliation();
      OC.Notification.showTemporary('Reconciliation completed successfully');
    }
  }, {
    key: "loadCategories",
    value: function () {
      var _loadCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var response, categories, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              // Initialize category state with defaults
              this.categoryTree = [];
              this.allCategories = [];
              this.currentCategoryType = this.currentCategoryType || 'expense';
              this.selectedCategory = null;
              this.expandedCategories = this.expandedCategories || new Set();
              _context6.p = 1;
              _context6.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/categories/tree'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context6.v;
              _context6.n = 3;
              return response.json();
            case 3:
              categories = _context6.v;
              // Update category state with fetched data
              if (Array.isArray(categories)) {
                this.categoryTree = categories;
                this.allCategories = categories;
              }
              _context6.n = 5;
              break;
            case 4:
              _context6.p = 4;
              _t6 = _context6.v;
              console.error('Failed to load categories:', _t6);
            case 5:
              // Always setup event listeners and render (even if fetch failed)
              this.setupCategoriesEventListeners();
              this.renderCategoriesTree();
            case 6:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 4]]);
      }));
      function loadCategories() {
        return _loadCategories.apply(this, arguments);
      }
      return loadCategories;
    }()
  }, {
    key: "saveTransaction",
    value: function () {
      var _saveTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var getFormValue, accountId, date, type, amount, description, formData, transactionId, url, method, response, result, savedTransactionId, selectedTagIds, errorMessage, errorData, _t7, _t8;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              // Helper function to safely get and clean form values
              getFormValue = function getFormValue(id) {
                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var isNumeric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var isInteger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var element = document.getElementById(id);
                if (!element) return defaultValue;
                var value = element.value ? String(element.value).trim() : '';
                if (value === '') return defaultValue;
                if (isInteger) {
                  var intValue = parseInt(value);
                  return isNaN(intValue) ? defaultValue : intValue;
                }
                if (isNumeric) {
                  var numValue = parseFloat(value);
                  return isNaN(numValue) ? defaultValue : numValue;
                }
                return value;
              }; // Validate required fields
              accountId = getFormValue('transaction-account', null, false, true);
              date = getFormValue('transaction-date');
              type = getFormValue('transaction-type');
              amount = getFormValue('transaction-amount', null, true);
              description = getFormValue('transaction-description');
              if (accountId) {
                _context7.n = 2;
                break;
              }
              if (!(!Array.isArray(this.accounts) || this.accounts.length === 0)) {
                _context7.n = 1;
                break;
              }
              OC.Notification.showTemporary('No accounts available. Please create an account first.');
              return _context7.a(2);
            case 1:
              OC.Notification.showTemporary('Please select an account');
              return _context7.a(2);
            case 2:
              if (date) {
                _context7.n = 3;
                break;
              }
              OC.Notification.showTemporary('Please enter a date');
              return _context7.a(2);
            case 3:
              if (type) {
                _context7.n = 4;
                break;
              }
              OC.Notification.showTemporary('Please select a transaction type');
              return _context7.a(2);
            case 4:
              if (!(amount === null || amount <= 0)) {
                _context7.n = 5;
                break;
              }
              OC.Notification.showTemporary('Please enter a valid amount');
              return _context7.a(2);
            case 5:
              if (description) {
                _context7.n = 6;
                break;
              }
              OC.Notification.showTemporary('Please enter a description');
              return _context7.a(2);
            case 6:
              formData = {
                accountId: accountId,
                date: date,
                type: type,
                amount: amount,
                description: description,
                vendor: getFormValue('transaction-vendor'),
                categoryId: getFormValue('transaction-category', null, false, true),
                notes: getFormValue('transaction-notes')
              };
              transactionId = getFormValue('transaction-id');
              _context7.p = 7;
              url = transactionId ? "/apps/budget/api/transactions/".concat(transactionId) : '/apps/budget/api/transactions';
              method = transactionId ? 'PUT' : 'POST';
              _context7.n = 8;
              return fetch(OC.generateUrl(url), {
                method: method,
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(formData)
              });
            case 8:
              response = _context7.v;
              if (!response.ok) {
                _context7.n = 11;
                break;
              }
              _context7.n = 9;
              return response.json();
            case 9:
              result = _context7.v;
              savedTransactionId = result.id || transactionId; // Save tags if any are selected
              selectedTagIds = this.getSelectedTransactionTags();
              if (!(selectedTagIds.length > 0 && savedTransactionId)) {
                _context7.n = 10;
                break;
              }
              _context7.n = 10;
              return this.saveTransactionTags(savedTransactionId, selectedTagIds);
            case 10:
              OC.Notification.showTemporary('Transaction saved successfully');
              this.hideModals();
              this.loadTransactions();
              // Also reload account transactions if we're on account details view
              if (this.currentView === 'account-details' && this.currentAccount) {
                this.loadAccountTransactions(this.currentAccount.id);
              }
              _context7.n = 16;
              break;
            case 11:
              // Try to get the actual error message from backend
              errorMessage = 'Failed to save transaction';
              _context7.p = 12;
              _context7.n = 13;
              return response.json();
            case 13:
              errorData = _context7.v;
              if (errorData.error) {
                errorMessage = errorData.error;
              }
              _context7.n = 15;
              break;
            case 14:
              _context7.p = 14;
              _t7 = _context7.v;
            case 15:
              throw new Error(errorMessage);
            case 16:
              _context7.n = 18;
              break;
            case 17:
              _context7.p = 17;
              _t8 = _context7.v;
              console.error('Failed to save transaction:', _t8);
              OC.Notification.showTemporary(_t8.message || 'Failed to save transaction');
            case 18:
              return _context7.a(2);
          }
        }, _callee7, this, [[12, 14], [7, 17]]);
      }));
      function saveTransaction() {
        return _saveTransaction.apply(this, arguments);
      }
      return saveTransaction;
    }() // Phase 4: Quick Add Transaction methods
  }, {
    key: "saveQuickAddTransaction",
    value: function () {
      var _saveQuickAddTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var getFormValue, accountId, date, type, amount, description, messageEl, formData, response, errorMessage, errorData, _t9, _t0;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              // Helper function to safely get and clean form values
              getFormValue = function getFormValue(id) {
                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var isNumeric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var isInteger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var element = document.getElementById(id);
                if (!element) return defaultValue;
                var value = element.value ? String(element.value).trim() : '';
                if (value === '') return defaultValue;
                if (isInteger) {
                  var intValue = parseInt(value);
                  return isNaN(intValue) ? defaultValue : intValue;
                }
                if (isNumeric) {
                  var numValue = parseFloat(value);
                  return isNaN(numValue) ? defaultValue : numValue;
                }
                return value;
              }; // Validate required fields
              accountId = getFormValue('quick-add-account', null, false, true);
              date = getFormValue('quick-add-date');
              type = getFormValue('quick-add-type');
              amount = getFormValue('quick-add-amount', null, true);
              description = getFormValue('quick-add-description');
              messageEl = document.getElementById('quick-add-message');
              if (accountId) {
                _context8.n = 2;
                break;
              }
              if (!(!Array.isArray(this.accounts) || this.accounts.length === 0)) {
                _context8.n = 1;
                break;
              }
              this.showQuickAddMessage('No accounts available. Please create an account first.', 'error');
              return _context8.a(2);
            case 1:
              this.showQuickAddMessage('Please select an account', 'error');
              return _context8.a(2);
            case 2:
              if (date) {
                _context8.n = 3;
                break;
              }
              this.showQuickAddMessage('Please enter a date', 'error');
              return _context8.a(2);
            case 3:
              if (type) {
                _context8.n = 4;
                break;
              }
              this.showQuickAddMessage('Please select a transaction type', 'error');
              return _context8.a(2);
            case 4:
              if (!(amount === null || amount <= 0)) {
                _context8.n = 5;
                break;
              }
              this.showQuickAddMessage('Please enter a valid amount', 'error');
              return _context8.a(2);
            case 5:
              if (description) {
                _context8.n = 6;
                break;
              }
              this.showQuickAddMessage('Please enter a description', 'error');
              return _context8.a(2);
            case 6:
              formData = {
                accountId: accountId,
                date: date,
                type: type,
                amount: amount,
                description: description,
                vendor: null,
                categoryId: getFormValue('quick-add-category', null, false, true),
                notes: null
              };
              _context8.p = 7;
              _context8.n = 8;
              return fetch(OC.generateUrl('/apps/budget/api/transactions'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(formData)
              });
            case 8:
              response = _context8.v;
              if (!response.ok) {
                _context8.n = 9;
                break;
              }
              this.showQuickAddMessage('Transaction added successfully!', 'success');
              this.resetQuickAddForm();
              // Reload transactions if on transactions view
              if (this.currentView === 'transactions') {
                this.loadTransactions();
              }
              // Reload dashboard to update totals
              if (this.currentView === 'dashboard') {
                this.loadDashboard();
              }
              _context8.n = 14;
              break;
            case 9:
              errorMessage = 'Failed to add transaction';
              _context8.p = 10;
              _context8.n = 11;
              return response.json();
            case 11:
              errorData = _context8.v;
              if (errorData.error) {
                errorMessage = errorData.error;
              }
              _context8.n = 13;
              break;
            case 12:
              _context8.p = 12;
              _t9 = _context8.v;
            case 13:
              throw new Error(errorMessage);
            case 14:
              _context8.n = 16;
              break;
            case 15:
              _context8.p = 15;
              _t0 = _context8.v;
              console.error('Failed to save quick add transaction:', _t0);
              this.showQuickAddMessage(_t0.message || 'Failed to add transaction', 'error');
            case 16:
              return _context8.a(2);
          }
        }, _callee8, this, [[10, 12], [7, 15]]);
      }));
      function saveQuickAddTransaction() {
        return _saveQuickAddTransaction.apply(this, arguments);
      }
      return saveQuickAddTransaction;
    }()
  }, {
    key: "resetQuickAddForm",
    value: function resetQuickAddForm() {
      var form = document.getElementById('quick-add-form');
      if (form) {
        form.reset();
        // Set today's date as default
        var dateInput = document.getElementById('quick-add-date');
        if (dateInput) {
          dateInput.value = new Date().toISOString().split('T')[0];
        }
      }
      // Hide message
      var messageEl = document.getElementById('quick-add-message');
      if (messageEl) {
        messageEl.style.display = 'none';
      }
    }
  }, {
    key: "showQuickAddMessage",
    value: function showQuickAddMessage(message) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
      var messageEl = document.getElementById('quick-add-message');
      if (!messageEl) return;
      messageEl.textContent = message;
      messageEl.className = "quick-add-message ".concat(type);
      messageEl.style.display = 'block';

      // Auto-hide success messages after 3 seconds
      if (type === 'success') {
        setTimeout(function () {
          messageEl.style.display = 'none';
        }, 3000);
      }
    }
  }, {
    key: "initQuickAddForm",
    value: function initQuickAddForm() {
      // Populate account dropdown
      var accountSelect = document.getElementById('quick-add-account');
      if (accountSelect && this.accounts) {
        accountSelect.innerHTML = '<option value="">Select account</option>';
        this.accounts.forEach(function (account) {
          var option = document.createElement('option');
          option.value = account.id;
          option.textContent = account.name;
          accountSelect.appendChild(option);
        });
      }

      // Populate category dropdown
      var categorySelect = document.getElementById('quick-add-category');
      if (categorySelect && this.categories) {
        categorySelect.innerHTML = '<option value="">No category</option>';
        this.categories.forEach(function (category) {
          var option = document.createElement('option');
          option.value = category.id;
          option.textContent = category.name;
          categorySelect.appendChild(option);
        });
      }

      // Set today's date as default
      var dateInput = document.getElementById('quick-add-date');
      if (dateInput && !dateInput.value) {
        dateInput.value = new Date().toISOString().split('T')[0];
      }
    }
  }, {
    key: "saveAccount",
    value: function () {
      var _saveAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
        var nameElement, typeElement, getFormValue, accountId, isEdit, formData, sensitiveFields, sensitiveFieldIds, url, method, response, result, contentType, text, detailsView, updatedAccount, errorMessage, _contentType, _text, errorData, errorMsg, _t1, _t10;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              // Get form elements
              nameElement = document.getElementById('account-name');
              typeElement = document.getElementById('account-type');
              if (nameElement) {
                _context9.n = 1;
                break;
              }
              console.error('Account name element not found');
              OC.Notification.showTemporary('Form error: Account name field not found');
              return _context9.a(2);
            case 1:
              if (typeElement) {
                _context9.n = 2;
                break;
              }
              console.error('Account type element not found');
              OC.Notification.showTemporary('Form error: Account type field not found');
              return _context9.a(2);
            case 2:
              // Helper function to safely get and clean form values
              getFormValue = function getFormValue(id) {
                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var isNumeric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var element = document.getElementById(id);
                if (!element) return defaultValue;
                var value = element.value ? String(element.value).trim() : '';
                if (value === '') return defaultValue;
                if (isNumeric) {
                  var numValue = parseFloat(value);
                  return isNaN(numValue) ? defaultValue : numValue;
                }
                return value;
              };
              accountId = getFormValue('account-id');
              isEdit = !!accountId;
              formData = {
                name: getFormValue('account-name', ''),
                type: getFormValue('account-type', ''),
                balance: getFormValue('account-balance', 0, true),
                currency: getFormValue('account-currency', 'USD'),
                institution: getFormValue('account-institution'),
                accountHolderName: getFormValue('account-holder-name'),
                openingDate: getFormValue('account-opening-date'),
                interestRate: getFormValue('account-interest-rate', null, true),
                creditLimit: getFormValue('account-credit-limit', null, true),
                overdraftLimit: getFormValue('account-overdraft-limit', null, true)
              }; // Sensitive fields: only include if user entered a value
              // For edits, empty means "keep existing" - don't send to avoid overwriting
              sensitiveFields = ['accountNumber', 'routingNumber', 'sortCode', 'iban', 'swiftBic'];
              sensitiveFieldIds = {
                accountNumber: 'form-account-number',
                routingNumber: 'form-routing-number',
                sortCode: 'form-sort-code',
                iban: 'form-iban',
                swiftBic: 'form-swift-bic'
              };
              sensitiveFields.forEach(function (field) {
                var value = getFormValue(sensitiveFieldIds[field]);
                // For new accounts: include all fields (null for empty)
                // For edits: only include if user entered a value
                if (!isEdit || value !== null) {
                  formData[field] = value;
                }
              });

              // Validate required fields on frontend
              if (!(!formData.name || formData.name === '')) {
                _context9.n = 3;
                break;
              }
              console.error('Account name is empty');
              OC.Notification.showTemporary('Please enter an account name');
              nameElement.focus();
              return _context9.a(2);
            case 3:
              if (!(!formData.type || formData.type === '')) {
                _context9.n = 4;
                break;
              }
              console.error('Account type is empty');
              OC.Notification.showTemporary('Please select an account type');
              typeElement.focus();
              return _context9.a(2);
            case 4:
              if (!(formData.name.length > 255)) {
                _context9.n = 5;
                break;
              }
              OC.Notification.showTemporary('Account name is too long (maximum 255 characters)');
              nameElement.focus();
              return _context9.a(2);
            case 5:
              if (!isNaN(formData.balance)) {
                _context9.n = 6;
                break;
              }
              OC.Notification.showTemporary('Please enter a valid balance amount');
              document.getElementById('account-balance').focus();
              return _context9.a(2);
            case 6:
              // Make API request (accountId already defined above for isEdit check)
              url = accountId ? "/apps/budget/api/accounts/".concat(accountId) : '/apps/budget/api/accounts';
              method = accountId ? 'PUT' : 'POST';
              _context9.n = 7;
              return fetch(OC.generateUrl(url), {
                method: method,
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(formData)
              });
            case 7:
              response = _context9.v;
              if (!response.ok) {
                _context9.n = 12;
                break;
              }
              // Try to parse response as JSON, but handle empty responses
              result = {};
              contentType = response.headers.get('content-type');
              if (!(contentType && contentType.includes('application/json'))) {
                _context9.n = 9;
                break;
              }
              _context9.n = 8;
              return response.text();
            case 8:
              text = _context9.v;
              if (text.trim()) {
                result = JSON.parse(text);
              }
            case 9:
              OC.Notification.showTemporary('Account saved successfully');
              this.hideModals();
              _context9.n = 10;
              return this.loadAccounts();
            case 10:
              _context9.n = 11;
              return this.loadInitialData();
            case 11:
              // Refresh dropdowns
              // Refresh account details view if it's currently visible
              detailsView = document.getElementById('account-details-view');
              if (detailsView && detailsView.style.display !== 'none' && accountId) {
                updatedAccount = this.accounts.find(function (a) {
                  return a.id === parseInt(accountId);
                });
                if (updatedAccount) {
                  this.currentAccount = updatedAccount;
                  this.populateAccountOverview(updatedAccount);
                }
              }
              _context9.n = 19;
              break;
            case 12:
              // Handle error responses more safely
              errorMessage = 'Failed to save account';
              _context9.p = 13;
              _contentType = response.headers.get('content-type');
              if (!(_contentType && _contentType.includes('application/json'))) {
                _context9.n = 15;
                break;
              }
              _context9.n = 14;
              return response.text();
            case 14:
              _text = _context9.v;
              if (_text.trim()) {
                errorData = JSON.parse(_text);
                errorMessage = errorData.error || errorMessage;
              }
              _context9.n = 16;
              break;
            case 15:
              // Non-JSON response, get status text
              errorMessage = "HTTP ".concat(response.status, ": ").concat(response.statusText);
            case 16:
              _context9.n = 18;
              break;
            case 17:
              _context9.p = 17;
              _t1 = _context9.v;
              console.error('Error parsing response:', _t1);
              errorMessage = "HTTP ".concat(response.status, ": ").concat(response.statusText);
            case 18:
              throw new Error(errorMessage);
            case 19:
              _context9.n = 21;
              break;
            case 20:
              _context9.p = 20;
              _t10 = _context9.v;
              console.error('Failed to save account:', _t10);

              // Show specific error message if available
              errorMsg = _t10.message || 'Unknown error occurred';
              OC.Notification.showTemporary("Failed to save account: ".concat(errorMsg));

              // Don't hide modal on error so user can fix and retry
            case 21:
              return _context9.a(2);
          }
        }, _callee9, this, [[13, 17], [0, 20]]);
      }));
      function saveAccount() {
        return _saveAccount.apply(this, arguments);
      }
      return saveAccount;
    }()
  }, {
    key: "showAccountModal",
    value: function showAccountModal() {
      var _this7 = this;
      var accountId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('account-modal');
      var title = document.getElementById('account-modal-title');
      if (!modal || !title) {
        console.error('Account modal or title not found');
        return;
      }
      if (accountId) {
        title.textContent = 'Edit Account';
        this.loadAccountData(accountId);
      } else {
        title.textContent = 'Add Account';
        this.resetAccountForm();
      }

      // Setup conditional fields and validation
      setTimeout(function () {
        _this7.setupAccountTypeConditionals();
        _this7.setupBankingFieldValidation();
      }, 100);
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');

      // Focus on the name field
      var nameField = document.getElementById('account-name');
      if (nameField) {
        nameField.focus();
      }
    }
  }, {
    key: "loadAccountData",
    value: function () {
      var _loadAccountData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(accountId) {
        var response, account, sensitiveFields, _t11;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              _context0.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/accounts/".concat(accountId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context0.v;
              _context0.n = 2;
              return response.json();
            case 2:
              account = _context0.v;
              document.getElementById('account-id').value = account.id;
              document.getElementById('account-name').value = account.name;
              document.getElementById('account-type').value = account.type;
              document.getElementById('account-balance').value = account.balance;
              document.getElementById('account-currency').value = account.currency;
              document.getElementById('account-institution').value = account.institution || '';

              // Sensitive fields: don't populate with masked values, use placeholder instead
              // This prevents the masked value from being saved back and corrupting the data
              sensitiveFields = [{
                id: 'form-account-number',
                hasValue: !!account.accountNumber
              }, {
                id: 'form-routing-number',
                hasValue: !!account.routingNumber
              }, {
                id: 'form-sort-code',
                hasValue: !!account.sortCode
              }, {
                id: 'form-iban',
                hasValue: !!account.iban
              }, {
                id: 'form-swift-bic',
                hasValue: !!account.swiftBic
              }];
              sensitiveFields.forEach(function (field) {
                var element = document.getElementById(field.id);
                if (element) {
                  element.value = ''; // Don't populate with masked value
                  if (field.hasValue) {
                    element.placeholder = '  (leave blank to keep current)';
                  } else {
                    element.placeholder = '';
                  }
                }
              });
              document.getElementById('account-holder-name').value = account.accountHolderName || '';
              document.getElementById('account-opening-date').value = account.openingDate || '';
              document.getElementById('account-interest-rate').value = account.interestRate || '';
              document.getElementById('account-credit-limit').value = account.creditLimit || '';
              document.getElementById('account-overdraft-limit').value = account.overdraftLimit || '';
              _context0.n = 4;
              break;
            case 3:
              _context0.p = 3;
              _t11 = _context0.v;
              console.error('Failed to load account data:', _t11);
              OC.Notification.showTemporary('Failed to load account data');
            case 4:
              return _context0.a(2);
          }
        }, _callee0, null, [[0, 3]]);
      }));
      function loadAccountData(_x5) {
        return _loadAccountData.apply(this, arguments);
      }
      return loadAccountData;
    }()
  }, {
    key: "resetAccountForm",
    value: function resetAccountForm() {
      var _this$settings;
      var form = document.getElementById('account-form');
      if (!form) {
        console.error('Account form not found');
        return;
      }
      form.reset();
      var accountId = document.getElementById('account-id');
      var currency = document.getElementById('account-currency');
      var balance = document.getElementById('account-balance');
      if (accountId) accountId.value = '';
      if (currency) currency.value = ((_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : _this$settings.default_currency) || 'GBP';
      if (balance) balance.value = '0';
    }
  }, {
    key: "editAccount",
    value: function () {
      var _editAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(id) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.showAccountModal(id);
            case 1:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function editAccount(_x6) {
        return _editAccount.apply(this, arguments);
      }
      return editAccount;
    }()
  }, {
    key: "deleteAccount",
    value: function () {
      var _deleteAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(id) {
        var response, error, _t12;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              if (confirm('Are you sure you want to delete this account? This action cannot be undone.')) {
                _context10.n = 1;
                break;
              }
              return _context10.a(2);
            case 1:
              _context10.p = 1;
              _context10.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/accounts/".concat(id)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context10.v;
              if (!response.ok) {
                _context10.n = 3;
                break;
              }
              OC.Notification.showTemporary('Account deleted successfully');
              this.loadAccounts();
              this.loadInitialData(); // Refresh dropdowns
              _context10.n = 5;
              break;
            case 3:
              _context10.n = 4;
              return response.json();
            case 4:
              error = _context10.v;
              throw new Error(error.error || 'Failed to delete account');
            case 5:
              _context10.n = 7;
              break;
            case 6:
              _context10.p = 6;
              _t12 = _context10.v;
              console.error('Failed to delete account:', _t12);
              OC.Notification.showTemporary('Failed to delete account: ' + _t12.message);
            case 7:
              return _context10.a(2);
          }
        }, _callee10, this, [[1, 6]]);
      }));
      function deleteAccount(_x7) {
        return _deleteAccount.apply(this, arguments);
      }
      return deleteAccount;
    }()
  }, {
    key: "setupAccountTypeConditionals",
    value: function () {
      var _setupAccountTypeConditionals = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var accountType, currency, requirements, response, _t13, _t14;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              accountType = document.getElementById('account-type').value;
              currency = document.getElementById('account-currency').value || 'USD'; // Hide all conditional groups first
              document.querySelectorAll('.form-group.conditional').forEach(function (group) {
                group.style.display = 'none';
              });

              // Get banking field requirements for the selected currency
              requirements = {};
              _context11.p = 1;
              _context11.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/accounts/banking-requirements/".concat(currency)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context11.v;
              _context11.n = 3;
              return response.json();
            case 3:
              requirements = _context11.v;
              _context11.n = 5;
              break;
            case 4:
              _context11.p = 4;
              _t13 = _context11.v;
              console.warn('Failed to load banking requirements:', _t13);
            case 5:
              _t14 = accountType;
              _context11.n = _t14 === 'checking' ? 6 : _t14 === 'savings' ? 6 : _t14 === 'credit_card' ? 7 : _t14 === 'loan' ? 8 : _t14 === 'investment' ? 9 : _t14 === 'cash' ? 10 : 11;
              break;
            case 6:
              // Show banking fields based on currency
              if (requirements.routing_number) {
                document.getElementById('routing-number-group').style.display = 'block';
              }
              if (requirements.sort_code) {
                document.getElementById('sort-code-group').style.display = 'block';
              }
              if (requirements.iban) {
                document.getElementById('iban-group').style.display = 'block';
              }
              document.getElementById('swift-bic-group').style.display = 'block';
              document.getElementById('overdraft-limit-group').style.display = 'block';
              if (accountType === 'savings') {
                document.getElementById('interest-rate-group').style.display = 'block';
              }
              return _context11.a(3, 11);
            case 7:
              // Show credit card specific fields
              document.getElementById('credit-limit-group').style.display = 'block';
              document.getElementById('interest-rate-group').style.display = 'block';
              return _context11.a(3, 11);
            case 8:
              // Show loan specific fields
              document.getElementById('interest-rate-group').style.display = 'block';
              return _context11.a(3, 11);
            case 9:
              // Show investment account fields
              document.getElementById('swift-bic-group').style.display = 'block';
              if (requirements.iban) {
                document.getElementById('iban-group').style.display = 'block';
              }
              return _context11.a(3, 11);
            case 10:
              return _context11.a(3, 11);
            case 11:
              return _context11.a(2);
          }
        }, _callee11, null, [[1, 4]]);
      }));
      function setupAccountTypeConditionals() {
        return _setupAccountTypeConditionals.apply(this, arguments);
      }
      return setupAccountTypeConditionals;
    }()
  }, {
    key: "setupInstitutionAutocomplete",
    value: function () {
      var _setupInstitutionAutocomplete = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
        var input, suggestions, query, response, currency, currencyMap, region, banks, filteredBanks, _t15;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.p = _context12.n) {
            case 0:
              input = document.getElementById('account-institution');
              suggestions = document.getElementById('institution-suggestions');
              query = input.value.toLowerCase();
              if (!(query.length < 2)) {
                _context12.n = 1;
                break;
              }
              suggestions.style.display = 'none';
              return _context12.a(2);
            case 1:
              _context12.p = 1;
              if (this.bankingInstitutions) {
                _context12.n = 4;
                break;
              }
              _context12.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/accounts/banking-institutions'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context12.v;
              _context12.n = 3;
              return response.json();
            case 3:
              this.bankingInstitutions = _context12.v;
            case 4:
              // Get currency to show relevant banks
              currency = document.getElementById('account-currency').value || 'USD';
              currencyMap = {
                'USD': 'US',
                'GBP': 'UK',
                'EUR': 'EU',
                'CAD': 'CA'
              };
              region = currencyMap[currency] || 'US';
              banks = this.bankingInstitutions[region] || this.bankingInstitutions['US'];
              filteredBanks = banks.filter(function (bank) {
                return bank.toLowerCase().includes(query);
              }).slice(0, 8);
              if (filteredBanks.length > 0) {
                suggestions.innerHTML = filteredBanks.map(function (bank) {
                  return "<div class=\"autocomplete-item\" data-bank-name=\"".concat(bank, "\">").concat(bank, "</div>");
                }).join('');
                suggestions.style.display = 'block';
              } else {
                suggestions.style.display = 'none';
              }
              _context12.n = 6;
              break;
            case 5:
              _context12.p = 5;
              _t15 = _context12.v;
              console.warn('Failed to load banking institutions:', _t15);
              suggestions.style.display = 'none';
            case 6:
              return _context12.a(2);
          }
        }, _callee12, this, [[1, 5]]);
      }));
      function setupInstitutionAutocomplete() {
        return _setupInstitutionAutocomplete.apply(this, arguments);
      }
      return setupInstitutionAutocomplete;
    }()
  }, {
    key: "selectInstitution",
    value: function selectInstitution(bankName) {
      document.getElementById('account-institution').value = bankName;
      document.getElementById('institution-suggestions').style.display = 'none';
    }

    // Real-time validation methods
  }, {
    key: "validateBankingField",
    value: function () {
      var _validateBankingField = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(fieldType, value, fieldId) {
        var response, result, _t16;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.p = _context13.n) {
            case 0:
              if (!(!value || value.length < 3)) {
                _context13.n = 1;
                break;
              }
              this.clearValidationFeedback(fieldId);
              return _context13.a(2);
            case 1:
              _context13.p = 1;
              _context13.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/accounts/validate/".concat(fieldType)), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(_defineProperty({}, fieldType.replace('-', ''), value))
              });
            case 2:
              response = _context13.v;
              _context13.n = 3;
              return response.json();
            case 3:
              result = _context13.v;
              this.showValidationFeedback(fieldId, result);

              // Auto-format if validation succeeded
              if (result.valid && result.formatted && result.formatted !== value) {
                document.getElementById(fieldId).value = result.formatted;
              }
              _context13.n = 5;
              break;
            case 4:
              _context13.p = 4;
              _t16 = _context13.v;
              console.warn("Failed to validate ".concat(fieldType, ":"), _t16);
            case 5:
              return _context13.a(2);
          }
        }, _callee13, this, [[1, 4]]);
      }));
      function validateBankingField(_x8, _x9, _x0) {
        return _validateBankingField.apply(this, arguments);
      }
      return validateBankingField;
    }()
  }, {
    key: "showValidationFeedback",
    value: function showValidationFeedback(fieldId, result) {
      var field = document.getElementById(fieldId);
      var formGroup = field.closest('.form-group');

      // Remove existing feedback
      this.clearValidationFeedback(fieldId);

      // Add validation state
      field.classList.remove('error', 'success');
      field.classList.add(result.valid ? 'success' : 'error');

      // Add feedback message
      if (!result.valid && result.error) {
        var feedback = document.createElement('div');
        feedback.className = 'field-feedback error';
        feedback.textContent = result.error;
        feedback.id = "".concat(fieldId, "-feedback");
        formGroup.appendChild(feedback);
      } else if (result.valid) {
        var _feedback = document.createElement('div');
        _feedback.className = 'field-feedback success';
        _feedback.innerHTML = '<span class="icon-checkmark"></span> Valid';
        _feedback.id = "".concat(fieldId, "-feedback");
        formGroup.appendChild(_feedback);
      }
    }
  }, {
    key: "clearValidationFeedback",
    value: function clearValidationFeedback(fieldId) {
      var field = document.getElementById(fieldId);
      var formGroup = field.closest('.form-group');
      field.classList.remove('error', 'success');
      var existingFeedback = document.getElementById("".concat(fieldId, "-feedback"));
      if (existingFeedback) {
        existingFeedback.remove();
      }
    }
  }, {
    key: "setupBankingFieldValidation",
    value: function setupBankingFieldValidation() {
      var _this8 = this;
      // IBAN validation
      var ibanField = document.getElementById('form-iban');
      if (ibanField) {
        ibanField.addEventListener('blur', function () {
          _this8.validateBankingField('iban', ibanField.value, 'form-iban');
        });
      }

      // Routing number validation
      var routingField = document.getElementById('form-routing-number');
      if (routingField) {
        routingField.addEventListener('blur', function () {
          _this8.validateBankingField('routing-number', routingField.value, 'form-routing-number');
        });
      }

      // Sort code validation
      var sortCodeField = document.getElementById('form-sort-code');
      if (sortCodeField) {
        sortCodeField.addEventListener('blur', function () {
          _this8.validateBankingField('sort-code', sortCodeField.value, 'form-sort-code');
        });
      }

      // SWIFT/BIC validation
      var swiftField = document.getElementById('form-swift-bic');
      if (swiftField) {
        swiftField.addEventListener('blur', function () {
          _this8.validateBankingField('swift-bic', swiftField.value, 'form-swift-bic');
        });
      }

      // Currency change handler
      var currencyField = document.getElementById('account-currency');
      if (currencyField) {
        currencyField.addEventListener('change', function () {
          _this8.setupAccountTypeConditionals();
        });
      }
    }

    // Helper methods for account display
  }, {
    key: "getAccountTypeInfo",
    value: function getAccountTypeInfo(accountType) {
      var typeMap = {
        'checking': {
          icon: 'icon-checkmark',
          color: '#4A90E2',
          label: 'Checking Account'
        },
        'savings': {
          icon: 'icon-folder',
          color: '#50E3C2',
          label: 'Savings Account'
        },
        'credit_card': {
          icon: 'icon-category-integration',
          color: '#F5A623',
          label: 'Credit Card'
        },
        'investment': {
          icon: 'icon-trending',
          color: '#7ED321',
          label: 'Investment'
        },
        'loan': {
          icon: 'icon-file',
          color: '#D0021B',
          label: 'Loan'
        },
        'cash': {
          icon: 'icon-category-monitoring',
          color: '#9013FE',
          label: 'Cash'
        }
      };
      return typeMap[accountType] || {
        icon: 'icon-folder',
        color: '#999999',
        label: 'Unknown'
      };
    }
  }, {
    key: "getAccountHealthStatus",
    value: function getAccountHealthStatus(account) {
      var balance = account.balance || 0;
      var type = account.type;

      // For credit cards, check credit utilization
      if (type === 'credit_card' && account.creditLimit) {
        var utilization = Math.abs(balance) / account.creditLimit;
        if (utilization > 0.9) {
          return {
            "class": 'critical',
            icon: 'icon-error',
            tooltip: 'Credit utilization very high'
          };
        } else if (utilization > 0.7) {
          return {
            "class": 'warning',
            icon: 'icon-triangle-s',
            tooltip: 'Credit utilization high'
          };
        }
      }

      // For regular accounts, check for negative balances
      if (balance < 0 && type !== 'credit_card' && type !== 'loan') {
        return {
          "class": 'warning',
          icon: 'icon-triangle-s',
          tooltip: 'Negative balance'
        };
      }

      // Check overdraft limits
      if (account.overdraftLimit && balance < -account.overdraftLimit) {
        return {
          "class": 'critical',
          icon: 'icon-error',
          tooltip: 'Exceeds overdraft limit'
        };
      }
      return {
        "class": 'healthy',
        icon: 'icon-checkmark',
        tooltip: 'Account is in good standing'
      };
    }
  }, {
    key: "viewAccountTransactions",
    value: function viewAccountTransactions(accountId) {
      // Switch to transactions view and filter by account
      this.showView('transactions');

      // Set the account filter
      var accountFilter = document.getElementById('filter-account');
      if (accountFilter) {
        accountFilter.value = accountId.toString();
      }

      // Load transactions for this account
      this.loadTransactions();
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/auth/AuthModule.js":
/*!****************************************!*\
  !*** ./src/modules/auth/AuthModule.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AuthModule)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Auth Module - Authentication and session management
 */
var AuthModule = /*#__PURE__*/function () {
  function AuthModule(app) {
    _classCallCheck(this, AuthModule);
    this.app = app;

    // Auth state
    this.sessionToken = localStorage.getItem('budget_session_token');
    this.lastActivityTime = Date.now();
    this.inactivityTimer = null;
  }

  // ============================================
  // State Proxies
  // ============================================
  return _createClass(AuthModule, [{
    key: "settings",
    get: function get() {
      return this.app.settings;
    }

    // ============================================
    // Helper Method Proxies
    // ============================================
  }, {
    key: "setupNavigation",
    value: function setupNavigation() {
      return this.app.router.setupNavigation();
    }
  }, {
    key: "setupEventListeners",
    value: function setupEventListeners() {
      return this.app.setupEventListeners();
    }
  }, {
    key: "loadInitialData",
    value: function () {
      var _loadInitialData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              return _context.a(2, this.app.loadInitialData());
          }
        }, _callee, this);
      }));
      function loadInitialData() {
        return _loadInitialData.apply(this, arguments);
      }
      return loadInitialData;
    }()
  }, {
    key: "showView",
    value: function showView(viewName) {
      return this.app.router.showView(viewName);
    }

    // ============================================
    // Auth Methods
    // ============================================
  }, {
    key: "setupLockButton",
    value: function () {
      var _setupLockButton = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var _this = this;
        var lockBtn, response, status, lockLink, _t;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              lockBtn = document.getElementById('lock-app-btn');
              if (lockBtn) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2);
            case 1:
              _context3.p = 1;
              _context3.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/auth/status'), {
                headers: this.getAuthHeaders()
              });
            case 2:
              response = _context3.v;
              if (!response.ok) {
                _context3.n = 4;
                break;
              }
              _context3.n = 3;
              return response.json();
            case 3:
              status = _context3.v;
              if (status.enabled && status.authenticated) {
                lockBtn.style.display = 'block';
              }
            case 4:
              _context3.n = 6;
              break;
            case 5:
              _context3.p = 5;
              _t = _context3.v;
              console.error('Failed to check lock button status:', _t);
            case 6:
              // Add click handler
              lockLink = lockBtn.querySelector('a');
              if (lockLink) {
                lockLink.addEventListener('click', /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(e) {
                    return _regenerator().w(function (_context2) {
                      while (1) switch (_context2.n) {
                        case 0:
                          e.preventDefault();
                          _context2.n = 1;
                          return _this.lockApp();
                        case 1:
                          return _context2.a(2);
                      }
                    }, _callee2);
                  }));
                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }());
              }
            case 7:
              return _context3.a(2);
          }
        }, _callee3, this, [[1, 5]]);
      }));
      function setupLockButton() {
        return _setupLockButton.apply(this, arguments);
      }
      return setupLockButton;
    }()
  }, {
    key: "checkAuth",
    value: function () {
      var _checkAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var response, status, _t2;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              _context4.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/auth/status'), {
                headers: this.getAuthHeaders()
              });
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              return _context4.a(2, false);
            case 2:
              _context4.n = 3;
              return response.json();
            case 3:
              status = _context4.v;
              if (status.enabled) {
                _context4.n = 4;
                break;
              }
              return _context4.a(2, false);
            case 4:
              if (!status.authenticated) {
                _context4.n = 5;
                break;
              }
              return _context4.a(2, false);
            case 5:
              return _context4.a(2, true);
            case 6:
              _context4.p = 6;
              _t2 = _context4.v;
              console.error('Auth check failed:', _t2);
              return _context4.a(2, false);
          }
        }, _callee4, this, [[0, 6]]);
      }));
      function checkAuth() {
        return _checkAuth.apply(this, arguments);
      }
      return checkAuth;
    }()
  }, {
    key: "getAuthHeaders",
    value: function getAuthHeaders() {
      var headers = {
        'requesttoken': OC.requestToken
      };
      if (this.sessionToken) {
        headers['X-Budget-Session-Token'] = this.sessionToken;
      }
      return headers;
    }
  }, {
    key: "showPasswordModal",
    value: function showPasswordModal() {
      var _this2 = this;
      var modal = document.createElement('div');
      modal.id = 'budget-auth-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Password Required</h2>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <p>This budget app is password protected. Please enter your password to continue.</p>\n                    <form id=\"budget-auth-form\">\n                        <div class=\"form-group\">\n                            <label for=\"budget-auth-password\">Password</label>\n                            <input type=\"password\" id=\"budget-auth-password\" class=\"budget-input\" required autocomplete=\"current-password\">\n                        </div>\n                        <div id=\"budget-auth-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"submit\" class=\"budget-btn primary\">Unlock</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('budget-auth-form');
      var passwordInput = document.getElementById('budget-auth-password');
      var errorDiv = document.getElementById('budget-auth-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(e) {
          var password, response, result, _t3;
          return _regenerator().w(function (_context5) {
            while (1) switch (_context5.p = _context5.n) {
              case 0:
                e.preventDefault();
                password = passwordInput.value;
                _context5.p = 1;
                _context5.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/verify'), {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'requesttoken': OC.requestToken
                  },
                  body: JSON.stringify({
                    password: password
                  })
                });
              case 2:
                response = _context5.v;
                _context5.n = 3;
                return response.json();
              case 3:
                result = _context5.v;
                if (!result.success) {
                  _context5.n = 6;
                  break;
                }
                // Store session token
                _this2.sessionToken = result.sessionToken;
                _this2.app.sessionToken = result.sessionToken; // Keep app in sync
                localStorage.setItem('budget_session_token', result.sessionToken);

                // Remove modal
                modal.remove();

                // Initialize app
                _this2.setupNavigation();
                _this2.setupEventListeners();
                _this2.setupActivityMonitoring();
                _context5.n = 4;
                return _this2.loadInitialData();
              case 4:
                _context5.n = 5;
                return _this2.setupLockButton();
              case 5:
                _this2.showView('dashboard');
                _context5.n = 7;
                break;
              case 6:
                // Show error
                errorDiv.textContent = result.error || 'Incorrect password';
                errorDiv.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
              case 7:
                _context5.n = 9;
                break;
              case 8:
                _context5.p = 8;
                _t3 = _context5.v;
                console.error('Password verification failed:', _t3);
                errorDiv.textContent = 'Failed to verify password. Please try again.';
                errorDiv.style.display = 'block';
              case 9:
                return _context5.a(2);
            }
          }, _callee5, null, [[1, 8]]);
        }));
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());

      // Focus password input
      setTimeout(function () {
        return passwordInput.focus();
      }, 100);
    }
  }, {
    key: "setupActivityMonitoring",
    value: function setupActivityMonitoring() {
      var _this3 = this;
      // Reset activity timer on user interaction
      var resetActivity = function resetActivity() {
        _this3.lastActivityTime = Date.now();
        _this3.app.lastActivityTime = Date.now(); // Keep app in sync
      };

      // Listen to various user interactions
      ['mousedown', 'keydown', 'scroll', 'touchstart'].forEach(function (event) {
        document.addEventListener(event, resetActivity, true);
      });

      // Check for inactivity every minute
      this.inactivityTimer = setInterval(function () {
        _this3.checkInactivity();
      }, 60000); // Check every minute

      // Keep app in sync
      this.app.inactivityTimer = this.inactivityTimer;
    }
  }, {
    key: "checkInactivity",
    value: function () {
      var _checkInactivity = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var timeoutMinutes, timeoutMs, inactiveTime;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              if (this.sessionToken) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              // Get session timeout from settings (default 30 minutes)
              timeoutMinutes = parseInt(this.settings.session_timeout_minutes || '30');
              timeoutMs = timeoutMinutes * 60 * 1000;
              inactiveTime = Date.now() - this.lastActivityTime;
              if (!(inactiveTime >= timeoutMs)) {
                _context6.n = 2;
                break;
              }
              _context6.n = 2;
              return this.lockApp();
            case 2:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function checkInactivity() {
        return _checkInactivity.apply(this, arguments);
      }
      return checkInactivity;
    }()
  }, {
    key: "lockApp",
    value: function () {
      var _lockApp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var _t4;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              _context7.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/auth/lock'), {
                method: 'POST',
                headers: this.getAuthHeaders()
              });
            case 1:
              _context7.n = 3;
              break;
            case 2:
              _context7.p = 2;
              _t4 = _context7.v;
              console.error('Failed to lock session:', _t4);
            case 3:
              // Clear session token
              this.sessionToken = null;
              this.app.sessionToken = null; // Keep app in sync
              localStorage.removeItem('budget_session_token');

              // Clear inactivity timer
              if (this.inactivityTimer) {
                clearInterval(this.inactivityTimer);
                this.inactivityTimer = null;
                this.app.inactivityTimer = null;
              }

              // Reload page to show password prompt
              window.location.reload();
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this, [[0, 2]]);
      }));
      function lockApp() {
        return _lockApp.apply(this, arguments);
      }
      return lockApp;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/bills/BillsModule.js":
/*!******************************************!*\
  !*** ./src/modules/bills/BillsModule.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BillsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Bills Module - Recurring bill tracking and detection
 */


var BillsModule = /*#__PURE__*/function () {
  function BillsModule(app) {
    _classCallCheck(this, BillsModule);
    this.app = app;
    this._eventsSetup = false;
    this._detectedBills = [];
    this._undoTimer = null;
    this._undoData = null;
  }

  // Getters for app state
  return _createClass(BillsModule, [{
    key: "bills",
    get: function get() {
      return this.app.bills;
    },
    set: function set(value) {
      this.app.bills = value;
    }
  }, {
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "loadBillsView",
    value: function () {
      var _loadBillsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return this.loadBillsSummary();
            case 1:
              _context.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/bills'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context.v;
              if (response.ok) {
                _context.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              _context.n = 4;
              return response.json();
            case 4:
              this.bills = _context.v;
              this.renderBills(this.bills);

              // Setup event listeners (only once)
              if (!this._eventsSetup) {
                this.setupBillsEventListeners();
                this._eventsSetup = true;
              }

              // Populate dropdowns in bill modal
              this.populateBillModalDropdowns();
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              console.error('Failed to load bills:', _t);
              OC.Notification.showTemporary('Failed to load bills');
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[0, 5]]);
      }));
      function loadBillsView() {
        return _loadBillsView.apply(this, arguments);
      }
      return loadBillsView;
    }()
  }, {
    key: "loadBillsSummary",
    value: function () {
      var _loadBillsSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response, summary, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/bills/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context2.n = 3;
              return response.json();
            case 3:
              summary = _context2.v;
              // Update summary cards
              document.getElementById('bills-due-count').textContent = summary.dueThisMonth || 0;
              document.getElementById('bills-overdue-count').textContent = summary.overdue || 0;
              document.getElementById('bills-monthly-total').textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(summary.monthlyTotal || 0, null, this.settings);
              document.getElementById('bills-paid-count').textContent = summary.paidThisMonth || 0;
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t2 = _context2.v;
              console.error('Failed to load bills summary:', _t2);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 4]]);
      }));
      function loadBillsSummary() {
        return _loadBillsSummary.apply(this, arguments);
      }
      return loadBillsSummary;
    }()
  }, {
    key: "renderBills",
    value: function renderBills(bills) {
      var _this = this;
      var billsList = document.getElementById('bills-list');
      var emptyBills = document.getElementById('empty-bills');
      if (!bills || bills.length === 0) {
        billsList.innerHTML = '';
        emptyBills.style.display = 'flex';
        return;
      }
      emptyBills.style.display = 'none';
      billsList.innerHTML = bills.map(function (bill) {
        var dueDate = bill.nextDueDate || bill.next_due_date;
        var isPaid = _this.isBillPaidThisMonth(bill);
        var isOverdue = !isPaid && dueDate && new Date(dueDate) < new Date();
        var isDueSoon = !isPaid && !isOverdue && dueDate && _this.isDueSoon(dueDate);
        var statusClass = '';
        var statusText = '';
        if (isPaid) {
          statusClass = 'paid';
          statusText = 'Paid';
        } else if (isOverdue) {
          statusClass = 'overdue';
          statusText = 'Overdue';
        } else if (isDueSoon) {
          statusClass = 'due-soon';
          statusText = 'Due Soon';
        } else {
          statusClass = 'upcoming';
          statusText = 'Upcoming';
        }
        var frequency = bill.frequency || 'monthly';
        var frequencyLabel = frequency.charAt(0).toUpperCase() + frequency.slice(1);
        return "\n                <div class=\"bill-card ".concat(statusClass, "\" data-bill-id=\"").concat(bill.id, "\" data-status=\"").concat(statusClass, "\">\n                    <div class=\"bill-header\">\n                        <div class=\"bill-info\">\n                            <h4 class=\"bill-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(bill.name), "</h4>\n                            <span class=\"bill-frequency\">").concat(frequencyLabel, "</span>\n                        </div>\n                        <div class=\"bill-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(bill.amount, null, _this.settings), "</div>\n                    </div>\n                    <div class=\"bill-details\">\n                        <div class=\"bill-due-date\">\n                            <span class=\"icon-calendar\" aria-hidden=\"true\"></span>\n                            ").concat(dueDate ? _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(dueDate, _this.settings) : 'No due date', "\n                        </div>\n                        <div class=\"bill-status ").concat(statusClass, "\">\n                            <span class=\"status-badge\">").concat(statusText, "</span>\n                        </div>\n                    </div>\n                    <div class=\"bill-actions\">\n                        ").concat(!isPaid ? "\n                            <button class=\"bill-action-btn bill-paid-btn\" data-bill-id=\"".concat(bill.id, "\" title=\"Mark as paid\">\n                                <span class=\"icon-checkmark\" aria-hidden=\"true\"></span>\n                                Mark Paid\n                            </button>\n                        ") : '', "\n                        <button class=\"bill-action-btn bill-edit-btn\" data-bill-id=\"").concat(bill.id, "\" title=\"Edit bill\">\n                            <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                        </button>\n                        <button class=\"bill-action-btn bill-delete-btn\" data-bill-id=\"").concat(bill.id, "\" title=\"Delete bill\">\n                            <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                        </button>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "isBillPaidThisMonth",
    value: function isBillPaidThisMonth(bill) {
      var lastPaid = bill.lastPaidDate || bill.last_paid_date;
      if (!lastPaid) return false;
      var paidDate = new Date(lastPaid);
      var now = new Date();
      return paidDate.getMonth() === now.getMonth() && paidDate.getFullYear() === now.getFullYear();
    }
  }, {
    key: "isDueSoon",
    value: function isDueSoon(dateStr) {
      var dueDate = new Date(dateStr);
      var now = new Date();
      var diffDays = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
      return diffDays >= 0 && diffDays <= 7;
    }
  }, {
    key: "filterBills",
    value: function filterBills(filter) {
      var billCards = document.querySelectorAll('.bill-card');
      billCards.forEach(function (card) {
        var status = card.dataset.status;
        var show = false;
        switch (filter) {
          case 'all':
            show = true;
            break;
          case 'due':
            show = status === 'due-soon' || status === 'upcoming';
            break;
          case 'overdue':
            show = status === 'overdue';
            break;
          case 'paid':
            show = status === 'paid';
            break;
          default:
            show = true;
        }
        card.style.display = show ? 'flex' : 'none';
      });
    }
  }, {
    key: "setupBillsEventListeners",
    value: function setupBillsEventListeners() {
      var _this2 = this;
      // Add bill button
      var addBillBtn = document.getElementById('add-bill-btn');
      if (addBillBtn) {
        addBillBtn.addEventListener('click', function () {
          return _this2.showBillModal();
        });
      }

      // Empty state add button
      var emptyBillsAddBtn = document.getElementById('empty-bills-add-btn');
      if (emptyBillsAddBtn) {
        emptyBillsAddBtn.addEventListener('click', function () {
          return _this2.showBillModal();
        });
      }

      // Detect bills button
      var detectBillsBtn = document.getElementById('detect-bills-btn');
      if (detectBillsBtn) {
        detectBillsBtn.addEventListener('click', function () {
          return _this2.detectBills();
        });
      }

      // Bill form submission
      var billForm = document.getElementById('bill-form');
      if (billForm) {
        billForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveBill();
        });
      }

      // Bill frequency change (show/hide due month for yearly)
      var billFrequency = document.getElementById('bill-frequency');
      if (billFrequency) {
        billFrequency.addEventListener('change', function () {
          return _this2.updateBillFormFields();
        });
      }

      // Bills filter tabs
      document.querySelectorAll('.bills-tabs .tab-button').forEach(function (tab) {
        tab.addEventListener('click', function (e) {
          document.querySelectorAll('.bills-tabs .tab-button').forEach(function (t) {
            return t.classList.remove('active');
          });
          e.target.classList.add('active');
          _this2.filterBills(e.target.dataset.filter);
        });
      });

      // Close detected panel
      var closeDetectedPanel = document.getElementById('close-detected-panel');
      if (closeDetectedPanel) {
        closeDetectedPanel.addEventListener('click', function () {
          document.getElementById('detected-bills-panel').style.display = 'none';
        });
      }

      // Cancel detected
      var cancelDetectedBtn = document.getElementById('cancel-detected-btn');
      if (cancelDetectedBtn) {
        cancelDetectedBtn.addEventListener('click', function () {
          document.getElementById('detected-bills-panel').style.display = 'none';
        });
      }

      // Add selected bills from detection
      var addSelectedBillsBtn = document.getElementById('add-selected-bills-btn');
      if (addSelectedBillsBtn) {
        addSelectedBillsBtn.addEventListener('click', function () {
          return _this2.addSelectedDetectedBills();
        });
      }

      // Delegated event handlers for bill actions
      document.addEventListener('click', function (e) {
        if (e.target.classList.contains('bill-edit-btn') || e.target.closest('.bill-edit-btn')) {
          var button = e.target.classList.contains('bill-edit-btn') ? e.target : e.target.closest('.bill-edit-btn');
          var billId = parseInt(button.dataset.billId);
          _this2.editBill(billId);
        } else if (e.target.classList.contains('bill-delete-btn') || e.target.closest('.bill-delete-btn')) {
          var _button = e.target.classList.contains('bill-delete-btn') ? e.target : e.target.closest('.bill-delete-btn');
          var _billId = parseInt(_button.dataset.billId);
          _this2.deleteBill(_billId);
        } else if (e.target.classList.contains('bill-paid-btn') || e.target.closest('.bill-paid-btn')) {
          var _button2 = e.target.classList.contains('bill-paid-btn') ? e.target : e.target.closest('.bill-paid-btn');
          var _billId2 = parseInt(_button2.dataset.billId);
          _this2.markBillPaid(_billId2);
        }
      });
    }
  }, {
    key: "showBillModal",
    value: function showBillModal() {
      var bill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('bill-modal');
      var title = document.getElementById('bill-modal-title');
      var form = document.getElementById('bill-form');
      form.reset();
      document.getElementById('bill-id').value = '';
      if (bill) {
        var _bill$reminderDays;
        title.textContent = 'Edit Bill';
        document.getElementById('bill-id').value = bill.id;
        document.getElementById('bill-name').value = bill.name || '';
        document.getElementById('bill-amount').value = bill.amount || '';
        document.getElementById('bill-frequency').value = bill.frequency || 'monthly';
        document.getElementById('bill-due-day').value = bill.dueDay || bill.due_day || '';
        document.getElementById('bill-due-month').value = bill.dueMonth || bill.due_month || '';
        document.getElementById('bill-category').value = bill.categoryId || bill.category_id || '';
        document.getElementById('bill-account').value = bill.accountId || bill.account_id || '';
        document.getElementById('bill-auto-pattern').value = bill.autoDetectPattern || bill.auto_detect_pattern || '';
        document.getElementById('bill-notes').value = bill.notes || '';
        var reminderDays = (_bill$reminderDays = bill.reminderDays) !== null && _bill$reminderDays !== void 0 ? _bill$reminderDays : bill.reminder_days;
        document.getElementById('bill-reminder-days').value = reminderDays !== null && reminderDays !== undefined ? reminderDays.toString() : '';
      } else {
        title.textContent = 'Add Bill';
      }
      this.updateBillFormFields();
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }
  }, {
    key: "hideBillModal",
    value: function hideBillModal() {
      var modal = document.getElementById('bill-modal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }
  }, {
    key: "updateBillFormFields",
    value: function updateBillFormFields() {
      var frequency = document.getElementById('bill-frequency').value;
      var dueDayGroup = document.getElementById('due-day-group');
      var dueMonthGroup = document.getElementById('due-month-group');

      // Show due month only for yearly bills
      if (frequency === 'yearly') {
        dueMonthGroup.style.display = 'block';
      } else {
        dueMonthGroup.style.display = 'none';
      }

      // Update due day label based on frequency
      var dueDayLabel = dueDayGroup.querySelector('label');
      var dueDayHelp = document.getElementById('bill-due-day-help');
      if (frequency === 'weekly') {
        dueDayLabel.textContent = 'Due Day (1-7)';
        dueDayHelp.textContent = 'Day of the week (1=Monday, 7=Sunday)';
        document.getElementById('bill-due-day').max = 7;
      } else {
        dueDayLabel.textContent = 'Due Day';
        dueDayHelp.textContent = 'Day of the month when bill is due';
        document.getElementById('bill-due-day').max = 31;
      }
    }
  }, {
    key: "populateBillModalDropdowns",
    value: function populateBillModalDropdowns() {
      // Populate category dropdown
      var categorySelect = document.getElementById('bill-category');
      if (categorySelect && this.categories) {
        var currentValue = categorySelect.value;
        categorySelect.innerHTML = '<option value="">No category</option>';
        this.categories.filter(function (c) {
          return c.type === 'expense';
        }).forEach(function (cat) {
          categorySelect.innerHTML += "<option value=\"".concat(cat.id, "\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(cat.name), "</option>");
        });
        if (currentValue) categorySelect.value = currentValue;
      }

      // Populate account dropdown
      var accountSelect = document.getElementById('bill-account');
      if (accountSelect && this.accounts) {
        var _currentValue = accountSelect.value;
        accountSelect.innerHTML = '<option value="">No specific account</option>';
        this.accounts.forEach(function (acc) {
          accountSelect.innerHTML += "<option value=\"".concat(acc.id, "\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(acc.name), "</option>");
        });
        if (_currentValue) accountSelect.value = _currentValue;
      }
    }
  }, {
    key: "saveBill",
    value: function () {
      var _saveBill = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var billId, isNew, reminderValue, billData, url, response, error, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              billId = document.getElementById('bill-id').value;
              isNew = !billId;
              reminderValue = document.getElementById('bill-reminder-days').value;
              billData = {
                name: document.getElementById('bill-name').value,
                amount: parseFloat(document.getElementById('bill-amount').value),
                frequency: document.getElementById('bill-frequency').value,
                dueDay: document.getElementById('bill-due-day').value ? parseInt(document.getElementById('bill-due-day').value) : null,
                dueMonth: document.getElementById('bill-due-month').value ? parseInt(document.getElementById('bill-due-month').value) : null,
                categoryId: document.getElementById('bill-category').value ? parseInt(document.getElementById('bill-category').value) : null,
                accountId: document.getElementById('bill-account').value ? parseInt(document.getElementById('bill-account').value) : null,
                autoDetectPattern: document.getElementById('bill-auto-pattern').value || null,
                notes: document.getElementById('bill-notes').value || null,
                reminderDays: reminderValue !== '' ? parseInt(reminderValue) : null
              };
              _context3.p = 1;
              url = isNew ? OC.generateUrl('/apps/budget/api/bills') : OC.generateUrl("/apps/budget/api/bills/".concat(billId));
              _context3.n = 2;
              return fetch(url, {
                method: isNew ? 'POST' : 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(billData)
              });
            case 2:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 4;
                break;
              }
              _context3.n = 3;
              return response.json();
            case 3:
              error = _context3.v;
              throw new Error(error.error || 'Failed to save bill');
            case 4:
              this.hideBillModal();
              OC.Notification.showTemporary(isNew ? 'Bill created successfully' : 'Bill updated successfully');
              _context3.n = 5;
              return this.loadBillsView();
            case 5:
              _context3.n = 7;
              break;
            case 6:
              _context3.p = 6;
              _t3 = _context3.v;
              console.error('Failed to save bill:', _t3);
              OC.Notification.showTemporary(_t3.message || 'Failed to save bill');
            case 7:
              return _context3.a(2);
          }
        }, _callee3, this, [[1, 6]]);
      }));
      function saveBill() {
        return _saveBill.apply(this, arguments);
      }
      return saveBill;
    }()
  }, {
    key: "editBill",
    value: function () {
      var _editBill = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(billId) {
        var response, bill, _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              _context4.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/bills/".concat(billId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context4.n = 3;
              return response.json();
            case 3:
              bill = _context4.v;
              this.showBillModal(bill);
              _context4.n = 5;
              break;
            case 4:
              _context4.p = 4;
              _t4 = _context4.v;
              console.error('Failed to load bill:', _t4);
              OC.Notification.showTemporary('Failed to load bill');
            case 5:
              return _context4.a(2);
          }
        }, _callee4, this, [[0, 4]]);
      }));
      function editBill(_x) {
        return _editBill.apply(this, arguments);
      }
      return editBill;
    }()
  }, {
    key: "deleteBill",
    value: function () {
      var _deleteBill = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(billId) {
        var response, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              if (confirm('Are you sure you want to delete this bill?')) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              _context5.p = 1;
              _context5.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/bills/".concat(billId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              OC.Notification.showTemporary('Bill deleted successfully');
              _context5.n = 4;
              return this.loadBillsView();
            case 4:
              _context5.n = 6;
              break;
            case 5:
              _context5.p = 5;
              _t5 = _context5.v;
              console.error('Failed to delete bill:', _t5);
              OC.Notification.showTemporary('Failed to delete bill');
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this, [[1, 5]]);
      }));
      function deleteBill(_x2) {
        return _deleteBill.apply(this, arguments);
      }
      return deleteBill;
    }()
  }, {
    key: "markBillPaid",
    value: function () {
      var _markBillPaid = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(billId) {
        var _this3 = this;
        var bill, previousPaidDate, currentDate, response, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              bill = this.bills.find(function (b) {
                return b.id === billId;
              });
              if (bill) {
                _context6.n = 1;
                break;
              }
              throw new Error('Bill not found');
            case 1:
              previousPaidDate = bill.lastPaidDate || bill.last_paid_date || null;
              currentDate = new Date().toISOString().split('T')[0];
              _context6.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/bills/".concat(billId, "/paid")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  paidDate: currentDate
                })
              });
            case 2:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              // Store undo data BEFORE reloading
              this._undoData = {
                billId: billId,
                previousPaidDate: previousPaidDate,
                action: 'markPaid'
              };
              _context6.n = 4;
              return this.loadBillsView();
            case 4:
              if (this._undoTimer) {
                clearTimeout(this._undoTimer);
              }
              this.showUndoNotification('Bill marked as paid', function () {
                return _this3.undoMarkBillPaid();
              });
              this._undoTimer = setTimeout(function () {
                _this3._undoData = null;
                _this3._undoTimer = null;
              }, 5000);
              _context6.n = 6;
              break;
            case 5:
              _context6.p = 5;
              _t6 = _context6.v;
              console.error('Failed to mark bill as paid:', _t6);
              OC.Notification.showTemporary('Failed to mark bill as paid');
            case 6:
              return _context6.a(2);
          }
        }, _callee6, this, [[0, 5]]);
      }));
      function markBillPaid(_x3) {
        return _markBillPaid.apply(this, arguments);
      }
      return markBillPaid;
    }()
  }, {
    key: "undoMarkBillPaid",
    value: function () {
      var _undoMarkBillPaid = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var _this$_undoData, billId, previousPaidDate, response, errorData, _t7;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              if (this._undoData) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              _context7.p = 1;
              _this$_undoData = this._undoData, billId = _this$_undoData.billId, previousPaidDate = _this$_undoData.previousPaidDate;
              if (this._undoTimer) {
                clearTimeout(this._undoTimer);
                this._undoTimer = null;
              }
              _context7.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/bills/".concat(billId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  lastPaidDate: previousPaidDate
                })
              });
            case 2:
              response = _context7.v;
              if (response.ok) {
                _context7.n = 4;
                break;
              }
              _context7.n = 3;
              return response.json()["catch"](function () {
                return {};
              });
            case 3:
              errorData = _context7.v;
              throw new Error(errorData.error || "HTTP ".concat(response.status));
            case 4:
              this._undoData = null;
              _context7.n = 5;
              return this.loadBillsView();
            case 5:
              OC.Notification.showTemporary('Action undone');
              _context7.n = 7;
              break;
            case 6:
              _context7.p = 6;
              _t7 = _context7.v;
              console.error('Failed to undo mark paid:', _t7);
              OC.Notification.showTemporary("Failed to undo action: ".concat(_t7.message));
            case 7:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 6]]);
      }));
      function undoMarkBillPaid() {
        return _undoMarkBillPaid.apply(this, arguments);
      }
      return undoMarkBillPaid;
    }()
  }, {
    key: "showUndoNotification",
    value: function showUndoNotification(message, undoCallback) {
      var notification = document.createElement('div');
      notification.className = 'undo-notification';
      notification.innerHTML = "\n            <span class=\"undo-message\">".concat(message, "</span>\n            <button class=\"undo-btn\">Undo</button>\n        ");
      Object.assign(notification.style, {
        position: 'fixed',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: '#333',
        color: '#fff',
        padding: '12px 20px',
        borderRadius: '4px',
        display: 'flex',
        alignItems: 'center',
        gap: '15px',
        zIndex: '10000',
        boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
        animation: 'slideUp 0.3s ease-out'
      });
      var undoBtn = notification.querySelector('.undo-btn');
      Object.assign(undoBtn.style, {
        backgroundColor: '#fff',
        color: '#333',
        border: 'none',
        padding: '6px 12px',
        borderRadius: '3px',
        cursor: 'pointer',
        fontWeight: 'bold',
        fontSize: '13px'
      });
      undoBtn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        undoCallback();
        notification.remove();
      });
      document.body.appendChild(notification);
      setTimeout(function () {
        notification.style.animation = 'slideDown 0.3s ease-in';
        setTimeout(function () {
          return notification.remove();
        }, 300);
      }, 5000);
    }
  }, {
    key: "detectBills",
    value: function () {
      var _detectBills = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var detectBtn, response, detected, _t8;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              detectBtn = document.getElementById('detect-bills-btn');
              detectBtn.disabled = true;
              detectBtn.innerHTML = '<span class="icon-loading-small" aria-hidden="true"></span> Detecting...';
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/bills/detect?months=6'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              _context8.n = 4;
              return response.json();
            case 4:
              detected = _context8.v;
              if (!(!detected || detected.length === 0)) {
                _context8.n = 5;
                break;
              }
              OC.Notification.showTemporary('No recurring transactions detected');
              return _context8.a(2);
            case 5:
              this.renderDetectedBills(detected);
              document.getElementById('detected-bills-panel').style.display = 'flex';
              _context8.n = 7;
              break;
            case 6:
              _context8.p = 6;
              _t8 = _context8.v;
              console.error('Failed to detect bills:', _t8);
              OC.Notification.showTemporary('Failed to detect recurring bills');
            case 7:
              _context8.p = 7;
              detectBtn.disabled = false;
              detectBtn.innerHTML = '<span class="icon-search" aria-hidden="true"></span> Detect Bills';
              return _context8.f(7);
            case 8:
              return _context8.a(2);
          }
        }, _callee8, this, [[1, 6, 7, 8]]);
      }));
      function detectBills() {
        return _detectBills.apply(this, arguments);
      }
      return detectBills;
    }()
  }, {
    key: "renderDetectedBills",
    value: function renderDetectedBills(detected) {
      var _this4 = this;
      var list = document.getElementById('detected-bills-list');
      list.innerHTML = detected.map(function (item, index) {
        var confidenceClass = item.confidence >= 0.8 ? 'high' : item.confidence >= 0.5 ? 'medium' : 'low';
        var confidencePercent = Math.round(item.confidence * 100);
        return "\n                <div class=\"detected-bill-item\" data-index=\"".concat(index, "\">\n                    <div class=\"detected-bill-select\">\n                        <input type=\"checkbox\" id=\"detected-").concat(index, "\" ").concat(item.confidence >= 0.7 ? 'checked' : '', ">\n                    </div>\n                    <div class=\"detected-bill-info\">\n                        <label for=\"detected-").concat(index, "\" class=\"detected-bill-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(item.description || item.name), "</label>\n                        <div class=\"detected-bill-meta\">\n                            <span class=\"detected-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(item.avgAmount || item.amount, null, _this4.settings), "</span>\n                            <span class=\"detected-frequency\">").concat(item.frequency, "</span>\n                            <span class=\"detected-confidence ").concat(confidenceClass, "\">").concat(confidencePercent, "% confidence</span>\n                        </div>\n                    </div>\n                </div>\n            ");
      }).join('');

      // Store detected bills for later use
      this._detectedBills = detected;
    }
  }, {
    key: "addSelectedDetectedBills",
    value: function () {
      var _addSelectedDetectedBills = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
        var _this5 = this;
        var checkboxes, selectedIndices, billsToAdd, response, result, _t9;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              checkboxes = document.querySelectorAll('#detected-bills-list input[type="checkbox"]:checked');
              selectedIndices = Array.from(checkboxes).map(function (cb) {
                return parseInt(cb.id.replace('detected-', ''));
              });
              if (!(selectedIndices.length === 0)) {
                _context9.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select at least one bill to add');
              return _context9.a(2);
            case 1:
              billsToAdd = selectedIndices.map(function (i) {
                return _this5._detectedBills[i];
              });
              _context9.p = 2;
              _context9.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/bills/create-from-detected'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  bills: billsToAdd
                })
              });
            case 3:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 4;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 4:
              _context9.n = 5;
              return response.json();
            case 5:
              result = _context9.v;
              document.getElementById('detected-bills-panel').style.display = 'none';
              OC.Notification.showTemporary("".concat(result.created, " bills added successfully"));
              _context9.n = 6;
              return this.loadBillsView();
            case 6:
              _context9.n = 8;
              break;
            case 7:
              _context9.p = 7;
              _t9 = _context9.v;
              console.error('Failed to add bills:', _t9);
              OC.Notification.showTemporary('Failed to add selected bills');
            case 8:
              return _context9.a(2);
          }
        }, _callee9, this, [[2, 7]]);
      }));
      function addSelectedDetectedBills() {
        return _addSelectedDetectedBills.apply(this, arguments);
      }
      return addSelectedDetectedBills;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/categories/CategoriesModule.js":
/*!****************************************************!*\
  !*** ./src/modules/categories/CategoriesModule.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CategoriesModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Categories Module - Category management, budgets, and tree visualization
 */

var CategoriesModule = /*#__PURE__*/function () {
  function CategoriesModule(app) {
    _classCallCheck(this, CategoriesModule);
    this.app = app;
    this.selectedCategory = null;
    this.selectedCategoryIds = new Set();
    this.expandedCategories = new Set();
    this.currentCategoryType = 'expense';
    this.budgetType = 'expense';
    this.budgetMonth = new Date().toISOString().slice(0, 7); // YYYY-MM
    this.budgetEventListenersSetup = false;
    this.categoryEventListenersSetup = false;
    this.categorySpending = {};
  }

  // State proxies
  return _createClass(CategoriesModule, [{
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "allCategories",
    get: function get() {
      return this.app.allCategories;
    },
    set: function set(value) {
      this.app.allCategories = value;
    }
  }, {
    key: "categoryTree",
    get: function get() {
      return this.app.categoryTree;
    },
    set: function set(value) {
      this.app.categoryTree = value;
    }
  }, {
    key: "transactions",
    get: function get() {
      return this.app.transactions;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }

    // Helper method delegations
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(date) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(date);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      var div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  }, {
    key: "loadCategories",
    value: function () {
      var _loadCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/categories/tree'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context.v;
              if (!response.ok) {
                _context.n = 3;
                break;
              }
              _context.n = 2;
              return response.json();
            case 2:
              this.categoryTree = _context.v;
              this.allCategories = this.flattenCategories(this.categoryTree);
              this.renderCategoriesTree();
              this.setupCategoriesEventListeners();
            case 3:
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
              console.error('Failed to load categories:', _t);
              OC.Notification.showTemporary('Failed to load categories');
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[0, 4]]);
      }));
      function loadCategories() {
        return _loadCategories.apply(this, arguments);
      }
      return loadCategories;
    }()
  }, {
    key: "renderCategoryTree",
    value: function renderCategoryTree(categories) {
      var _this = this;
      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return categories.map(function (cat) {
        return "\n            <div class=\"category-item\" style=\"margin-left: ".concat(level * 20, "px\" data-id=\"").concat(cat.id, "\">\n                <span class=\"category-name\">").concat(cat.name, "</span>\n                ").concat(cat.children ? _this.renderCategoryTree(cat.children, level + 1) : '', "\n            </div>\n        ");
      }).join('');
    }
  }, {
    key: "setupCategoriesEventListeners",
    value: function setupCategoriesEventListeners() {
      var _this2 = this;
      // Prevent duplicate event listeners
      if (this.categoryEventListenersSetup) {
        return;
      }
      this.categoryEventListenersSetup = true;

      // Tab switching
      document.querySelectorAll('.tab-button').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          var type = e.currentTarget.dataset.tab;
          _this2.switchCategoryType(type);
        });
      });

      // Search
      var searchInput = document.getElementById('categories-search');
      if (searchInput) {
        searchInput.addEventListener('input', function (e) {
          _this2.searchCategories(e.target.value);
        });
      }

      // Expand/Collapse all
      var expandBtn = document.getElementById('expand-all-btn');
      var collapseBtn = document.getElementById('collapse-all-btn');
      if (expandBtn) {
        expandBtn.addEventListener('click', function () {
          return _this2.expandAllCategories();
        });
      }
      if (collapseBtn) {
        collapseBtn.addEventListener('click', function () {
          return _this2.collapseAllCategories();
        });
      }

      // Add category button
      var addBtn = document.getElementById('add-category-btn');
      if (addBtn) {
        addBtn.addEventListener('click', function () {
          return _this2.showAddCategoryModal();
        });
      }

      // Category details actions
      var editBtn = document.getElementById('edit-category-btn');
      var deleteBtn = document.getElementById('delete-category-btn');
      if (editBtn) {
        editBtn.addEventListener('click', function () {
          return _this2.editSelectedCategory();
        });
      }
      if (deleteBtn) {
        deleteBtn.addEventListener('click', function () {
          return _this2.deleteSelectedCategory();
        });
      }

      // Bulk action buttons
      var selectAllBtn = document.getElementById('category-select-all-btn');
      var clearSelectionBtn = document.getElementById('category-clear-selection-btn');
      var bulkDeleteBtn = document.getElementById('category-bulk-delete-btn');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', function () {
          return _this2.selectAllCategories();
        });
      }
      if (clearSelectionBtn) {
        clearSelectionBtn.addEventListener('click', function () {
          return _this2.clearCategorySelection();
        });
      }
      if (bulkDeleteBtn) {
        bulkDeleteBtn.addEventListener('click', function () {
          return _this2.bulkDeleteCategories();
        });
      }
    }
  }, {
    key: "switchCategoryType",
    value: function switchCategoryType(type) {
      // Update active tab
      document.querySelectorAll('.tab-button').forEach(function (btn) {
        btn.classList.toggle('active', btn.dataset.tab === type);
      });
      this.currentCategoryType = type;
      this.selectedCategory = null;
      this.renderCategoriesTree();
      this.showCategoryDetailsEmpty();
    }
  }, {
    key: "renderCategoriesTree",
    value: function renderCategoriesTree() {
      var _this3 = this;
      var treeContainer = document.getElementById('categories-tree');
      var emptyState = document.getElementById('empty-categories');
      if (!treeContainer) return;

      // Handle case where categoryTree is not loaded or empty
      if (!this.categoryTree || !Array.isArray(this.categoryTree) || this.categoryTree.length === 0) {
        treeContainer.innerHTML = '';
        if (emptyState) emptyState.style.display = 'block';
        return;
      }

      // Filter categories by current type
      var typedCategories = this.categoryTree.filter(function (cat) {
        return cat.type === _this3.currentCategoryType;
      });
      if (typedCategories.length === 0) {
        treeContainer.innerHTML = '';
        if (emptyState) emptyState.style.display = 'block';
        return;
      }
      if (emptyState) emptyState.style.display = 'none';
      treeContainer.innerHTML = this.renderCategoryNodes(typedCategories);

      // Setup event listeners for category items
      this.setupCategoryItemListeners();
      this.setupDragAndDrop();

      // Auto-select first category if none is selected
      if (!this.selectedCategory && typedCategories.length > 0) {
        this.selectCategory(typedCategories[0].id);
      }
    }
  }, {
    key: "renderCategoryNodes",
    value: function renderCategoryNodes(categories) {
      var _this4 = this;
      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var countMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      // Build count map once at the start (avoids O(n*m) filtering)
      if (countMap === null) {
        countMap = this.buildCategoryTransactionCountMap();
      }
      return categories.map(function (category) {
        var _this4$selectedCatego;
        var hasChildren = category.children && category.children.length > 0;
        var isExpanded = _this4.expandedCategories && _this4.expandedCategories.has(category.id);
        var isSelected = ((_this4$selectedCatego = _this4.selectedCategory) === null || _this4$selectedCatego === void 0 ? void 0 : _this4$selectedCatego.id) === category.id;
        var isChecked = _this4.selectedCategoryIds && _this4.selectedCategoryIds.has(category.id);

        // Use pre-computed count map for O(1) lookup
        var transactionCount = countMap[category.id] || 0;
        return "\n                <div class=\"category-node\" data-level=\"".concat(level, "\">\n                    <div class=\"category-item ").concat(isSelected ? 'selected' : '', " ").concat(isChecked ? 'checked' : '', "\"\n                         data-category-id=\"").concat(category.id, "\"\n                         draggable=\"true\">\n                        <input type=\"checkbox\"\n                               class=\"category-checkbox\"\n                               data-category-id=\"").concat(category.id, "\"\n                               ").concat(isChecked ? 'checked' : '', ">\n                        ").concat(hasChildren ? "\n                            <button class=\"category-toggle ".concat(isExpanded ? 'expanded' : '', "\"\n                                    data-category-id=\"").concat(category.id, "\">\n                                <span class=\"icon-triangle-e\" aria-hidden=\"true\"></span>\n                            </button>\n                        ") : '<div style="width: 20px;"></div>', "\n\n                        <div class=\"category-icon\" style=\"background-color: ").concat(category.color || '#999', ";\">\n                            <span class=\"").concat(category.icon || 'icon-tag', "\" aria-hidden=\"true\"></span>\n                        </div>\n\n                        <div class=\"category-content\">\n                            <span class=\"category-name\">").concat(category.name, "</span>\n                            <div class=\"category-meta\">\n                                ").concat(transactionCount > 0 ? "<span class=\"transaction-count\">".concat(transactionCount, "</span>") : '', "\n                            </div>\n                        </div>\n\n                        <button class=\"category-delete-btn\"\n                                data-category-id=\"").concat(category.id, "\"\n                                title=\"Delete ").concat(category.name, "\">\n                            <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                        </button>\n                    </div>\n\n                    ").concat(hasChildren ? "\n                        <div class=\"category-children ".concat(isExpanded ? '' : 'collapsed', "\">\n                            ").concat(_this4.renderCategoryNodes(category.children, level + 1, countMap), "\n                        </div>\n                    ") : '', "\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "buildCategoryTransactionCountMap",
    value: function buildCategoryTransactionCountMap() {
      var countMap = {};
      var _iterator = _createForOfIteratorHelper(this.transactions || []),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tx = _step.value;
          if (tx.categoryId) {
            countMap[tx.categoryId] = (countMap[tx.categoryId] || 0) + 1;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return countMap;
    }
  }, {
    key: "setupCategoryItemListeners",
    value: function setupCategoryItemListeners() {
      var _this5 = this;
      // Initialize selectedCategoryIds if not exists
      if (!this.selectedCategoryIds) {
        this.selectedCategoryIds = new Set();
      }

      // Category selection
      document.querySelectorAll('.category-item').forEach(function (item) {
        item.addEventListener('click', function (e) {
          if (e.target.closest('.category-toggle')) return;
          if (e.target.closest('.category-checkbox')) return;
          if (e.target.closest('.category-delete-btn')) return;
          var categoryId = parseInt(item.dataset.categoryId);
          _this5.selectCategory(categoryId);
        });
      });

      // Toggle expand/collapse
      document.querySelectorAll('.category-toggle').forEach(function (toggle) {
        toggle.addEventListener('click', function (e) {
          e.stopPropagation();
          var categoryId = parseInt(toggle.dataset.categoryId);
          _this5.toggleCategoryExpanded(categoryId);
        });
      });

      // Checkbox selection for bulk actions
      document.querySelectorAll('.category-checkbox').forEach(function (checkbox) {
        checkbox.addEventListener('change', function (e) {
          e.stopPropagation();
          var categoryId = parseInt(checkbox.dataset.categoryId);
          if (checkbox.checked) {
            _this5.selectedCategoryIds.add(categoryId);
          } else {
            _this5.selectedCategoryIds["delete"](categoryId);
          }
          checkbox.closest('.category-item').classList.toggle('checked', checkbox.checked);
          _this5.updateBulkCategoryActions();
        });
      });

      // Inline delete buttons
      document.querySelectorAll('.category-delete-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          var categoryId = parseInt(btn.dataset.categoryId);
          _this5.deleteCategoryById(categoryId);
        });
      });
    }
  }, {
    key: "setupDragAndDrop",
    value: function setupDragAndDrop() {
      var _this6 = this;
      var categoryItems = document.querySelectorAll('.category-item');
      categoryItems.forEach(function (item) {
        item.addEventListener('dragstart', function (e) {
          e.dataTransfer.setData('text/plain', item.dataset.categoryId);
          item.classList.add('dragging');
        });
        item.addEventListener('dragend', function (e) {
          item.classList.remove('dragging');
          document.querySelectorAll('.drop-indicator').forEach(function (el) {
            return el.remove();
          });
          document.querySelectorAll('.drag-over').forEach(function (el) {
            return el.classList.remove('drag-over');
          });
        });
        item.addEventListener('dragover', function (e) {
          e.preventDefault();
          _this6.showDropIndicator(e, item);
        });
        item.addEventListener('drop', function (e) {
          e.preventDefault();
          var draggedId = parseInt(e.dataTransfer.getData('text/plain'));
          var targetId = parseInt(item.dataset.categoryId);
          if (draggedId !== targetId) {
            _this6.reorderCategory(draggedId, targetId, _this6.getDropPosition(e, item));
          }
        });
      });
    }
  }, {
    key: "showDropIndicator",
    value: function showDropIndicator(e, targetItem) {
      // Remove existing indicators
      document.querySelectorAll('.drop-indicator').forEach(function (el) {
        return el.remove();
      });
      document.querySelectorAll('.drag-over').forEach(function (el) {
        return el.classList.remove('drag-over');
      });
      var rect = targetItem.getBoundingClientRect();
      var y = e.clientY - rect.top;
      var threshold = rect.height / 3;
      var indicator = document.createElement('div');
      indicator.className = 'drop-indicator';
      if (y < threshold) {
        // Drop above
        indicator.classList.add('top');
        targetItem.parentNode.insertBefore(indicator, targetItem.parentNode);
      } else if (y > rect.height - threshold) {
        // Drop below
        indicator.classList.add('bottom');
        targetItem.parentNode.insertBefore(indicator, targetItem.parentNode.nextSibling);
      } else {
        // Drop as child
        indicator.classList.add('child');
        targetItem.classList.add('drag-over');
        targetItem.appendChild(indicator);
      }
    }
  }, {
    key: "getDropPosition",
    value: function getDropPosition(e, targetItem) {
      var rect = targetItem.getBoundingClientRect();
      var y = e.clientY - rect.top;
      var threshold = rect.height / 3;
      if (y < threshold) return 'above';
      if (y > rect.height - threshold) return 'below';
      return 'child';
    }
  }, {
    key: "reorderCategory",
    value: function () {
      var _reorderCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(draggedId, targetId, position) {
        var draggedCategory, targetCategory, newParentId, newSortOrder, response, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              draggedCategory = this.findCategoryById(draggedId);
              targetCategory = this.findCategoryById(targetId);
              if (!(!draggedCategory || !targetCategory)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              newParentId = null;
              newSortOrder = 0;
              if (position === 'child') {
                newParentId = targetId;
                newSortOrder = 0; // First child
              } else {
                newParentId = targetCategory.parentId;
                newSortOrder = position === 'above' ? targetCategory.sortOrder : targetCategory.sortOrder + 1;
              }

              // Update via API
              _context2.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/categories/".concat(draggedId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  parentId: newParentId,
                  sortOrder: newSortOrder
                })
              });
            case 2:
              response = _context2.v;
              if (!response.ok) {
                _context2.n = 4;
                break;
              }
              _context2.n = 3;
              return this.loadCategories();
            case 3:
              OC.Notification.showTemporary('Category reordered successfully');
              _context2.n = 5;
              break;
            case 4:
              throw new Error('Failed to reorder category');
            case 5:
              _context2.n = 7;
              break;
            case 6:
              _context2.p = 6;
              _t2 = _context2.v;
              console.error('Failed to reorder category:', _t2);
              OC.Notification.showTemporary('Failed to reorder category');
            case 7:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 6]]);
      }));
      function reorderCategory(_x, _x2, _x3) {
        return _reorderCategory.apply(this, arguments);
      }
      return reorderCategory;
    }()
  }, {
    key: "selectCategory",
    value: function selectCategory(categoryId) {
      // Update selection in tree
      document.querySelectorAll('.category-item').forEach(function (item) {
        item.classList.toggle('selected', parseInt(item.dataset.categoryId) === categoryId);
      });

      // Find and store selected category
      this.selectedCategory = this.findCategoryById(categoryId);
      if (this.selectedCategory) {
        this.showCategoryDetails(this.selectedCategory);
      }
    }
  }, {
    key: "showCategoryDetails",
    value: function () {
      var _showCategoryDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(category) {
        var emptyEl, contentEl;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              // Hide empty state, show details
              emptyEl = document.getElementById('category-details-empty');
              contentEl = document.getElementById('category-details-content');
              if (emptyEl) emptyEl.style.display = 'none';
              if (contentEl) contentEl.style.display = 'block';

              // Update category overview
              this.updateCategoryOverview(category);

              // Load and display tag sets
              _context3.n = 1;
              return this.app.renderCategoryTagSetsList(category.id);
            case 1:
              _context3.n = 2;
              return this.loadCategoryAnalytics(category.id);
            case 2:
              _context3.n = 3;
              return this.loadCategoryTransactions(category.id);
            case 3:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
      function showCategoryDetails(_x4) {
        return _showCategoryDetails.apply(this, arguments);
      }
      return showCategoryDetails;
    }()
  }, {
    key: "updateCategoryOverview",
    value: function updateCategoryOverview(category) {
      var nameEl = document.getElementById('category-display-name');
      if (nameEl) nameEl.textContent = category.name;
      var iconEl = document.getElementById('category-display-icon');
      if (iconEl) {
        iconEl.className = "category-icon large ".concat(category.icon || 'icon-tag');
        iconEl.style.backgroundColor = category.color || '#999';
      }
      var typeEl = document.getElementById('category-display-type');
      if (typeEl) {
        typeEl.textContent = category.type;
        typeEl.className = "category-type-badge ".concat(category.type);
      }

      // Build category path
      var path = this.getCategoryPath(category);
      var pathEl = document.getElementById('category-display-path');
      if (pathEl) pathEl.textContent = path;
    }
  }, {
    key: "loadCategoryAnalytics",
    value: function () {
      var _loadCategoryAnalytics = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(categoryId) {
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              try {
                this.updateAnalyticsDisplay(categoryId);
              } catch (error) {
                console.error('Failed to load category analytics:', error);
                this.updateAnalyticsDisplay(categoryId);
              }
            case 1:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function loadCategoryAnalytics(_x5) {
        return _loadCategoryAnalytics.apply(this, arguments);
      }
      return loadCategoryAnalytics;
    }()
  }, {
    key: "updateAnalyticsDisplay",
    value: function updateAnalyticsDisplay(categoryId) {
      // Calculate analytics from transactions
      var categoryTransactions = this.getCategoryTransactions(categoryId);
      var totalCount = categoryTransactions.length;
      var totalAmount = categoryTransactions.reduce(function (sum, t) {
        return sum + Math.abs(parseFloat(t.amount) || 0);
      }, 0);
      var avgAmount = totalCount > 0 ? totalAmount / totalCount : 0;

      // Calculate trend (simplified)
      var trend = this.calculateCategoryTrend(categoryTransactions);
      var countEl = document.getElementById('total-transactions-count');
      if (countEl) countEl.textContent = totalCount.toLocaleString();
      var avgEl = document.getElementById('avg-transaction-amount');
      if (avgEl) avgEl.textContent = this.formatCurrency(avgAmount);
      var trendEl = document.getElementById('category-trend');
      if (trendEl) trendEl.textContent = trend;
    }
  }, {
    key: "loadCategoryTransactions",
    value: function () {
      var _loadCategoryTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(categoryId) {
        var _this7 = this;
        var transactions, container, _t3;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              // Get recent transactions for this category
              transactions = this.getCategoryTransactions(categoryId, 5);
              container = document.getElementById('category-recent-transactions');
              if (container) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              if (!(transactions.length === 0)) {
                _context5.n = 2;
                break;
              }
              container.innerHTML = '<div class="empty-state"><p>No transactions in this category yet.</p></div>';
              return _context5.a(2);
            case 2:
              container.innerHTML = transactions.map(function (transaction) {
                return "\n                <div class=\"transaction-item\">\n                    <div class=\"transaction-description\">".concat(transaction.description, "</div>\n                    <div class=\"transaction-date\">").concat(_this7.formatDate(transaction.date), "</div>\n                    <div class=\"transaction-amount ").concat(transaction.type, "\">\n                        ").concat(transaction.type === 'credit' ? '+' : '-').concat(_this7.formatCurrency(Math.abs(transaction.amount)), "\n                    </div>\n                </div>\n            ");
              }).join('');
              _context5.n = 4;
              break;
            case 3:
              _context5.p = 3;
              _t3 = _context5.v;
              console.error('Failed to load category transactions:', _t3);
            case 4:
              return _context5.a(2);
          }
        }, _callee5, this, [[0, 3]]);
      }));
      function loadCategoryTransactions(_x6) {
        return _loadCategoryTransactions.apply(this, arguments);
      }
      return loadCategoryTransactions;
    }()
  }, {
    key: "showCategoryDetailsEmpty",
    value: function showCategoryDetailsEmpty() {
      var contentEl = document.getElementById('category-details-content');
      var emptyEl = document.getElementById('category-details-empty');
      if (contentEl) contentEl.style.display = 'none';
      if (emptyEl) emptyEl.style.display = 'flex';
    }
  }, {
    key: "toggleCategoryExpanded",
    value: function toggleCategoryExpanded(categoryId) {
      if (!this.expandedCategories) this.expandedCategories = new Set();
      if (this.expandedCategories.has(categoryId)) {
        this.expandedCategories["delete"](categoryId);
      } else {
        this.expandedCategories.add(categoryId);
      }
      this.renderCategoriesTree();
    }
  }, {
    key: "expandAllCategories",
    value: function expandAllCategories() {
      var _this8 = this;
      if (!this.expandedCategories) this.expandedCategories = new Set();
      var allCategories = this.getAllCategoryIds(this.categoryTree || []);
      allCategories.forEach(function (id) {
        return _this8.expandedCategories.add(id);
      });
      this.renderCategoriesTree();
    }
  }, {
    key: "collapseAllCategories",
    value: function collapseAllCategories() {
      if (!this.expandedCategories) this.expandedCategories = new Set();
      this.expandedCategories.clear();
      this.renderCategoriesTree();
    }
  }, {
    key: "searchCategories",
    value: function searchCategories(query) {
      // Simple search implementation
      var items = document.querySelectorAll('.category-item');
      var lowerQuery = query.toLowerCase();
      items.forEach(function (item) {
        var nameEl = item.querySelector('.category-name');
        if (nameEl) {
          var categoryName = nameEl.textContent.toLowerCase();
          var matches = categoryName.includes(lowerQuery);
          item.style.display = matches ? 'flex' : 'none';
        }
      });
    }

    // Helper methods
  }, {
    key: "findCategoryById",
    value: function findCategoryById(id) {
      var _findInTree = function findInTree(categories) {
        var _iterator2 = _createForOfIteratorHelper(categories),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var category = _step2.value;
            if (category.id === id) return category;
            if (category.children) {
              var found = _findInTree(category.children);
              if (found) return found;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return null;
      };
      return _findInTree(this.categoryTree || []);
    }
  }, {
    key: "getCategoryPath",
    value: function getCategoryPath(category) {
      var path = [];
      var current = category;
      while ((_current = current) !== null && _current !== void 0 && _current.parentId) {
        var _current;
        var parent = this.findCategoryById(current.parentId);
        if (parent) {
          path.unshift(parent.name);
          current = parent;
        } else {
          break;
        }
      }
      return path.length > 0 ? path.join('  ') : 'Root';
    }
  }, {
    key: "getCategoryTransactionCount",
    value: function getCategoryTransactionCount(categoryId) {
      return this.getCategoryTransactions(categoryId).length;
    }
  }, {
    key: "getCategoryTransactions",
    value: function getCategoryTransactions(categoryId) {
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var transactions = (this.transactions || []).filter(function (t) {
        return t.categoryId === categoryId;
      });
      return limit ? transactions.slice(0, limit) : transactions;
    }
  }, {
    key: "calculateCategoryTrend",
    value: function calculateCategoryTrend(transactions) {
      if (transactions.length < 2) return '';

      // Simple trend calculation based on recent vs older transactions
      var sorted = transactions.sort(function (a, b) {
        return new Date(b.date) - new Date(a.date);
      });
      var recent = sorted.slice(0, Math.ceil(sorted.length / 2));
      var older = sorted.slice(Math.ceil(sorted.length / 2));
      var recentAvg = recent.reduce(function (sum, t) {
        return sum + Math.abs(t.amount);
      }, 0) / recent.length;
      var olderAvg = older.reduce(function (sum, t) {
        return sum + Math.abs(t.amount);
      }, 0) / older.length;
      var change = (recentAvg - olderAvg) / olderAvg * 100;
      if (Math.abs(change) < 5) return ' Stable';
      return change > 0 ? ' Increasing' : ' Decreasing';
    }
  }, {
    key: "getAllCategoryIds",
    value: function getAllCategoryIds(categories) {
      var ids = [];
      var _traverse = function traverse(cats) {
        cats.forEach(function (cat) {
          ids.push(cat.id);
          if (cat.children) _traverse(cat.children);
        });
      };
      _traverse(categories);
      return ids;
    }
  }, {
    key: "showAddCategoryModal",
    value: function showAddCategoryModal() {
      var modal = document.getElementById('category-modal');
      var title = document.getElementById('category-modal-title');
      if (!modal || !title) {
        console.error('Category modal not found');
        return;
      }
      title.textContent = 'Add Category';
      this.resetCategoryForm();
      this.populateCategoryParentDropdown();

      // Pre-select the current category type tab
      var typeSelect = document.getElementById('category-type');
      if (typeSelect && this.currentCategoryType) {
        typeSelect.value = this.currentCategoryType;
      }

      // Show empty state for tag sets (can't add tag sets until category is saved)
      this.app.renderCategoryTagSetsUI(null);
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      var nameField = document.getElementById('category-name');
      if (nameField) {
        nameField.focus();
      }
    }
  }, {
    key: "editSelectedCategory",
    value: function editSelectedCategory() {
      if (!this.selectedCategory) {
        return;
      }
      var modal = document.getElementById('category-modal');
      var title = document.getElementById('category-modal-title');
      if (!modal || !title) {
        console.error('Category modal not found');
        return;
      }
      title.textContent = 'Edit Category';
      this.loadCategoryData(this.selectedCategory);
      this.populateCategoryParentDropdown(this.selectedCategory.id);
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      var nameField = document.getElementById('category-name');
      if (nameField) {
        nameField.focus();
      }
    }
  }, {
    key: "deleteSelectedCategory",
    value: function () {
      var _deleteSelectedCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var categoryName, response, error, _t4;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              if (this.selectedCategory) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              categoryName = this.selectedCategory.name;
              if (confirm("Are you sure you want to delete the category \"".concat(categoryName, "\"? This action cannot be undone."))) {
                _context6.n = 2;
                break;
              }
              return _context6.a(2);
            case 2:
              _context6.p = 2;
              _context6.n = 3;
              return fetch(OC.generateUrl("/apps/budget/api/categories/".concat(this.selectedCategory.id)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 3:
              response = _context6.v;
              if (!response.ok) {
                _context6.n = 6;
                break;
              }
              OC.Notification.showTemporary('Category deleted successfully');
              this.selectedCategory = null;
              _context6.n = 4;
              return this.loadCategories();
            case 4:
              _context6.n = 5;
              return this.app.loadInitialData();
            case 5:
              this.showCategoryDetailsEmpty();
              _context6.n = 8;
              break;
            case 6:
              _context6.n = 7;
              return response.json();
            case 7:
              error = _context6.v;
              throw new Error(error.error || 'Failed to delete category');
            case 8:
              _context6.n = 10;
              break;
            case 9:
              _context6.p = 9;
              _t4 = _context6.v;
              console.error('Failed to delete category:', _t4);
              OC.Notification.showTemporary(_t4.message || 'Failed to delete category');
            case 10:
              return _context6.a(2);
          }
        }, _callee6, this, [[2, 9]]);
      }));
      function deleteSelectedCategory() {
        return _deleteSelectedCategory.apply(this, arguments);
      }
      return deleteSelectedCategory;
    }()
  }, {
    key: "deleteCategoryById",
    value: function () {
      var _deleteCategoryById = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(categoryId) {
        var category, categoryName, response, _this$selectedCategor, error, _t5;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              category = this.findCategoryById(categoryId);
              categoryName = category ? category.name : 'this category';
              if (confirm("Are you sure you want to delete \"".concat(categoryName, "\"? This action cannot be undone."))) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              _context7.p = 1;
              _context7.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/categories/".concat(categoryId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context7.v;
              if (!response.ok) {
                _context7.n = 5;
                break;
              }
              OC.Notification.showTemporary('Category deleted successfully');
              if (((_this$selectedCategor = this.selectedCategory) === null || _this$selectedCategor === void 0 ? void 0 : _this$selectedCategor.id) === categoryId) {
                this.selectedCategory = null;
                this.showCategoryDetailsEmpty();
              }
              this.selectedCategoryIds["delete"](categoryId);
              _context7.n = 3;
              return this.loadCategories();
            case 3:
              _context7.n = 4;
              return this.app.loadInitialData();
            case 4:
              _context7.n = 7;
              break;
            case 5:
              _context7.n = 6;
              return response.json();
            case 6:
              error = _context7.v;
              throw new Error(error.error || 'Failed to delete category');
            case 7:
              _context7.n = 9;
              break;
            case 8:
              _context7.p = 8;
              _t5 = _context7.v;
              console.error('Failed to delete category:', _t5);
              OC.Notification.showTemporary(_t5.message || 'Failed to delete category');
            case 9:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 8]]);
      }));
      function deleteCategoryById(_x7) {
        return _deleteCategoryById.apply(this, arguments);
      }
      return deleteCategoryById;
    }()
  }, {
    key: "updateBulkCategoryActions",
    value: function updateBulkCategoryActions() {
      var toolbar = document.getElementById('category-bulk-toolbar');
      var countSpan = document.getElementById('category-bulk-count');
      var selectedCount = this.selectedCategoryIds ? this.selectedCategoryIds.size : 0;
      if (toolbar) {
        toolbar.style.display = selectedCount > 0 ? 'flex' : 'none';
      }
      if (countSpan) {
        countSpan.textContent = "".concat(selectedCount, " selected");
      }
    }
  }, {
    key: "bulkDeleteCategories",
    value: function () {
      var _bulkDeleteCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var count, categoryIds, deleted, errors, _iterator3, _step3, categoryId, response, error, category, _category, _t6, _t7;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              count = this.selectedCategoryIds.size;
              if (!(count === 0)) {
                _context8.n = 1;
                break;
              }
              return _context8.a(2);
            case 1:
              if (confirm("Are you sure you want to delete ".concat(count, " categor").concat(count === 1 ? 'y' : 'ies', "? This action cannot be undone."))) {
                _context8.n = 2;
                break;
              }
              return _context8.a(2);
            case 2:
              categoryIds = _toConsumableArray(this.selectedCategoryIds);
              deleted = 0;
              errors = [];
              _iterator3 = _createForOfIteratorHelper(categoryIds);
              _context8.p = 3;
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context8.n = 12;
                break;
              }
              categoryId = _step3.value;
              _context8.p = 5;
              _context8.n = 6;
              return fetch(OC.generateUrl("/apps/budget/api/categories/".concat(categoryId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 6:
              response = _context8.v;
              if (!response.ok) {
                _context8.n = 7;
                break;
              }
              deleted++;
              this.selectedCategoryIds["delete"](categoryId);
              _context8.n = 9;
              break;
            case 7:
              _context8.n = 8;
              return response.json();
            case 8:
              error = _context8.v;
              category = this.findCategoryById(categoryId);
              errors.push("".concat((category === null || category === void 0 ? void 0 : category.name) || categoryId, ": ").concat(error.error || 'Failed to delete'));
            case 9:
              _context8.n = 11;
              break;
            case 10:
              _context8.p = 10;
              _t6 = _context8.v;
              _category = this.findCategoryById(categoryId);
              errors.push("".concat((_category === null || _category === void 0 ? void 0 : _category.name) || categoryId, ": ").concat(_t6.message));
            case 11:
              _context8.n = 4;
              break;
            case 12:
              _context8.n = 14;
              break;
            case 13:
              _context8.p = 13;
              _t7 = _context8.v;
              _iterator3.e(_t7);
            case 14:
              _context8.p = 14;
              _iterator3.f();
              return _context8.f(14);
            case 15:
              if (!(deleted > 0)) {
                _context8.n = 17;
                break;
              }
              OC.Notification.showTemporary("".concat(deleted, " categor").concat(deleted === 1 ? 'y' : 'ies', " deleted successfully"));
              this.selectedCategory = null;
              this.showCategoryDetailsEmpty();
              _context8.n = 16;
              return this.loadCategories();
            case 16:
              _context8.n = 17;
              return this.app.loadInitialData();
            case 17:
              if (errors.length > 0) {
                OC.Notification.showTemporary("Failed to delete: ".concat(errors.join(', ')));
              }
              this.updateBulkCategoryActions();
            case 18:
              return _context8.a(2);
          }
        }, _callee8, this, [[5, 10], [3, 13, 14, 15]]);
      }));
      function bulkDeleteCategories() {
        return _bulkDeleteCategories.apply(this, arguments);
      }
      return bulkDeleteCategories;
    }()
  }, {
    key: "clearCategorySelection",
    value: function clearCategorySelection() {
      this.selectedCategoryIds.clear();
      document.querySelectorAll('.category-checkbox').forEach(function (cb) {
        cb.checked = false;
      });
      document.querySelectorAll('.category-item.checked').forEach(function (item) {
        item.classList.remove('checked');
      });
      this.updateBulkCategoryActions();
    }
  }, {
    key: "selectAllCategories",
    value: function selectAllCategories() {
      var _this9 = this;
      var checkboxes = document.querySelectorAll('.category-checkbox');
      checkboxes.forEach(function (cb) {
        var categoryId = parseInt(cb.dataset.categoryId);
        cb.checked = true;
        _this9.selectedCategoryIds.add(categoryId);
        cb.closest('.category-item').classList.add('checked');
      });
      this.updateBulkCategoryActions();
    }
  }, {
    key: "resetCategoryForm",
    value: function resetCategoryForm() {
      var form = document.getElementById('category-form');
      if (form) {
        form.reset();
      }
      var categoryId = document.getElementById('category-id');
      if (categoryId) categoryId.value = '';
      var colorInput = document.getElementById('category-color');
      if (colorInput) colorInput.value = '#3b82f6';
    }
  }, {
    key: "loadCategoryData",
    value: function loadCategoryData(category) {
      document.getElementById('category-id').value = category.id;
      document.getElementById('category-name').value = category.name;
      document.getElementById('category-type').value = category.type;
      document.getElementById('category-parent').value = category.parentId || '';
      document.getElementById('category-color').value = category.color || '#3b82f6';

      // Load tag sets for this category
      this.app.renderCategoryTagSetsUI(category.id);
    }
  }, {
    key: "populateCategoryParentDropdown",
    value: function populateCategoryParentDropdown() {
      var _this0 = this;
      var excludeId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var parentSelect = document.getElementById('category-parent');
      if (!parentSelect) return;
      var typeSelect = document.getElementById('category-type');
      var currentType = typeSelect ? typeSelect.value : 'expense';
      parentSelect.innerHTML = '<option value="">None (Top Level)</option>';
      var _addOptions = function addOptions(categories) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        categories.forEach(function (cat) {
          // Only show categories of the same type, and exclude the current category and its children
          if (cat.type === currentType && cat.id !== excludeId) {
            parentSelect.innerHTML += "<option value=\"".concat(cat.id, "\">").concat(prefix).concat(_this0.escapeHtml(cat.name), "</option>");
          }
          if (cat.children && cat.children.length > 0) {
            _addOptions(cat.children, prefix + '  ');
          }
        });
      };
      if (this.allCategories) {
        _addOptions(this.allCategories);
      }
    }
  }, {
    key: "saveCategory",
    value: function () {
      var _saveCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
        var categoryId, name, type, parentId, color, categoryData, isEdit, url, method, response, savedCategory, categoryIdToSelect, error, _t8;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              categoryId = document.getElementById('category-id').value;
              name = document.getElementById('category-name').value.trim();
              type = document.getElementById('category-type').value;
              parentId = document.getElementById('category-parent').value || null;
              color = document.getElementById('category-color').value;
              if (name) {
                _context9.n = 1;
                break;
              }
              OC.Notification.showTemporary('Category name is required');
              return _context9.a(2);
            case 1:
              categoryData = {
                name: name,
                type: type,
                parentId: parentId ? parseInt(parentId) : null,
                color: color
              };
              _context9.p = 2;
              isEdit = !!categoryId;
              url = isEdit ? "/apps/budget/api/categories/".concat(categoryId) : '/apps/budget/api/categories';
              method = isEdit ? 'PUT' : 'POST';
              _context9.n = 3;
              return fetch(OC.generateUrl(url), {
                method: method,
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(categoryData)
              });
            case 3:
              response = _context9.v;
              if (!response.ok) {
                _context9.n = 7;
                break;
              }
              _context9.n = 4;
              return response.json();
            case 4:
              savedCategory = _context9.v;
              OC.Notification.showTemporary(isEdit ? 'Category updated successfully' : 'Category created successfully');
              this.app.hideModals();
              _context9.n = 5;
              return this.loadCategories();
            case 5:
              _context9.n = 6;
              return this.app.loadInitialData();
            case 6:
              // Re-select the category to update the details panel
              categoryIdToSelect = isEdit ? parseInt(categoryId) : savedCategory.id;
              if (categoryIdToSelect) {
                this.selectCategory(categoryIdToSelect);
              }
              _context9.n = 9;
              break;
            case 7:
              _context9.n = 8;
              return response.json();
            case 8:
              error = _context9.v;
              throw new Error(error.error || 'Failed to save category');
            case 9:
              _context9.n = 11;
              break;
            case 10:
              _context9.p = 10;
              _t8 = _context9.v;
              console.error('Failed to save category:', _t8);
              OC.Notification.showTemporary(_t8.message || 'Failed to save category');
            case 11:
              return _context9.a(2);
          }
        }, _callee9, this, [[2, 10]]);
      }));
      function saveCategory() {
        return _saveCategory.apply(this, arguments);
      }
      return saveCategory;
    }()
  }, {
    key: "createDefaultCategories",
    value: function () {
      var _createDefaultCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        var response, error, _t9;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              _context0.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/setup/initialize'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({})
              });
            case 1:
              response = _context0.v;
              if (!response.ok) {
                _context0.n = 4;
                break;
              }
              OC.Notification.showTemporary('Default categories created successfully');
              _context0.n = 2;
              return this.loadCategories();
            case 2:
              _context0.n = 3;
              return this.app.loadInitialData();
            case 3:
              _context0.n = 6;
              break;
            case 4:
              _context0.n = 5;
              return response.json();
            case 5:
              error = _context0.v;
              throw new Error(error.error || 'Failed to create default categories');
            case 6:
              _context0.n = 8;
              break;
            case 7:
              _context0.p = 7;
              _t9 = _context0.v;
              console.error('Failed to create default categories:', _t9);
              OC.Notification.showTemporary(_t9.message || 'Failed to create default categories');
            case 8:
              return _context0.a(2);
          }
        }, _callee0, this, [[0, 7]]);
      }));
      function createDefaultCategories() {
        return _createDefaultCategories.apply(this, arguments);
      }
      return createDefaultCategories;
    }() // ===================================
    // Budget View Methods
    // ===================================
  }, {
    key: "loadBudgetView",
    value: function () {
      var _loadBudgetView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
        var response, _t0;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              // Initialize budget state
              this.budgetType = this.budgetType || 'expense';
              this.budgetMonth = this.budgetMonth || new Date().toISOString().slice(0, 7); // YYYY-MM

              // Setup event listeners on first load
              if (!this.budgetEventListenersSetup) {
                this.setupBudgetEventListeners();
                this.budgetEventListenersSetup = true;
              }

              // Populate month selector
              this.populateBudgetMonthSelector();

              // Fetch categories if not already loaded
              if (!(!this.allCategories || this.allCategories.length === 0)) {
                _context1.n = 6;
                break;
              }
              _context1.p = 1;
              _context1.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/categories/tree'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context1.v;
              if (!response.ok) {
                _context1.n = 4;
                break;
              }
              _context1.n = 3;
              return response.json();
            case 3:
              this.categoryTree = _context1.v;
              this.allCategories = this.flattenCategories(this.categoryTree);
            case 4:
              _context1.n = 6;
              break;
            case 5:
              _context1.p = 5;
              _t0 = _context1.v;
              console.error('Failed to load categories for budget:', _t0);
            case 6:
              _context1.n = 7;
              return this.calculateCategorySpending();
            case 7:
              // Render the budget tree
              this.renderBudgetTree();

              // Update summary
              this.updateBudgetSummary();
            case 8:
              return _context1.a(2);
          }
        }, _callee1, this, [[1, 5]]);
      }));
      function loadBudgetView() {
        return _loadBudgetView.apply(this, arguments);
      }
      return loadBudgetView;
    }()
  }, {
    key: "setupBudgetEventListeners",
    value: function setupBudgetEventListeners() {
      var _this1 = this;
      // Budget type tabs
      document.querySelectorAll('.budget-tabs .tab-button').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          document.querySelectorAll('.budget-tabs .tab-button').forEach(function (b) {
            return b.classList.remove('active');
          });
          e.currentTarget.classList.add('active');
          _this1.budgetType = e.currentTarget.dataset.budgetType;
          _this1.renderBudgetTree();
          _this1.updateBudgetSummary();
        });
      });

      // Month selector
      var monthSelect = document.getElementById('budget-month');
      if (monthSelect) {
        monthSelect.addEventListener('change', /*#__PURE__*/function () {
          var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(e) {
            return _regenerator().w(function (_context10) {
              while (1) switch (_context10.n) {
                case 0:
                  _this1.budgetMonth = e.target.value;
                  _context10.n = 1;
                  return _this1.calculateCategorySpending();
                case 1:
                  _this1.renderBudgetTree();
                  _this1.updateBudgetSummary();
                case 2:
                  return _context10.a(2);
              }
            }, _callee10);
          }));
          return function (_x8) {
            return _ref.apply(this, arguments);
          };
        }());
      }

      // Go to categories button (empty state)
      var goToCategoriesBtn = document.getElementById('empty-budget-go-categories-btn');
      if (goToCategoriesBtn) {
        goToCategoriesBtn.addEventListener('click', function () {
          _this1.app.navigateTo('categories');
        });
      }
    }
  }, {
    key: "populateBudgetMonthSelector",
    value: function populateBudgetMonthSelector() {
      var _this10 = this;
      var monthSelect = document.getElementById('budget-month');
      if (!monthSelect) return;

      // Generate last 12 months + next 3 months
      var options = [];
      var now = new Date();
      for (var i = -12; i <= 3; i++) {
        var date = new Date(now.getFullYear(), now.getMonth() + i, 1);
        var value = date.toISOString().slice(0, 7);
        var label = date.toLocaleDateString('en-US', {
          month: 'long',
          year: 'numeric'
        });
        options.push({
          value: value,
          label: label
        });
      }
      monthSelect.innerHTML = options.map(function (opt) {
        return "<option value=\"".concat(opt.value, "\" ").concat(opt.value === _this10.budgetMonth ? 'selected' : '', ">").concat(opt.label, "</option>");
      }).join('');
    }
  }, {
    key: "calculateCategorySpending",
    value: function () {
      var _calculateCategorySpending = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var _this11 = this;
        var _this$budgetMonth$spl, _this$budgetMonth$spl2, year, month, startDate, endDate, startStr, endStr, response, spendingData, _t1;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              // Get date range for selected month
              _this$budgetMonth$spl = this.budgetMonth.split('-').map(Number), _this$budgetMonth$spl2 = _slicedToArray(_this$budgetMonth$spl, 2), year = _this$budgetMonth$spl2[0], month = _this$budgetMonth$spl2[1];
              startDate = new Date(year, month - 1, 1);
              endDate = new Date(year, month, 0); // Last day of month
              startStr = startDate.toISOString().split('T')[0];
              endStr = endDate.toISOString().split('T')[0]; // Fetch spending data from API
              _context11.p = 1;
              _context11.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/categories/spending?startDate=".concat(startStr, "&endDate=").concat(endStr)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context11.v;
              if (!response.ok) {
                _context11.n = 4;
                break;
              }
              _context11.n = 3;
              return response.json();
            case 3:
              spendingData = _context11.v;
              // Map spending to categories
              this.categorySpending = {};
              spendingData.forEach(function (item) {
                _this11.categorySpending[item.categoryId] = parseFloat(item.spent) || 0;
              });
            case 4:
              _context11.n = 6;
              break;
            case 5:
              _context11.p = 5;
              _t1 = _context11.v;
              console.error('Failed to fetch category spending:', _t1);
              this.categorySpending = {};
            case 6:
              // Also calculate from local transactions as fallback
              if (!this.categorySpending || Object.keys(this.categorySpending).length === 0) {
                this.categorySpending = {};
                (this.transactions || []).forEach(function (t) {
                  if (!t.categoryId) return;
                  var txDate = new Date(t.date);
                  if (txDate >= startDate && txDate <= endDate) {
                    var amount = Math.abs(parseFloat(t.amount) || 0);
                    _this11.categorySpending[t.categoryId] = (_this11.categorySpending[t.categoryId] || 0) + amount;
                  }
                });
              }
            case 7:
              return _context11.a(2);
          }
        }, _callee11, this, [[1, 5]]);
      }));
      function calculateCategorySpending() {
        return _calculateCategorySpending.apply(this, arguments);
      }
      return calculateCategorySpending;
    }()
  }, {
    key: "renderBudgetTree",
    value: function renderBudgetTree() {
      var _this12 = this;
      var treeContainer = document.getElementById('budget-tree');
      var emptyState = document.getElementById('empty-budget');
      var headerEl = document.querySelector('.budget-tree-header');
      if (!treeContainer) return;

      // Filter categories by type
      var filteredCategories = (this.categoryTree || []).filter(function (cat) {
        return cat.type === _this12.budgetType;
      });
      if (filteredCategories.length === 0) {
        treeContainer.innerHTML = '';
        if (headerEl) headerEl.style.display = 'none';
        if (emptyState) emptyState.style.display = 'block';
        return;
      }
      if (headerEl) headerEl.style.display = 'grid';
      if (emptyState) emptyState.style.display = 'none';
      treeContainer.innerHTML = this.renderBudgetCategoryNodes(filteredCategories, 0);

      // Setup inline editing listeners
      this.setupBudgetInlineEditing();
    }
  }, {
    key: "renderBudgetCategoryNodes",
    value: function renderBudgetCategoryNodes(categories) {
      var _this13 = this;
      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return categories.map(function (category) {
        var hasChildren = category.children && category.children.length > 0;
        var spent = _this13.categorySpending[category.id] || 0;
        var budget = parseFloat(category.budgetAmount) || 0;
        var remaining = budget - spent;
        var percentage = budget > 0 ? Math.min(spent / budget * 100, 100) : 0;
        var progressStatus = 'good';
        if (percentage >= 100) progressStatus = 'over';else if (percentage >= 80) progressStatus = 'danger';else if (percentage >= 60) progressStatus = 'warning';
        var remainingClass = remaining > 0 ? 'positive' : remaining < 0 ? 'negative' : 'zero';
        return "\n                <div class=\"budget-category-row ".concat(hasChildren ? 'parent-row' : '', "\" data-category-id=\"").concat(category.id, "\">\n                    <div class=\"budget-category-name level-").concat(level, "\" data-label=\"\">\n                        <span class=\"category-color\" style=\"background-color: ").concat(category.color || '#3b82f6', "\"></span>\n                        <span class=\"category-label\">").concat(category.name, "</span>\n                    </div>\n                    <div class=\"budget-input-wrapper\" data-label=\"Budget\">\n                        <input type=\"number\"\n                               class=\"budget-input\"\n                               data-category-id=\"").concat(category.id, "\"\n                               value=\"").concat(budget || '', "\"\n                               placeholder=\"0.00\"\n                               step=\"0.01\"\n                               min=\"0\">\n                    </div>\n                    <div data-label=\"Period\">\n                        <select class=\"budget-period-select\" data-category-id=\"").concat(category.id, "\">\n                            <option value=\"monthly\" ").concat(category.budgetPeriod === 'monthly' || !category.budgetPeriod ? 'selected' : '', ">Monthly</option>\n                            <option value=\"weekly\" ").concat(category.budgetPeriod === 'weekly' ? 'selected' : '', ">Weekly</option>\n                            <option value=\"quarterly\" ").concat(category.budgetPeriod === 'quarterly' ? 'selected' : '', ">Quarterly</option>\n                            <option value=\"yearly\" ").concat(category.budgetPeriod === 'yearly' ? 'selected' : '', ">Yearly</option>\n                        </select>\n                    </div>\n                    <div class=\"budget-spent\" data-label=\"Spent\">\n                        ").concat(_this13.formatCurrency(spent), "\n                    </div>\n                    <div class=\"budget-remaining ").concat(remainingClass, "\" data-label=\"Remaining\">\n                        ").concat(budget > 0 ? _this13.formatCurrency(remaining) : '<span class="no-budget"></span>', "\n                    </div>\n                    <div class=\"budget-progress-wrapper\" data-label=\"Progress\">\n                        ").concat(budget > 0 ? "\n                            <div class=\"budget-progress-bar\">\n                                <div class=\"budget-progress-fill ".concat(progressStatus, "\" style=\"width: ").concat(percentage, "%\"></div>\n                            </div>\n                            <span class=\"budget-progress-text\">").concat(Math.round(percentage), "%</span>\n                        ") : '<span class="no-budget">No budget set</span>', "\n                    </div>\n                </div>\n                ").concat(hasChildren ? _this13.renderBudgetCategoryNodes(category.children, level + 1) : '', "\n            ");
      }).join('');
    }
  }, {
    key: "setupBudgetInlineEditing",
    value: function setupBudgetInlineEditing() {
      var _this14 = this;
      // Budget amount inputs
      document.querySelectorAll('.budget-input').forEach(function (input) {
        var debounceTimer;
        input.addEventListener('change', function (e) {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(function () {
            _this14.saveCategoryBudget(e.target.dataset.categoryId, {
              budgetAmount: e.target.value || null
            });
          }, 300);
        });
      });

      // Period selects
      document.querySelectorAll('.budget-period-select').forEach(function (select) {
        select.addEventListener('change', function (e) {
          _this14.saveCategoryBudget(e.target.dataset.categoryId, {
            budgetPeriod: e.target.value
          });
        });
      });
    }
  }, {
    key: "saveCategoryBudget",
    value: function () {
      var _saveCategoryBudget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(categoryId, updates) {
        var response, category, errorMessage, errorData, _t10, _t11;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.p = _context12.n) {
            case 0:
              _context12.p = 0;
              // Convert empty string or null to 0 for budgetAmount
              if ('budgetAmount' in updates && (updates.budgetAmount === null || updates.budgetAmount === '')) {
                updates.budgetAmount = 0;
              } else if ('budgetAmount' in updates) {
                updates.budgetAmount = parseFloat(updates.budgetAmount) || 0;
              }
              _context12.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/categories/".concat(categoryId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(updates)
              });
            case 1:
              response = _context12.v;
              if (!response.ok) {
                _context12.n = 2;
                break;
              }
              // Update local data
              category = this.findCategoryById(parseInt(categoryId));
              if (category) {
                Object.assign(category, updates);
              }

              // Re-render to update calculations
              this.renderBudgetTree();
              this.updateBudgetSummary();
              OC.Notification.showTemporary('Budget updated');
              _context12.n = 7;
              break;
            case 2:
              // Try to get detailed error message
              errorMessage = 'Failed to update budget';
              _context12.p = 3;
              _context12.n = 4;
              return response.json();
            case 4:
              errorData = _context12.v;
              if (errorData.error) {
                errorMessage = errorData.error;
              }
              _context12.n = 6;
              break;
            case 5:
              _context12.p = 5;
              _t10 = _context12.v;
              errorMessage = "HTTP ".concat(response.status, ": ").concat(response.statusText);
            case 6:
              throw new Error(errorMessage);
            case 7:
              _context12.n = 9;
              break;
            case 8:
              _context12.p = 8;
              _t11 = _context12.v;
              console.error('Failed to save budget:', _t11);
              OC.Notification.showTemporary("Failed to update budget: ".concat(_t11.message));
            case 9:
              return _context12.a(2);
          }
        }, _callee12, this, [[3, 5], [0, 8]]);
      }));
      function saveCategoryBudget(_x9, _x0) {
        return _saveCategoryBudget.apply(this, arguments);
      }
      return saveCategoryBudget;
    }()
  }, {
    key: "updateBudgetSummary",
    value: function updateBudgetSummary() {
      var _this15 = this;
      var categories = this.flattenCategories(this.categoryTree || []).filter(function (cat) {
        return cat.type === _this15.budgetType;
      });
      var totalBudgeted = 0;
      var totalSpent = 0;
      var categoriesWithBudget = 0;
      categories.forEach(function (cat) {
        var budget = parseFloat(cat.budgetAmount) || 0;
        var spent = _this15.categorySpending[cat.id] || 0;
        if (budget > 0) {
          totalBudgeted += budget;
          categoriesWithBudget++;
        }
        totalSpent += spent;
      });
      var totalRemaining = totalBudgeted - totalSpent;

      // Update DOM
      var budgetedEl = document.getElementById('budget-total-budgeted');
      var spentEl = document.getElementById('budget-total-spent');
      var remainingEl = document.getElementById('budget-total-remaining');
      var countEl = document.getElementById('budget-categories-count');
      if (budgetedEl) budgetedEl.textContent = this.formatCurrency(totalBudgeted);
      if (spentEl) spentEl.textContent = this.formatCurrency(totalSpent);
      if (remainingEl) remainingEl.textContent = this.formatCurrency(totalRemaining);
      if (countEl) countEl.textContent = categoriesWithBudget;
    }
  }, {
    key: "flattenCategories",
    value: function flattenCategories(categories) {
      var _this16 = this;
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      categories.forEach(function (cat) {
        result.push(cat);
        if (cat.children && cat.children.length > 0) {
          _this16.flattenCategories(cat.children, result);
        }
      });
      return result;
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/dashboard/DashboardModule.js":
/*!**************************************************!*\
  !*** ./src/modules/dashboard/DashboardModule.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DashboardModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
/* harmony import */ var chart_js_auto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.js");
/* harmony import */ var _config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config/dashboardWidgets.js */ "./src/config/dashboardWidgets.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * DashboardModule - Handles all dashboard-related functionality
 *
 * This module manages:
 * - Loading and displaying dashboard data
 * - Hero tiles (Net Worth, Income, Expenses, Savings)
 * - Dashboard widgets (accounts, transactions, charts, alerts, etc.)
 * - Dashboard customization (drag & drop, show/hide tiles)
 * - Chart rendering (spending, trends, net worth history)
 */





var DashboardModule = /*#__PURE__*/function () {
  function DashboardModule(app) {
    _classCallCheck(this, DashboardModule);
    this.app = app;
  }

  // State proxies
  return _createClass(DashboardModule, [{
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "charts",
    get: function get() {
      return this.app.charts;
    }
  }, {
    key: "dashboardConfig",
    get: function get() {
      return this.app.dashboardConfig;
    }
  }, {
    key: "dashboardLocked",
    get: function get() {
      return this.app.dashboardLocked;
    },
    set: function set(value) {
      this.app.dashboardLocked = value;
    }
  }, {
    key: "widgetDataLoaded",
    get: function get() {
      return this.app.widgetDataLoaded;
    }
  }, {
    key: "widgetData",
    get: function get() {
      return this.app.widgetData;
    }
  }, {
    key: "savingsGoals",
    get: function get() {
      return this.app.savingsGoals;
    }

    // Helper proxies
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount, currency) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(dateStr) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(dateStr, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return this.app.getPrimaryCurrency();
    }

    // ===========================
    // Main Dashboard Load
    // ===========================
  }, {
    key: "loadDashboard",
    value: function () {
      var _loadDashboard = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var now, startOfMonth, endOfMonth, sixMonthsAgo, _yield$Promise$all, _yield$Promise$all2, summaryResponse, trendResponse, transResponse, billsResponse, budgetResponse, goalsResponse, pensionResponse, netWorthResponse, alertsResponse, debtResponse, summary, trendData, transactions, bills, budgetDataRaw, budgetData, savingsGoals, pensionSummary, netWorthSnapshots, budgetAlerts, debtSummary, _t, _t2, _t3, _t4, _t5, _t6, _t7, _t8;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              // Calculate current month date range for hero stats
              now = new Date();
              startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
              endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0]; // Calculate 6-month range for trend charts
              sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 5, 1).toISOString().split('T')[0]; // Load all dashboard data in parallel for better performance
              _context.n = 1;
              return Promise.all([
              // Current month summary for hero stats
              fetch(OC.generateUrl("/apps/budget/api/reports/summary?startDate=".concat(startOfMonth, "&endDate=").concat(endOfMonth)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              }),
              // 6-month summary for trend charts
              fetch(OC.generateUrl("/apps/budget/api/reports/summary?startDate=".concat(sixMonthsAgo, "&endDate=").concat(endOfMonth)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              }), fetch(OC.generateUrl('/apps/budget/api/transactions?limit=8'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              }), fetch(OC.generateUrl('/apps/budget/api/bills/upcoming'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/reports/budget'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/savings-goals'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/pensions/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/net-worth/snapshots?days=30'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/alerts'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              }), fetch(OC.generateUrl('/apps/budget/api/debts/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })["catch"](function () {
                return {
                  ok: false
                };
              })]);
            case 1:
              _yield$Promise$all = _context.v;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 10);
              summaryResponse = _yield$Promise$all2[0];
              trendResponse = _yield$Promise$all2[1];
              transResponse = _yield$Promise$all2[2];
              billsResponse = _yield$Promise$all2[3];
              budgetResponse = _yield$Promise$all2[4];
              goalsResponse = _yield$Promise$all2[5];
              pensionResponse = _yield$Promise$all2[6];
              netWorthResponse = _yield$Promise$all2[7];
              alertsResponse = _yield$Promise$all2[8];
              debtResponse = _yield$Promise$all2[9];
              _context.n = 2;
              return summaryResponse.json();
            case 2:
              summary = _context.v;
              _context.n = 3;
              return trendResponse.json();
            case 3:
              trendData = _context.v;
              _context.n = 4;
              return transResponse.json();
            case 4:
              transactions = _context.v;
              if (!billsResponse.ok) {
                _context.n = 6;
                break;
              }
              _context.n = 5;
              return billsResponse.json();
            case 5:
              _t = _context.v;
              _context.n = 7;
              break;
            case 6:
              _t = [];
            case 7:
              bills = _t;
              if (!budgetResponse.ok) {
                _context.n = 9;
                break;
              }
              _context.n = 8;
              return budgetResponse.json();
            case 8:
              _t2 = _context.v;
              _context.n = 10;
              break;
            case 9:
              _t2 = null;
            case 10:
              budgetDataRaw = _t2;
              budgetData = budgetDataRaw && _typeof(budgetDataRaw) === 'object' ? budgetDataRaw : {
                categories: []
              };
              if (!goalsResponse.ok) {
                _context.n = 12;
                break;
              }
              _context.n = 11;
              return goalsResponse.json();
            case 11:
              _t3 = _context.v;
              _context.n = 13;
              break;
            case 12:
              _t3 = [];
            case 13:
              savingsGoals = _t3;
              if (!pensionResponse.ok) {
                _context.n = 15;
                break;
              }
              _context.n = 14;
              return pensionResponse.json();
            case 14:
              _t4 = _context.v;
              _context.n = 16;
              break;
            case 15:
              _t4 = {
                totalPensionWorth: 0,
                pensionCount: 0
              };
            case 16:
              pensionSummary = _t4;
              if (!netWorthResponse.ok) {
                _context.n = 18;
                break;
              }
              _context.n = 17;
              return netWorthResponse.json();
            case 17:
              _t5 = _context.v;
              _context.n = 19;
              break;
            case 18:
              _t5 = [];
            case 19:
              netWorthSnapshots = _t5;
              if (!alertsResponse.ok) {
                _context.n = 21;
                break;
              }
              _context.n = 20;
              return alertsResponse.json();
            case 20:
              _t6 = _context.v;
              _context.n = 22;
              break;
            case 21:
              _t6 = [];
            case 22:
              budgetAlerts = _t6;
              if (!debtResponse.ok) {
                _context.n = 24;
                break;
              }
              _context.n = 23;
              return debtResponse.json();
            case 23:
              _t7 = _context.v;
              _context.n = 25;
              break;
            case 24:
              _t7 = null;
            case 25:
              debtSummary = _t7;
              // Update Hero Section (current month data)
              this.updateDashboardHero(summary);

              // Update Account Widget (current balances from current month summary)
              this.updateAccountsWidget(summary.accounts || []);

              // Update Budget Alerts Widget
              this.updateBudgetAlertsWidget(budgetAlerts);

              // Update Recent Transactions
              this.updateRecentTransactions(transactions);

              // Update Upcoming Bills Widget
              this.updateUpcomingBillsWidget(bills);

              // Update Budget Progress Widget
              this.updateBudgetProgressWidget(budgetData.categories || []);

              // Update Savings Goals Widget
              this.updateSavingsGoalsWidget(savingsGoals);

              // Update Pension Dashboard Card
              this.updatePensionsSummary(pensionSummary);

              // Update Debt Payoff Dashboard Card
              this.updateDebtPayoffWidget(debtSummary);

              // Phase 1: Update New Hero Tiles (use existing data)
              this.updateSavingsRateHero(summary);
              this.updateCashFlowHero(summary);
              this.updateBudgetRemainingHero(budgetData);
              this.updateBudgetHealthHero(budgetAlerts);

              // Phase 1: Update New Widget Tiles (use existing data)
              if (trendData.spending) {
                this.updateTopCategoriesWidget(trendData.spending);
              }
              this.updateAccountPerformanceWidget(summary.accounts || []);
              this.updateBudgetBreakdownWidget(budgetData.categories || []);
              this.updateGoalsSummaryWidget(savingsGoals);
              this.updatePaymentBreakdownWidget(summary.accounts || []);
              this.updateReconciliationStatusWidget(summary.accounts || []);

              // Update Charts (using 6-month trend data)
              if (trendData.spending) {
                this.updateSpendingChart(trendData.spending);
              }
              if (trendData.trends) {
                this.updateTrendChart(trendData.trends);
              }

              // Update Net Worth History Chart
              this.updateNetWorthHistoryChart(netWorthSnapshots);

              // Setup dashboard controls
              this.setupDashboardControls();

              // Apply dashboard widget order (must be before visibility)
              this.applyDashboardOrder();

              // Apply dashboard widget visibility
              this.applyDashboardVisibility();

              // Setup drag-and-drop for dashboard customization
              this.setupDashboardDragAndDrop();

              // Apply responsive layout ordering
              this.applyDashboardLayout();
              _context.n = 27;
              break;
            case 26:
              _context.p = 26;
              _t8 = _context.v;
              console.error('Failed to load dashboard:', _t8);
            case 27:
              return _context.a(2);
          }
        }, _callee, this, [[0, 26]]);
      }));
      function loadDashboard() {
        return _loadDashboard.apply(this, arguments);
      }
      return loadDashboard;
    }() // ===========================
    // Hero Tile Updates
    // ===========================
  }, {
    key: "updateDashboardHero",
    value: function updateDashboardHero(summary) {
      var totals = summary.totals || {};
      var currency = this.getPrimaryCurrency();

      // Net Worth (total balance across all accounts)
      var netWorthEl = document.getElementById('hero-net-worth-value');
      if (netWorthEl) {
        var netWorth = totals.currentBalance || 0;
        netWorthEl.textContent = this.formatCurrency(netWorth, currency);
        netWorthEl.className = "hero-value ".concat(netWorth >= 0 ? '' : 'expenses');
      }

      // Income This Month
      var incomeEl = document.getElementById('hero-income-value');
      if (incomeEl) {
        incomeEl.textContent = this.formatCurrency(totals.totalIncome || 0, currency);
      }

      // Calculate month-over-month change for income
      var incomeChangeEl = document.getElementById('hero-income-change');
      if (incomeChangeEl && summary.trends && summary.trends.income) {
        var incomeData = summary.trends.income;
        if (incomeData.length >= 2) {
          var currentMonth = incomeData[incomeData.length - 1] || 0;
          var lastMonth = incomeData[incomeData.length - 2] || 0;
          var change = lastMonth > 0 ? (currentMonth - lastMonth) / lastMonth * 100 : 0;
          if (change !== 0) {
            incomeChangeEl.innerHTML = "".concat(change >= 0 ? '' : '', " ").concat(Math.abs(change).toFixed(1), "% vs last month");
            incomeChangeEl.className = "hero-change ".concat(change >= 0 ? 'positive' : 'negative');
          }
        }
      }

      // Expenses This Month
      var expensesEl = document.getElementById('hero-expenses-value');
      if (expensesEl) {
        expensesEl.textContent = this.formatCurrency(totals.totalExpenses || 0, currency);
      }

      // Calculate month-over-month change for expenses
      var expensesChangeEl = document.getElementById('hero-expenses-change');
      if (expensesChangeEl && summary.trends && summary.trends.expenses) {
        var expenseData = summary.trends.expenses;
        if (expenseData.length >= 2) {
          var _currentMonth = expenseData[expenseData.length - 1] || 0;
          var _lastMonth = expenseData[expenseData.length - 2] || 0;
          var _change = _lastMonth > 0 ? (_currentMonth - _lastMonth) / _lastMonth * 100 : 0;
          if (_change !== 0) {
            // For expenses, down is good
            expensesChangeEl.innerHTML = "".concat(_change >= 0 ? '' : '', " ").concat(Math.abs(_change).toFixed(1), "% vs last month");
            expensesChangeEl.className = "hero-change ".concat(_change <= 0 ? 'positive' : 'negative');
          }
        }
      }

      // Net Savings
      var savingsEl = document.getElementById('hero-savings-value');
      var savingsRateEl = document.getElementById('hero-savings-rate');
      if (savingsEl) {
        var netSavings = (totals.totalIncome || 0) - (totals.totalExpenses || 0);
        savingsEl.textContent = this.formatCurrency(netSavings, currency);
        savingsEl.className = "hero-value ".concat(netSavings >= 0 ? 'income' : 'expenses');

        // Savings rate
        if (savingsRateEl && totals.totalIncome > 0) {
          var savingsRate = netSavings / totals.totalIncome * 100;
          savingsRateEl.textContent = "".concat(savingsRate >= 0 ? '' : '-').concat(Math.abs(savingsRate).toFixed(1), "% savings rate");
        }
      }
    }
  }, {
    key: "updateSavingsRateHero",
    value: function updateSavingsRateHero(summary) {
      var el = document.getElementById('hero-savings-rate-value');
      if (!el || !(summary !== null && summary !== void 0 && summary.totals)) return;
      var income = summary.totals.totalIncome || 0;
      var savings = summary.totals.netSavings || income - (summary.totals.totalExpenses || 0);
      var rate = income > 0 ? savings / income * 100 : 0;
      el.textContent = "".concat(rate.toFixed(1), "%");
      el.className = "hero-value ".concat(rate >= 0 ? 'income' : 'expenses');
      var changeEl = document.getElementById('hero-savings-rate-change');
      if (changeEl) {
        var trend = rate >= 20 ? 'positive' : rate >= 10 ? 'neutral' : 'negative';
        var icon = rate >= 20 ? '' : rate >= 10 ? '' : '';
        changeEl.innerHTML = "<span class=\"trend-icon ".concat(trend, "\">").concat(icon, " ").concat(rate >= 20 ? 'Great' : rate >= 10 ? 'Good' : 'Low', "</span>");
        changeEl.className = "hero-change ".concat(trend);
      }
    }
  }, {
    key: "updateCashFlowHero",
    value: function updateCashFlowHero(summary) {
      var el = document.getElementById('hero-cash-flow-value');
      if (!el || !(summary !== null && summary !== void 0 && summary.totals)) return;
      var income = summary.totals.totalIncome || 0;
      var expenses = summary.totals.totalExpenses || 0;
      var cashFlow = income - expenses;
      el.textContent = this.formatCurrency(cashFlow, this.getPrimaryCurrency());
      el.className = "hero-value ".concat(cashFlow >= 0 ? 'income' : 'expenses');
      var changeEl = document.getElementById('hero-cash-flow-change');
      if (changeEl && summary.trends) {
        // Calculate month-over-month change
        var incomeData = summary.trends.income || [];
        var expenseData = summary.trends.expenses || [];
        if (incomeData.length >= 2 && expenseData.length >= 2) {
          var currentCF = (incomeData[incomeData.length - 1] || 0) - (expenseData[expenseData.length - 1] || 0);
          var lastCF = (incomeData[incomeData.length - 2] || 0) - (expenseData[expenseData.length - 2] || 0);
          var change = lastCF !== 0 ? (currentCF - lastCF) / Math.abs(lastCF) * 100 : 0;
          if (change !== 0) {
            changeEl.innerHTML = "".concat(change >= 0 ? '' : '', " ").concat(Math.abs(change).toFixed(1), "% vs last month");
            changeEl.className = "hero-change ".concat(change >= 0 ? 'positive' : 'negative');
          }
        }
      }
    }
  }, {
    key: "updateBudgetRemainingHero",
    value: function updateBudgetRemainingHero(budgetData) {
      var el = document.getElementById('hero-budget-remaining-value');
      if (!el) return;
      if (!budgetData || !budgetData.categories || budgetData.categories.length === 0) {
        el.textContent = '--';
        return;
      }
      var totalRemaining = budgetData.categories.reduce(function (sum, cat) {
        var remaining = (cat.budget || 0) - (cat.spent || 0);
        return sum + (remaining > 0 ? remaining : 0);
      }, 0);
      el.textContent = this.formatCurrency(totalRemaining, this.getPrimaryCurrency());
      el.className = "hero-value ".concat(totalRemaining >= 0 ? 'income' : 'expenses');
      var changeEl = document.getElementById('hero-budget-remaining-change');
      if (changeEl) {
        var categoryCount = budgetData.categories.filter(function (c) {
          return (c.budget || 0) - (c.spent || 0) > 0;
        }).length;
        changeEl.textContent = "".concat(categoryCount, " categories under budget");
      }
    }
  }, {
    key: "updateBudgetHealthHero",
    value: function updateBudgetHealthHero(budgetAlerts) {
      var el = document.getElementById('hero-budget-health-value');
      if (!el) return;

      // Get total number of budget categories from the existing budget progress widget
      var budgetProgressContainer = document.getElementById('budget-progress-categories');
      var totalBudgets = budgetProgressContainer ? budgetProgressContainer.querySelectorAll('.budget-category-item').length : 0;
      if (totalBudgets === 0) {
        el.textContent = '--';
        return;
      }
      var alertCount = Array.isArray(budgetAlerts) ? budgetAlerts.length : 0;
      var onTrack = Math.max(totalBudgets - alertCount, 0);
      var healthScore = onTrack / totalBudgets * 100;
      el.textContent = "".concat(healthScore.toFixed(0), "%");
      el.className = "hero-value ".concat(healthScore >= 75 ? 'income' : healthScore >= 50 ? '' : 'expenses');
      var changeEl = document.getElementById('hero-budget-health-change');
      if (changeEl) {
        changeEl.textContent = "".concat(onTrack, "/").concat(totalBudgets, " on track");
      }
    }

    // ===========================
    // Widget Updates
    // ===========================
  }, {
    key: "updateAccountsWidget",
    value: function updateAccountsWidget(accounts) {
      var _this = this;
      var container = document.getElementById('accounts-summary');
      if (!container || !Array.isArray(accounts)) return;
      if (accounts.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No accounts yet</div>';
        return;
      }
      var accountTypeIcons = {
        checking: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>',
        savings: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.5 3.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2v14H3v3c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2v-3h-3V2l-1.5 1.5zM19 19H5v-1h14v1z"/></svg>',
        credit_card: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>',
        investment: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>',
        cash: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16z"/></svg>',
        loan: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 14V6c0-1.1-.9-2-2-2H3C1.9 4 1 4.9 1 6v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zm-2 0H3V6h14v8zm-7-7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm13 0v11c0 1.1-.9 2-2 2H4v-2h17V7h2z"/></svg>'
      };
      container.innerHTML = accounts.slice(0, 5).map(function (account) {
        var type = account.type || 'checking';
        var balance = parseFloat(account.balance) || 0;
        var currency = account.currency || _this.getPrimaryCurrency();
        var icon = accountTypeIcons[type] || accountTypeIcons.checking;
        return "\n                <div class=\"account-widget-item\" data-account-id=\"".concat(account.id, "\">\n                    <div class=\"account-widget-info\">\n                        <div class=\"account-widget-icon\">").concat(icon, "</div>\n                        <div>\n                            <div class=\"account-widget-name\">").concat(_this.escapeHtml(account.name), "</div>\n                            <div class=\"account-widget-type\">").concat(type.replace('_', ' '), "</div>\n                        </div>\n                    </div>\n                    <div class=\"account-widget-balance\">\n                        <div class=\"account-widget-amount ").concat(balance >= 0 ? 'positive' : 'negative', "\">\n                            ").concat(_this.formatCurrency(balance, currency), "\n                        </div>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateRecentTransactions",
    value: function updateRecentTransactions(transactions) {
      var _this2 = this;
      var container = document.getElementById('recent-transactions');
      if (!container) return;
      if (!Array.isArray(transactions) || transactions.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No recent transactions</div>';
        return;
      }
      container.innerHTML = transactions.slice(0, 8).map(function (tx) {
        var isCredit = tx.type === 'credit';
        var amount = parseFloat(tx.amount) || 0;
        var category = _this2.categories.find(function (c) {
          return c.id === tx.categoryId || c.id === tx.category_id;
        });
        var categoryName = category ? category.name : 'Uncategorized';
        var categoryColor = category ? category.color : '#999';
        var date = tx.date ? _this2.formatDate(tx.date) : '';
        return "\n                <div class=\"recent-transaction-item\">\n                    <div class=\"recent-transaction-info\">\n                        <div class=\"recent-transaction-icon ".concat(isCredit ? 'income' : 'expense', "\">\n                            ").concat(isCredit ? '<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>' : '<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z"/></svg>', "\n                        </div>\n                        <div class=\"recent-transaction-details\">\n                            <div class=\"recent-transaction-description\">").concat(_this2.escapeHtml(tx.description || tx.vendor || 'Transaction'), "</div>\n                            <div class=\"recent-transaction-meta\">\n                                <span>").concat(date, "</span>\n                                <span class=\"recent-transaction-category\">\n                                    <span class=\"recent-transaction-category-dot\" style=\"background: ").concat(categoryColor, "\"></span>\n                                    ").concat(_this2.escapeHtml(categoryName), "\n                                </span>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"recent-transaction-amount ").concat(isCredit ? 'credit' : 'debit', "\">\n                        ").concat(isCredit ? '+' : '-').concat(_this2.formatCurrency(amount), "\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateBudgetAlertsWidget",
    value: function updateBudgetAlertsWidget(alerts) {
      var _this3 = this;
      var card = document.getElementById('budget-alerts-card');
      var container = document.getElementById('budget-alerts');
      if (!card || !container) return;

      // Hide the card if no alerts
      if (!Array.isArray(alerts) || alerts.length === 0) {
        card.style.display = 'none';
        return;
      }

      // Show the card
      card.style.display = '';
      var currency = this.getPrimaryCurrency();
      container.innerHTML = alerts.map(function (alert) {
        var severityClass = alert.severity === 'danger' ? 'alert-danger' : 'alert-warning';
        var severityIcon = alert.severity === 'danger' ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 21h22L12 2zm0 3.83L19.53 19H4.47L12 5.83zM11 10v4h2v-4h-2zm0 6v2h2v-2h-2z"/></svg>' : '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>';
        var percentDisplay = alert.percentage >= 100 ? "".concat(Math.round(alert.percentage - 100), "% over") : "".concat(Math.round(alert.percentage), "% used");
        return "\n                <div class=\"budget-alert-item ".concat(severityClass, "\">\n                    <div class=\"alert-icon\">").concat(severityIcon, "</div>\n                    <div class=\"alert-content\">\n                        <div class=\"alert-category\">").concat(_this3.escapeHtml(alert.categoryName), "</div>\n                        <div class=\"alert-progress\">\n                            <div class=\"alert-progress-bar\">\n                                <div class=\"alert-progress-fill ").concat(severityClass, "\" style=\"width: ").concat(Math.min(100, alert.percentage), "%\"></div>\n                            </div>\n                            <span class=\"alert-percent\">").concat(percentDisplay, "</span>\n                        </div>\n                        <div class=\"alert-amounts\">\n                            <span class=\"alert-spent\">").concat(_this3.formatCurrency(alert.spent, currency), "</span>\n                            <span class=\"alert-separator\">/</span>\n                            <span class=\"alert-budget\">").concat(_this3.formatCurrency(alert.budgetAmount, currency), "</span>\n                        </div>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateDebtPayoffWidget",
    value: function updateDebtPayoffWidget(summary) {
      var card = document.getElementById('debt-payoff-card');
      if (!card) return;

      // Hide the card if no debt
      if (!summary || summary.debtCount === 0) {
        card.style.display = 'none';
        return;
      }
      card.style.display = '';
      var currency = this.getPrimaryCurrency();

      // Update summary stats
      var totalEl = document.getElementById('debt-total-balance');
      var countEl = document.getElementById('debt-account-count');
      var minEl = document.getElementById('debt-minimum-payment');
      var estimateEl = document.getElementById('debt-payoff-estimate');
      if (totalEl) totalEl.textContent = this.formatCurrency(summary.totalBalance, currency);
      if (countEl) countEl.textContent = summary.debtCount.toString();
      if (minEl) minEl.textContent = this.formatCurrency(summary.totalMinimumPayment, currency);

      // Show payoff estimate if available
      if (estimateEl) {
        if (summary.highestInterestRate > 0) {
          estimateEl.innerHTML = "<span class=\"debt-hint\">Highest rate: ".concat(summary.highestInterestRate.toFixed(1), "% APR</span>");
        } else {
          estimateEl.innerHTML = '';
        }
      }
    }
  }, {
    key: "updateUpcomingBillsWidget",
    value: function updateUpcomingBillsWidget(bills) {
      var _this4 = this;
      var container = document.getElementById('upcoming-bills');
      if (!container) return;
      if (!Array.isArray(bills) || bills.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No upcoming bills</div>';
        return;
      }
      var today = new Date();
      today.setHours(0, 0, 0, 0);
      container.innerHTML = bills.slice(0, 5).map(function (bill) {
        var dueDate = new Date(bill.nextDueDate || bill.next_due_date);
        var daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
        var statusClass = '';
        var dueText = '';
        if (daysUntilDue < 0) {
          statusClass = 'overdue';
          dueText = "Overdue by ".concat(Math.abs(daysUntilDue), " day").concat(Math.abs(daysUntilDue) !== 1 ? 's' : '');
        } else if (daysUntilDue === 0) {
          statusClass = 'due-soon';
          dueText = 'Due today';
        } else if (daysUntilDue <= 7) {
          statusClass = 'due-soon';
          dueText = "Due in ".concat(daysUntilDue, " day").concat(daysUntilDue !== 1 ? 's' : '');
        } else {
          dueText = "Due ".concat(dueDate.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
          }));
        }
        return "\n                <div class=\"bill-widget-item ".concat(statusClass, "\">\n                    <div class=\"bill-widget-info\">\n                        <div class=\"bill-widget-name\">").concat(_this4.escapeHtml(bill.name), "</div>\n                        <div class=\"bill-widget-due ").concat(statusClass, "\">").concat(dueText, "</div>\n                    </div>\n                    <div class=\"bill-widget-amount\">").concat(_this4.formatCurrency(bill.amount), "</div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateBudgetProgressWidget",
    value: function updateBudgetProgressWidget(categories) {
      var _this5 = this;
      var container = document.getElementById('budget-progress');
      if (!container) return;
      if (!Array.isArray(categories) || categories.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No budgets configured</div>';
        return;
      }

      // Filter to only categories with budgets
      var budgetedCategories = categories.filter(function (c) {
        return c.budgeted > 0 || c.budget > 0;
      });
      if (budgetedCategories.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No budgets configured</div>';
        return;
      }
      container.innerHTML = budgetedCategories.slice(0, 5).map(function (cat) {
        var budgeted = cat.budgeted || cat.budget || 0;
        var spent = cat.spent || 0;
        var percentage = budgeted > 0 ? Math.min(spent / budgeted * 100, 100) : 0;
        var actualPercentage = budgeted > 0 ? spent / budgeted * 100 : 0;
        var statusClass = 'good';
        if (actualPercentage > 100) statusClass = 'over';else if (actualPercentage > 80) statusClass = 'danger';else if (actualPercentage > 50) statusClass = 'warning';
        var color = cat.color || '#0082c9';
        return "\n                <div class=\"budget-widget-item\">\n                    <div class=\"budget-widget-header\">\n                        <div class=\"budget-widget-name\">\n                            <span class=\"budget-widget-color\" style=\"background: ".concat(color, "\"></span>\n                            ").concat(_this5.escapeHtml(cat.categoryName || cat.name), "\n                        </div>\n                        <div class=\"budget-widget-amounts\">\n                            ").concat(_this5.formatCurrency(spent), " / ").concat(_this5.formatCurrency(budgeted), "\n                        </div>\n                    </div>\n                    <div class=\"budget-progress-bar\">\n                        <div class=\"budget-progress-fill ").concat(statusClass, "\" style=\"width: ").concat(percentage, "%\"></div>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateSavingsGoalsWidget",
    value: function updateSavingsGoalsWidget(goals) {
      var _this6 = this;
      var container = document.getElementById('savings-goals-summary');
      if (!container) return;
      if (!Array.isArray(goals) || goals.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No savings goals yet</div>';
        return;
      }
      container.innerHTML = goals.slice(0, 3).map(function (goal) {
        var target = goal.targetAmount || goal.target_amount || 0;
        var current = goal.currentAmount || goal.current_amount || 0;
        var percentage = target > 0 ? Math.min(current / target * 100, 100) : 0;
        var remaining = Math.max(target - current, 0);
        return "\n                <div class=\"savings-goal-item\">\n                    <div class=\"savings-goal-header\">\n                        <div class=\"savings-goal-name\">".concat(_this6.escapeHtml(goal.name), "</div>\n                        <div class=\"savings-goal-target\">Target: ").concat(_this6.formatCurrency(target), "</div>\n                    </div>\n                    <div class=\"savings-goal-progress\">\n                        <div class=\"savings-goal-fill\" style=\"width: ").concat(percentage, "%\"></div>\n                    </div>\n                    <div class=\"savings-goal-footer\">\n                        <span class=\"savings-goal-current\">").concat(_this6.formatCurrency(current), " saved</span>\n                        <span>").concat(percentage.toFixed(0), "%</span>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updatePensionsSummary",
    value: function updatePensionsSummary(summary) {
      var currency = this.getPrimaryCurrency();
      var pensionWorth = summary.totalPensionWorth || 0;
      var projectedIncome = summary.totalProjectedIncome || 0;
      var count = summary.pensionCount || 0;
      var worthEl = document.getElementById('pensions-total-worth');
      var countEl = document.getElementById('pensions-count');
      if (worthEl) {
        worthEl.textContent = this.formatCurrency(pensionWorth, currency);
      }
      if (countEl) {
        countEl.textContent = count;
      }

      // Update dashboard hero card
      var heroPensionValue = document.getElementById('hero-pension-value');
      var heroPensionCount = document.getElementById('hero-pension-count');
      var heroPensionLabel = document.querySelector('.hero-pension .hero-label');
      if (heroPensionValue) {
        // Show pension worth if available, otherwise show projected income
        if (pensionWorth > 0) {
          heroPensionValue.textContent = this.formatCurrency(pensionWorth, currency);
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Worth';
        } else if (projectedIncome > 0) {
          heroPensionValue.textContent = this.formatCurrency(projectedIncome, currency) + '/yr';
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Income';
        } else {
          heroPensionValue.textContent = this.formatCurrency(0, currency);
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Worth';
        }
      }
      if (heroPensionCount) {
        var subtext = count === 1 ? '1 pension' : "".concat(count, " pensions");
        // If showing income but also have some pot value, mention it
        if (pensionWorth > 0 && projectedIncome > 0) {
          subtext += " \xB7 ".concat(this.formatCurrency(projectedIncome, currency), "/yr income");
        }
        heroPensionCount.textContent = subtext;
      }
    }

    // Phase 1: New Widget Tiles
  }, {
    key: "updateTopCategoriesWidget",
    value: function updateTopCategoriesWidget(spending) {
      var _this7 = this;
      var container = document.getElementById('top-categories-list');
      if (!container) return;
      if (!spending || _typeof(spending) !== 'object' || Object.keys(spending).length === 0) {
        container.innerHTML = '<div class="empty-state-small">No spending data</div>';
        return;
      }
      var topCategories = Object.entries(spending).sort(function (a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
      }).slice(0, 5);
      container.innerHTML = topCategories.map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          categoryId = _ref2[0],
          amount = _ref2[1];
        var category = _this7.categories.find(function (c) {
          return c.id == categoryId;
        });
        return "\n                <div class=\"top-category-item\">\n                    <span class=\"category-dot\" style=\"background: ".concat((category === null || category === void 0 ? void 0 : category.color) || '#999', "\"></span>\n                    <span class=\"category-name\">").concat(_this7.escapeHtml((category === null || category === void 0 ? void 0 : category.name) || 'Unknown'), "</span>\n                    <span class=\"category-amount\">").concat(_this7.formatCurrency(Math.abs(amount)), "</span>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateAccountPerformanceWidget",
    value: function updateAccountPerformanceWidget(accounts) {
      var _this8 = this;
      var container = document.getElementById('account-performance-list');
      if (!container || !Array.isArray(accounts)) return;
      if (accounts.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No account data</div>';
        return;
      }

      // Calculate balance changes (this would ideally use historical data, but we'll use current balance as proxy)
      var accountsWithPerformance = accounts.map(function (acc) {
        return _objectSpread(_objectSpread({}, acc), {}, {
          changeAmount: acc.balance || 0 // In future, this could be balance - previousBalance
        });
      }).sort(function (a, b) {
        return Math.abs(b.changeAmount) - Math.abs(a.changeAmount);
      }).slice(0, 5);
      container.innerHTML = accountsWithPerformance.map(function (account) {
        var change = account.changeAmount;
        var isPositive = change >= 0;
        return "\n                <div class=\"account-performance-item\">\n                    <div class=\"account-name\">".concat(_this8.escapeHtml(account.name), "</div>\n                    <div class=\"account-balance\">").concat(_this8.formatCurrency(account.balance || 0), "</div>\n                    <div class=\"account-change ").concat(isPositive ? 'positive' : 'negative', "\">\n                        ").concat(isPositive ? '' : '', " ").concat(_this8.formatCurrency(Math.abs(change)), "\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updateBudgetBreakdownWidget",
    value: function updateBudgetBreakdownWidget(categories) {
      var _this9 = this;
      var container = document.getElementById('budget-breakdown-table');
      if (!container) return;
      if (!Array.isArray(categories) || categories.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No budget data</div>';
        return;
      }
      container.innerHTML = "\n            <table class=\"budget-breakdown-table\">\n                <thead>\n                    <tr>\n                        <th>Category</th>\n                        <th>Budget</th>\n                        <th>Spent</th>\n                        <th>Remaining</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    ".concat(categories.map(function (cat) {
        var budget = cat.budget || 0;
        var spent = cat.spent || 0;
        var remaining = budget - spent;
        var percentage = budget > 0 ? spent / budget * 100 : 0;
        return "\n                            <tr>\n                                <td>".concat(_this9.escapeHtml(cat.name), "</td>\n                                <td>").concat(_this9.formatCurrency(budget), "</td>\n                                <td>").concat(_this9.formatCurrency(spent), "</td>\n                                <td class=\"").concat(remaining >= 0 ? 'positive' : 'negative', "\">\n                                    ").concat(_this9.formatCurrency(remaining), "\n                                </td>\n                            </tr>\n                        ");
      }).join(''), "\n                </tbody>\n            </table>\n        ");
    }
  }, {
    key: "updateGoalsSummaryWidget",
    value: function updateGoalsSummaryWidget(goals) {
      var _this0 = this;
      var container = document.getElementById('goals-summary-list');
      if (!container) return;
      if (!Array.isArray(goals) || goals.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No savings goals</div>';
        return;
      }
      container.innerHTML = goals.map(function (goal) {
        var target = goal.targetAmount || goal.target_amount || 0;
        var current = goal.currentAmount || goal.current_amount || 0;
        var percentage = target > 0 ? Math.min(current / target * 100, 100) : 0;
        return "\n                <div class=\"goal-summary-item\">\n                    <div class=\"goal-summary-header\">\n                        <span class=\"goal-name\">".concat(_this0.escapeHtml(goal.name), "</span>\n                        <span class=\"goal-percentage\">").concat(percentage.toFixed(0), "%</span>\n                    </div>\n                    <div class=\"goal-summary-progress\">\n                        <div class=\"goal-summary-fill\" style=\"width: ").concat(percentage, "%\"></div>\n                    </div>\n                    <div class=\"goal-summary-footer\">\n                        <span>").concat(_this0.formatCurrency(current), "</span>\n                        <span>").concat(_this0.formatCurrency(target), "</span>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "updatePaymentBreakdownWidget",
    value: function updatePaymentBreakdownWidget(accounts) {
      var _this1 = this;
      var container = document.getElementById('payment-breakdown-list');
      if (!container || !Array.isArray(accounts)) return;
      if (accounts.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No account data</div>';
        return;
      }

      // Group by account type
      var breakdown = accounts.reduce(function (acc, account) {
        var type = account.type || 'Other';
        if (!acc[type]) {
          acc[type] = {
            count: 0,
            total: 0
          };
        }
        acc[type].count++;
        acc[type].total += account.balance || 0;
        return acc;
      }, {});
      var typeLabels = {
        'checking': 'Checking',
        'savings': 'Savings',
        'credit': 'Credit Cards',
        'investment': 'Investments',
        'loan': 'Loans',
        'Other': 'Other'
      };
      container.innerHTML = Object.entries(breakdown).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          type = _ref4[0],
          data = _ref4[1];
        return "\n            <div class=\"payment-method-item\">\n                <div class=\"payment-method-header\">\n                    <span class=\"payment-method-name\">".concat(typeLabels[type] || type, "</span>\n                    <span class=\"payment-method-count\">").concat(data.count, " accounts</span>\n                </div>\n                <div class=\"payment-method-total\">").concat(_this1.formatCurrency(data.total), "</div>\n            </div>\n        ");
      }).join('');
    }
  }, {
    key: "updateReconciliationStatusWidget",
    value: function updateReconciliationStatusWidget(accounts) {
      var _this10 = this;
      var container = document.getElementById('reconciliation-status-list');
      if (!container || !Array.isArray(accounts)) return;
      if (accounts.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No accounts to reconcile</div>';
        return;
      }

      // In a real implementation, this would track unreconciled transactions
      // For now, show account status
      var accountsToReconcile = accounts.map(function (acc) {
        return {
          name: acc.name,
          unreconciledCount: 0,
          // Would be fetched from API
          lastReconciled: null // Would be fetched from API
        };
      }).filter(function (a) {
        return true;
      }); // Would filter to only show accounts needing reconciliation

      if (accountsToReconcile.length === 0) {
        container.innerHTML = '<div class="empty-state-small">All accounts reconciled</div>';
        return;
      }
      container.innerHTML = accountsToReconcile.slice(0, 5).map(function (account) {
        return "\n            <div class=\"reconciliation-item\">\n                <div class=\"reconciliation-name\">".concat(_this10.escapeHtml(account.name), "</div>\n                <div class=\"reconciliation-status\">\n                    <span class=\"reconciliation-badge\">Up to date</span>\n                </div>\n            </div>\n        ");
      }).join('');
    }

    // ===========================
    // Chart Updates
    // ===========================
  }, {
    key: "updateSpendingChart",
    value: function updateSpendingChart(spending) {
      var _this11 = this;
      var canvas = document.getElementById('spending-chart');
      if (!canvas) return;

      // Destroy existing chart
      if (this.charts.spending) {
        this.charts.spending.destroy();
      }
      if (!spending || Object.keys(spending).length === 0) {
        return;
      }
      var ctx = canvas.getContext('2d');
      var sortedData = Object.entries(spending).sort(function (a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
      }).slice(0, 10);
      var labels = sortedData.map(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
          categoryId = _ref6[0];
        var category = _this11.categories.find(function (c) {
          return c.id == categoryId;
        });
        return category ? category.name : 'Unknown';
      });
      var data = sortedData.map(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
          amount = _ref8[1];
        return Math.abs(amount);
      });
      var colors = sortedData.map(function (_ref9) {
        var _ref0 = _slicedToArray(_ref9, 1),
          categoryId = _ref0[0];
        var category = _this11.categories.find(function (c) {
          return c.id == categoryId;
        });
        return category ? category.color : '#999';
      });
      this.charts.spending = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: colors
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.label, ": ").concat(_this11.formatCurrency(context.raw));
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "updateTrendChart",
    value: function updateTrendChart(trends) {
      var _this12 = this;
      var canvas = document.getElementById('trend-chart');
      if (!canvas) return;

      // Destroy existing chart
      if (this.charts.trend) {
        this.charts.trend.destroy();
      }
      if (!trends || !trends.labels || trends.labels.length === 0) {
        return;
      }
      var ctx = canvas.getContext('2d');
      this.charts.trend = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'line',
        data: {
          labels: trends.labels,
          datasets: [{
            label: 'Income',
            data: trends.income || [],
            borderColor: '#46ba61',
            backgroundColor: 'rgba(70, 186, 97, 0.1)',
            fill: false,
            tension: 0.3
          }, {
            label: 'Expenses',
            data: trends.expenses || [],
            borderColor: '#e9322d',
            backgroundColor: 'rgba(233, 50, 45, 0.1)',
            fill: false,
            tension: 0.3
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this12.formatCurrency(context.raw));
                }
              }
            }
          },
          scales: {
            y: {
              ticks: {
                callback: function callback(value) {
                  return _this12.formatCurrency(value);
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "updateNetWorthHistoryChart",
    value: function updateNetWorthHistoryChart(snapshots) {
      var _this13 = this;
      var canvas = document.getElementById('net-worth-chart');
      var emptyState = document.getElementById('net-worth-chart-empty');
      if (!canvas) return;

      // Destroy existing chart
      if (this.charts.netWorth) {
        this.charts.netWorth.destroy();
      }

      // Handle empty state
      if (!snapshots || snapshots.length === 0) {
        canvas.style.display = 'none';
        if (emptyState) emptyState.style.display = 'block';
        return;
      }

      // Show canvas, hide empty state
      canvas.style.display = 'block';
      if (emptyState) emptyState.style.display = 'none';
      var currency = this.getPrimaryCurrency();
      var labels = snapshots.map(function (s) {
        return s.date;
      });
      var netWorthData = snapshots.map(function (s) {
        return s.netWorth;
      });
      var assetsData = snapshots.map(function (s) {
        return s.totalAssets;
      });
      var liabilitiesData = snapshots.map(function (s) {
        return s.totalLiabilities;
      });
      this.charts.netWorth = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](canvas, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Net Worth',
            data: netWorthData,
            borderColor: '#46ba61',
            backgroundColor: 'rgba(70, 186, 97, 0.1)',
            fill: true,
            tension: 0.3,
            borderWidth: 2
          }, {
            label: 'Assets',
            data: assetsData,
            borderColor: '#0082c9',
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5
          }, {
            label: 'Liabilities',
            data: liabilitiesData,
            borderColor: '#e9322d',
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              position: 'bottom',
              labels: {
                usePointStyle: true,
                padding: 15
              }
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this13.formatCurrency(context.raw, currency));
                }
              }
            }
          },
          scales: {
            y: {
              ticks: {
                callback: function callback(value) {
                  return _this13.formatCurrency(value, currency);
                }
              }
            },
            x: {
              ticks: {
                maxTicksLimit: 8
              }
            }
          }
        }
      });
    }

    // ===========================
    // Dashboard Controls
    // ===========================
  }, {
    key: "setupDashboardControls",
    value: function setupDashboardControls() {
      var _this14 = this;
      // Trend period selector
      var trendPeriodSelect = document.getElementById('trend-period-select');
      if (trendPeriodSelect && !trendPeriodSelect.hasAttribute('data-initialized')) {
        trendPeriodSelect.setAttribute('data-initialized', 'true');
        trendPeriodSelect.addEventListener('change', /*#__PURE__*/function () {
          var _ref1 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(e) {
            var months;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  months = parseInt(e.target.value);
                  _context2.n = 1;
                  return _this14.refreshTrendChart(months);
                case 1:
                  return _context2.a(2);
              }
            }, _callee2);
          }));
          return function (_x) {
            return _ref1.apply(this, arguments);
          };
        }());
      }

      // Spending period selector
      var spendingPeriodSelect = document.getElementById('spending-period-select');
      if (spendingPeriodSelect && !spendingPeriodSelect.hasAttribute('data-initialized')) {
        spendingPeriodSelect.setAttribute('data-initialized', 'true');
        spendingPeriodSelect.addEventListener('change', /*#__PURE__*/function () {
          var _ref10 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(e) {
            var period;
            return _regenerator().w(function (_context3) {
              while (1) switch (_context3.n) {
                case 0:
                  period = e.target.value;
                  _context3.n = 1;
                  return _this14.refreshSpendingChart(period);
                case 1:
                  return _context3.a(2);
              }
            }, _callee3);
          }));
          return function (_x2) {
            return _ref10.apply(this, arguments);
          };
        }());
      }

      // Net Worth period selector
      var netWorthPeriodSelector = document.getElementById('net-worth-period-selector');
      if (netWorthPeriodSelector && !netWorthPeriodSelector.hasAttribute('data-initialized')) {
        netWorthPeriodSelector.setAttribute('data-initialized', 'true');
        netWorthPeriodSelector.addEventListener('click', /*#__PURE__*/function () {
          var _ref11 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(e) {
            var days;
            return _regenerator().w(function (_context4) {
              while (1) switch (_context4.n) {
                case 0:
                  if (!e.target.classList.contains('period-btn')) {
                    _context4.n = 1;
                    break;
                  }
                  // Update active button
                  netWorthPeriodSelector.querySelectorAll('.period-btn').forEach(function (btn) {
                    return btn.classList.remove('active');
                  });
                  e.target.classList.add('active');
                  // Refresh chart with new period
                  days = parseInt(e.target.dataset.days);
                  _context4.n = 1;
                  return _this14.refreshNetWorthChart(days);
                case 1:
                  return _context4.a(2);
              }
            }, _callee4);
          }));
          return function (_x3) {
            return _ref11.apply(this, arguments);
          };
        }());
      }

      // Record Net Worth Snapshot button
      var recordNetWorthBtn = document.getElementById('record-net-worth-btn');
      if (recordNetWorthBtn && !recordNetWorthBtn.hasAttribute('data-initialized')) {
        recordNetWorthBtn.setAttribute('data-initialized', 'true');
        recordNetWorthBtn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
          return _regenerator().w(function (_context5) {
            while (1) switch (_context5.n) {
              case 0:
                _context5.n = 1;
                return _this14.recordNetWorthSnapshot();
              case 1:
                return _context5.a(2);
            }
          }, _callee5);
        })));
      }
    }
  }, {
    key: "refreshTrendChart",
    value: function () {
      var _refreshTrendChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(months) {
        var startDate, response, data, _t9;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              startDate = new Date();
              startDate.setMonth(startDate.getMonth() - months);
              _context6.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/reports/summary?startDate=".concat(startDate.toISOString().split('T')[0])), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context6.v;
              _context6.n = 2;
              return response.json();
            case 2:
              data = _context6.v;
              if (data.trends) {
                this.updateTrendChart(data.trends);
              }
              _context6.n = 4;
              break;
            case 3:
              _context6.p = 3;
              _t9 = _context6.v;
              console.error('Failed to refresh trend chart:', _t9);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this, [[0, 3]]);
      }));
      function refreshTrendChart(_x4) {
        return _refreshTrendChart.apply(this, arguments);
      }
      return refreshTrendChart;
    }()
  }, {
    key: "refreshSpendingChart",
    value: function () {
      var _refreshSpendingChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(period) {
        var startDate, endDate, response, data, _t0, _t1;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              startDate = new Date();
              endDate = new Date();
              _t0 = period;
              _context7.n = _t0 === 'month' ? 1 : _t0 === '3months' ? 2 : _t0 === 'year' ? 3 : 4;
              break;
            case 1:
              startDate = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
              return _context7.a(3, 4);
            case 2:
              startDate.setMonth(startDate.getMonth() - 3);
              return _context7.a(3, 4);
            case 3:
              startDate = new Date(endDate.getFullYear(), 0, 1);
              return _context7.a(3, 4);
            case 4:
              _context7.n = 5;
              return fetch(OC.generateUrl("/apps/budget/api/reports/spending?startDate=".concat(startDate.toISOString().split('T')[0], "&endDate=").concat(endDate.toISOString().split('T')[0])), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 5:
              response = _context7.v;
              _context7.n = 6;
              return response.json();
            case 6:
              data = _context7.v;
              if (data.data) {
                this.updateSpendingChart(data.data);
              }
              _context7.n = 8;
              break;
            case 7:
              _context7.p = 7;
              _t1 = _context7.v;
              console.error('Failed to refresh spending chart:', _t1);
            case 8:
              return _context7.a(2);
          }
        }, _callee7, this, [[0, 7]]);
      }));
      function refreshSpendingChart(_x5) {
        return _refreshSpendingChart.apply(this, arguments);
      }
      return refreshSpendingChart;
    }()
  }, {
    key: "refreshNetWorthChart",
    value: function () {
      var _refreshNetWorthChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(days) {
        var response, snapshots, _t10;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              _context8.p = 0;
              _context8.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/net-worth/snapshots?days=".concat(days)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 2;
                break;
              }
              throw new Error('Failed to fetch net worth snapshots');
            case 2:
              _context8.n = 3;
              return response.json();
            case 3:
              snapshots = _context8.v;
              this.updateNetWorthHistoryChart(snapshots);
              _context8.n = 5;
              break;
            case 4:
              _context8.p = 4;
              _t10 = _context8.v;
              console.error('Failed to refresh net worth chart:', _t10);
            case 5:
              return _context8.a(2);
          }
        }, _callee8, this, [[0, 4]]);
      }));
      function refreshNetWorthChart(_x6) {
        return _refreshNetWorthChart.apply(this, arguments);
      }
      return refreshNetWorthChart;
    }()
  }, {
    key: "recordNetWorthSnapshot",
    value: function () {
      var _recordNetWorthSnapshot = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
        var response, activeBtn, days, _t11;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              _context9.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/net-worth/snapshots'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                }
              });
            case 1:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 2;
                break;
              }
              throw new Error('Failed to record snapshot');
            case 2:
              OC.Notification.showTemporary('Net worth snapshot recorded');

              // Refresh the chart with current period
              activeBtn = document.querySelector('#net-worth-period-selector .period-btn.active');
              days = activeBtn ? parseInt(activeBtn.dataset.days) : 30;
              _context9.n = 3;
              return this.refreshNetWorthChart(days);
            case 3:
              _context9.n = 5;
              break;
            case 4:
              _context9.p = 4;
              _t11 = _context9.v;
              console.error('Failed to record net worth snapshot:', _t11);
              OC.Notification.showTemporary('Failed to record snapshot');
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 4]]);
      }));
      function recordNetWorthSnapshot() {
        return _recordNetWorthSnapshot.apply(this, arguments);
      }
      return recordNetWorthSnapshot;
    }() // ===========================
    // Dashboard Customization
    // ===========================
  }, {
    key: "parseDashboardConfig",
    value: function parseDashboardConfig(settingValue, category) {
      // Get defaults from widget registry
      var widgets = _config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__.DASHBOARD_WIDGETS[category];
      var defaults = {
        order: Object.keys(widgets),
        visibility: Object.keys(widgets).reduce(function (acc, key) {
          acc[key] = widgets[key].defaultVisible;
          return acc;
        }, {})
      };
      if (!settingValue) return defaults;
      try {
        var saved = JSON.parse(settingValue);

        // Merge: preserve user settings, add any new widgets from defaults
        var allWidgetIds = new Set([].concat(_toConsumableArray(saved.order), _toConsumableArray(defaults.order)));
        var mergedOrder = saved.order.filter(function (id) {
          return allWidgetIds.has(id);
        });

        // Append any new widgets that aren't in saved order
        defaults.order.forEach(function (id) {
          if (!mergedOrder.includes(id)) {
            mergedOrder.push(id);
          }
        });
        return {
          order: mergedOrder,
          visibility: _objectSpread(_objectSpread({}, defaults.visibility), saved.visibility)
        };
      } catch (e) {
        console.error('Failed to parse dashboard config', e);
        return defaults;
      }
    }
  }, {
    key: "applyDashboardVisibility",
    value: function () {
      var _applyDashboardVisibility = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        var _i, _Object$entries, _Object$entries$_i, key, visible, widget, element, updateMethod, _i2, _Object$entries2, _Object$entries2$_i, _key, _visible, _widget, _element, _updateMethod, hasConditionalHide;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              _i = 0, _Object$entries = Object.entries(this.dashboardConfig.hero.visibility);
            case 1:
              if (!(_i < _Object$entries.length)) {
                _context0.n = 7;
                break;
              }
              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], visible = _Object$entries$_i[1];
              widget = _config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__.DASHBOARD_WIDGETS.hero[key];
              if (widget) {
                _context0.n = 2;
                break;
              }
              return _context0.a(3, 6);
            case 2:
              element = document.querySelector("[data-widget-id=\"".concat(key, "\"][data-widget-category=\"hero\"]"));
              if (element) {
                _context0.n = 3;
                break;
              }
              return _context0.a(3, 6);
            case 3:
              if (!(visible && this.app.needsLazyLoad(key) && !this.widgetDataLoaded[key])) {
                _context0.n = 5;
                break;
              }
              _context0.n = 4;
              return this.app.loadWidgetData(key);
            case 4:
              // Call the appropriate update method
              updateMethod = "update".concat(key.charAt(0).toUpperCase() + key.slice(1), "Hero");
              if (typeof this[updateMethod] === 'function') {
                this[updateMethod]();
              }
            case 5:
              element.style.display = visible ? '' : 'none';
            case 6:
              _i++;
              _context0.n = 1;
              break;
            case 7:
              _i2 = 0, _Object$entries2 = Object.entries(this.dashboardConfig.widgets.visibility);
            case 8:
              if (!(_i2 < _Object$entries2.length)) {
                _context0.n = 14;
                break;
              }
              _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), _key = _Object$entries2$_i[0], _visible = _Object$entries2$_i[1];
              _widget = _config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__.DASHBOARD_WIDGETS.widgets[_key];
              if (_widget) {
                _context0.n = 9;
                break;
              }
              return _context0.a(3, 13);
            case 9:
              _element = document.querySelector("[data-widget-id=\"".concat(_key, "\"][data-widget-category=\"widget\"]"));
              if (_element) {
                _context0.n = 10;
                break;
              }
              return _context0.a(3, 13);
            case 10:
              if (!(_visible && this.app.needsLazyLoad(_key) && !this.widgetDataLoaded[_key])) {
                _context0.n = 12;
                break;
              }
              _context0.n = 11;
              return this.app.loadWidgetData(_key);
            case 11:
              // Call the appropriate update method
              _updateMethod = "update".concat(_key.charAt(0).toUpperCase() + _key.slice(1), "Widget");
              if (typeof this[_updateMethod] === 'function') {
                this[_updateMethod]();
              }
            case 12:
              // Initialize Quick Add form when it becomes visible (Phase 4)
              if (_visible && _key === 'quickAdd' && !this.widgetDataLoaded[_key]) {
                this.app.initQuickAddForm();
                this.widgetDataLoaded[_key] = true;
              }

              // Respect conditional widgets (Budget Alerts, Debt Payoff)
              if (_visible) {
                hasConditionalHide = _element.hasAttribute('style') && _element.getAttribute('style').includes('display: none') && (_key === 'budgetAlerts' || _key === 'debtPayoff');
                if (!hasConditionalHide) {
                  _element.style.display = '';
                }
              } else {
                _element.style.display = 'none';
              }
            case 13:
              _i2++;
              _context0.n = 8;
              break;
            case 14:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function applyDashboardVisibility() {
        return _applyDashboardVisibility.apply(this, arguments);
      }
      return applyDashboardVisibility;
    }()
  }, {
    key: "hideWidget",
    value: function () {
      var _hideWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(widgetId, category) {
        var config;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              config = category === 'hero' ? this.dashboardConfig.hero : this.dashboardConfig.widgets; // Update visibility
              config.visibility[widgetId] = false;

              // Apply to DOM
              _context1.n = 1;
              return this.applyDashboardVisibility();
            case 1:
              // Update Add Tiles menu
              this.app.updateAddTilesMenu();

              // Save to backend
              _context1.n = 2;
              return this.saveDashboardVisibility();
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function hideWidget(_x7, _x8) {
        return _hideWidget.apply(this, arguments);
      }
      return hideWidget;
    }()
  }, {
    key: "showWidget",
    value: function () {
      var _showWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(widgetId, category) {
        var config;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              config = category === 'hero' ? this.dashboardConfig.hero : this.dashboardConfig.widgets; // Update visibility
              config.visibility[widgetId] = true;

              // Apply to DOM
              _context10.n = 1;
              return this.applyDashboardVisibility();
            case 1:
              // Add remove buttons if unlocked
              if (!this.dashboardLocked) {
                this.app.addRemoveButtons();
              }

              // Update Add Tiles menu
              this.app.updateAddTilesMenu();

              // Save to backend
              _context10.n = 2;
              return this.saveDashboardVisibility();
            case 2:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function showWidget(_x9, _x0) {
        return _showWidget.apply(this, arguments);
      }
      return showWidget;
    }()
  }, {
    key: "saveDashboardVisibility",
    value: function () {
      var _saveDashboardVisibility = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var settings, response, _t12;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              _context11.p = 0;
              settings = {
                dashboard_hero_config: JSON.stringify(this.dashboardConfig.hero),
                dashboard_widgets_config: JSON.stringify(this.dashboardConfig.widgets)
              };
              _context11.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
              });
            case 1:
              response = _context11.v;
              if (response.ok) {
                _context11.n = 2;
                break;
              }
              throw new Error('Failed to save dashboard config');
            case 2:
              this.settings.dashboard_hero_config = settings.dashboard_hero_config;
              this.settings.dashboard_widgets_config = settings.dashboard_widgets_config;
              _context11.n = 4;
              break;
            case 3:
              _context11.p = 3;
              _t12 = _context11.v;
              console.error('Failed to save dashboard config:', _t12);
              OC.Notification.showTemporary('Failed to save dashboard layout');
            case 4:
              return _context11.a(2);
          }
        }, _callee11, this, [[0, 3]]);
      }));
      function saveDashboardVisibility() {
        return _saveDashboardVisibility.apply(this, arguments);
      }
      return saveDashboardVisibility;
    }()
  }, {
    key: "setupDashboardDragAndDrop",
    value:
    // ===========================
    // Dashboard Drag and Drop
    // ===========================

    function setupDashboardDragAndDrop() {
      var _this15 = this;
      // Check if touch device - disable drag on mobile
      var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (isTouchDevice) {
        return; // Only allow drag-and-drop on desktop
      }

      // Set draggable based on lock state
      var isDraggable = !this.dashboardLocked;

      // Make hero cards draggable
      document.querySelectorAll('.hero-card').forEach(function (card) {
        card.draggable = isDraggable;
        card.addEventListener('dragstart', function (e) {
          var widgetId = card.dataset.widgetId;
          e.dataTransfer.setData('text/plain', JSON.stringify({
            id: widgetId,
            category: 'hero'
          }));
          card.classList.add('dragging');
        });
        card.addEventListener('dragend', function (e) {
          card.classList.remove('dragging');
          _this15.clearDashboardDropIndicators();
        });
      });

      // Make dashboard cards draggable
      document.querySelectorAll('.dashboard-card').forEach(function (card) {
        card.draggable = isDraggable;
        card.addEventListener('dragstart', function (e) {
          var widgetId = card.dataset.widgetId;
          e.dataTransfer.setData('text/plain', JSON.stringify({
            id: widgetId,
            category: 'widget'
          }));
          card.classList.add('dragging');
        });
        card.addEventListener('dragend', function (e) {
          card.classList.remove('dragging');
          _this15.clearDashboardDropIndicators();
        });
      });

      // Setup drop zones
      var heroContainer = document.querySelector('.dashboard-hero');
      var mainColumn = document.querySelector('.dashboard-column-main');
      var sideColumn = document.querySelector('.dashboard-column-side');
      [heroContainer, mainColumn, sideColumn].forEach(function (container) {
        if (!container) return;
        container.addEventListener('dragover', function (e) {
          e.preventDefault();
          _this15.showDashboardDropIndicator(e, container);
        });
        container.addEventListener('drop', /*#__PURE__*/function () {
          var _ref13 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(e) {
            var data, dropInfo, _t13;
            return _regenerator().w(function (_context12) {
              while (1) switch (_context12.p = _context12.n) {
                case 0:
                  e.preventDefault();
                  _this15.clearDashboardDropIndicators();
                  _context12.p = 1;
                  data = JSON.parse(e.dataTransfer.getData('text/plain'));
                  dropInfo = _this15.getDashboardDropTarget(e, container);
                  if (!dropInfo) {
                    _context12.n = 2;
                    break;
                  }
                  _context12.n = 2;
                  return _this15.reorderDashboardWidget(data.id, dropInfo.targetId, dropInfo.position, data.category);
                case 2:
                  _context12.n = 4;
                  break;
                case 3:
                  _context12.p = 3;
                  _t13 = _context12.v;
                  console.error('Drop failed:', _t13);
                case 4:
                  return _context12.a(2);
              }
            }, _callee12, null, [[1, 3]]);
          }));
          return function (_x1) {
            return _ref13.apply(this, arguments);
          };
        }());
        container.addEventListener('dragleave', function (e) {
          if (!container.contains(e.relatedTarget)) {
            _this15.clearDashboardDropIndicators();
          }
        });
      });
    }
  }, {
    key: "applyDashboardOrder",
    value: function applyDashboardOrder() {
      var _this16 = this;
      // Reorder hero cards
      var heroContainer = document.querySelector('.dashboard-hero');
      if (heroContainer) {
        var fragment = document.createDocumentFragment();
        this.dashboardConfig.hero.order.forEach(function (widgetId) {
          var card = heroContainer.querySelector("[data-widget-id=\"".concat(widgetId, "\"]"));
          if (card) {
            fragment.appendChild(card);
          }
        });
        heroContainer.appendChild(fragment);
      }

      // For widgets, we need to handle two columns
      // Simpler approach: collect all widgets, sort by order, then redistribute
      var mainColumn = document.querySelector('.dashboard-column-main');
      var sideColumn = document.querySelector('.dashboard-column-side');
      if (!mainColumn || !sideColumn) return;

      // Collect all widget cards
      var allCards = [];
      document.querySelectorAll('[data-widget-category="widget"]').forEach(function (card) {
        allCards.push(card);
      });

      // Sort by configured order
      allCards.sort(function (a, b) {
        var aIndex = _this16.dashboardConfig.widgets.order.indexOf(a.dataset.widgetId);
        var bIndex = _this16.dashboardConfig.widgets.order.indexOf(b.dataset.widgetId);
        return aIndex - bIndex;
      });

      // Remove all widget cards from both columns first
      allCards.forEach(function (card) {
        return card.remove();
      });

      // Redistribute: first 4 to main, rest to side (matching original layout)
      var fragment1 = document.createDocumentFragment();
      var fragment2 = document.createDocumentFragment();
      allCards.forEach(function (card, index) {
        if (index < 4) {
          fragment1.appendChild(card);
        } else {
          fragment2.appendChild(card);
        }
      });
      mainColumn.appendChild(fragment1);
      sideColumn.appendChild(fragment2);
    }
  }, {
    key: "applyDashboardLayout",
    value: function applyDashboardLayout() {
      var _this17 = this;
      var isMobile = window.innerWidth < 1200;
      if (isMobile) {
        // On mobile, apply CSS order property for single-column layout
        var orderIndex = 0;

        // Hero cards first
        this.dashboardConfig.hero.order.forEach(function (widgetId) {
          var card = document.querySelector("[data-widget-id=\"".concat(widgetId, "\"][data-widget-category=\"hero\"]"));
          if (card && _this17.dashboardConfig.hero.visibility[widgetId]) {
            card.style.order = orderIndex++;
          }
        });

        // Then widget cards
        this.dashboardConfig.widgets.order.forEach(function (widgetId) {
          var card = document.querySelector("[data-widget-id=\"".concat(widgetId, "\"][data-widget-category=\"widget\"]"));
          if (card && _this17.dashboardConfig.widgets.visibility[widgetId]) {
            card.style.order = orderIndex++;
          }
        });
      } else {
        // On desktop, clear order and let CSS Grid handle layout
        document.querySelectorAll('[data-widget-id]').forEach(function (card) {
          card.style.order = '';
        });
      }
    }

    // Phase 2: Lazy loading infrastructure
  }, {
    key: "needsLazyLoad",
    value: function needsLazyLoad(widgetKey) {
      // Phase 1 tiles don't need lazy loading (use existing data)
      var phase1Tiles = ['savingsRate', 'cashFlow', 'budgetRemaining', 'budgetHealth', 'topCategories', 'accountPerformance', 'budgetBreakdown', 'goalsSummary', 'paymentBreakdown', 'reconciliationStatus'];
      return !phase1Tiles.includes(widgetKey);
    }
  }, {
    key: "loadWidgetData",
    value: function () {
      var _loadWidgetData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(widgetKey) {
        var uncatResp, now, thisMonth, lastMonth, _yield$Promise$all3, _yield$Promise$all4, currentResp, previousResp, largeResp, forecastResp, yoyResp, incomeResp, debtResp, rulesResp, _t14, _t15, _t16, _t17;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.p = _context13.n) {
            case 0:
              if (!this.widgetDataLoaded[widgetKey]) {
                _context13.n = 1;
                break;
              }
              return _context13.a(2);
            case 1:
              _context13.p = 1;
              _t14 = widgetKey;
              _context13.n = _t14 === 'uncategorizedCount' ? 2 : _t14 === 'monthlyComparison' ? 5 : _t14 === 'largeTransactions' ? 9 : _t14 === 'cashFlowForecast' ? 12 : _t14 === 'yoyComparison' ? 15 : _t14 === 'incomeTracking' ? 18 : _t14 === 'daysUntilDebtFree' ? 21 : _t14 === 'recentImports' ? 24 : _t14 === 'ruleEffectiveness' ? 25 : 28;
              break;
            case 2:
              _context13.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/uncategorized?limit=100'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 3:
              uncatResp = _context13.v;
              _context13.n = 4;
              return uncatResp.json();
            case 4:
              this.widgetData.uncategorizedCount = _context13.v;
              return _context13.a(3, 28);
            case 5:
              now = new Date();
              thisMonth = {
                start: new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0],
                end: new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0]
              };
              lastMonth = {
                start: new Date(now.getFullYear(), now.getMonth() - 1, 1).toISOString().split('T')[0],
                end: new Date(now.getFullYear(), now.getMonth(), 0).toISOString().split('T')[0]
              };
              _context13.n = 6;
              return Promise.all([fetch(OC.generateUrl("/apps/budget/api/reports/summary?startDate=".concat(thisMonth.start, "&endDate=").concat(thisMonth.end)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              }), fetch(OC.generateUrl("/apps/budget/api/reports/summary?startDate=".concat(lastMonth.start, "&endDate=").concat(lastMonth.end)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })]);
            case 6:
              _yield$Promise$all3 = _context13.v;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              currentResp = _yield$Promise$all4[0];
              previousResp = _yield$Promise$all4[1];
              _context13.n = 7;
              return currentResp.json();
            case 7:
              _t15 = _context13.v;
              _context13.n = 8;
              return previousResp.json();
            case 8:
              _t16 = _context13.v;
              this.widgetData.monthlyComparison = {
                current: _t15,
                previous: _t16
              };
              return _context13.a(3, 28);
            case 9:
              _context13.n = 10;
              return fetch(OC.generateUrl('/apps/budget/api/transactions?limit=10&sort=amount'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 10:
              largeResp = _context13.v;
              _context13.n = 11;
              return largeResp.json();
            case 11:
              this.widgetData.largeTransactions = _context13.v;
              return _context13.a(3, 28);
            case 12:
              _context13.n = 13;
              return fetch(OC.generateUrl('/apps/budget/api/forecast/live?days=90'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 13:
              forecastResp = _context13.v;
              _context13.n = 14;
              return forecastResp.json();
            case 14:
              this.widgetData.cashFlowForecast = _context13.v;
              return _context13.a(3, 28);
            case 15:
              _context13.n = 16;
              return fetch(OC.generateUrl('/apps/budget/api/yoy/years?years=2'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 16:
              yoyResp = _context13.v;
              _context13.n = 17;
              return yoyResp.json();
            case 17:
              this.widgetData.yoyComparison = _context13.v;
              return _context13.a(3, 28);
            case 18:
              _context13.n = 19;
              return fetch(OC.generateUrl('/apps/budget/api/recurring-income/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 19:
              incomeResp = _context13.v;
              _context13.n = 20;
              return incomeResp.json();
            case 20:
              this.widgetData.incomeTracking = _context13.v;
              return _context13.a(3, 28);
            case 21:
              _context13.n = 22;
              return fetch(OC.generateUrl('/apps/budget/api/debts/payoff-plan?strategy=avalanche'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 22:
              debtResp = _context13.v;
              _context13.n = 23;
              return debtResp.json();
            case 23:
              this.widgetData.daysUntilDebtFree = _context13.v;
              return _context13.a(3, 28);
            case 24:
              // Placeholder - would use /api/import/history if it exists
              this.widgetData.recentImports = [];
              return _context13.a(3, 28);
            case 25:
              _context13.n = 26;
              return fetch(OC.generateUrl('/apps/budget/api/import-rules'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 26:
              rulesResp = _context13.v;
              _context13.n = 27;
              return rulesResp.json();
            case 27:
              this.widgetData.ruleEffectiveness = _context13.v;
              return _context13.a(3, 28);
            case 28:
              this.widgetDataLoaded[widgetKey] = true;
              _context13.n = 30;
              break;
            case 29:
              _context13.p = 29;
              _t17 = _context13.v;
              console.error("Failed to load data for ".concat(widgetKey, ":"), _t17);
            case 30:
              return _context13.a(2);
          }
        }, _callee13, this, [[1, 29]]);
      }));
      function loadWidgetData(_x10) {
        return _loadWidgetData.apply(this, arguments);
      }
      return loadWidgetData;
    }() // ===========================
    // Dashboard Customization
    // ===========================
  }, {
    key: "setupDashboardCustomization",
    value: function setupDashboardCustomization() {
      var _this18 = this;
      var toggleBtn = document.getElementById('toggle-dashboard-lock-btn');
      if (!toggleBtn) return;

      // Load saved lock state
      var savedLockState = this.settings.dashboard_locked !== 'false'; // Default to locked
      this.app.dashboardLocked = savedLockState;
      this.updateDashboardLockUI();
      toggleBtn.addEventListener('click', function () {
        return _this18.toggleDashboardLock();
      });

      // Add Tiles dropdown
      var addTilesBtn = document.getElementById('add-tiles-btn');
      var addTilesMenu = document.getElementById('add-tiles-menu');
      if (addTilesBtn && addTilesMenu) {
        addTilesBtn.addEventListener('click', function (e) {
          e.stopPropagation();
          var isVisible = addTilesMenu.style.display !== 'none';
          addTilesMenu.style.display = isVisible ? 'none' : 'block';
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function (e) {
          if (!addTilesBtn.contains(e.target) && !addTilesMenu.contains(e.target)) {
            addTilesMenu.style.display = 'none';
          }
        });
      }
    }
  }, {
    key: "toggleDashboardLock",
    value: function () {
      var _toggleDashboardLock = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14() {
        var settings, response, _t18;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              this.app.dashboardLocked = !this.app.dashboardLocked;

              // Update UI immediately
              this.updateDashboardLockUI();

              // Apply/remove draggable state
              this.setupDashboardDragAndDrop();

              // Save state to backend
              _context14.p = 1;
              settings = {
                dashboard_locked: this.app.dashboardLocked.toString()
              };
              _context14.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
              });
            case 2:
              response = _context14.v;
              if (response.ok) {
                _context14.n = 3;
                break;
              }
              throw new Error('Failed to save lock state');
            case 3:
              this.settings.dashboard_locked = settings.dashboard_locked;
              _context14.n = 5;
              break;
            case 4:
              _context14.p = 4;
              _t18 = _context14.v;
              console.error('Failed to save lock state:', _t18);
              OC.Notification.showTemporary('Failed to save dashboard lock state');
            case 5:
              return _context14.a(2);
          }
        }, _callee14, this, [[1, 4]]);
      }));
      function toggleDashboardLock() {
        return _toggleDashboardLock.apply(this, arguments);
      }
      return toggleDashboardLock;
    }()
  }, {
    key: "updateDashboardLockUI",
    value: function updateDashboardLockUI() {
      var btn = document.getElementById('toggle-dashboard-lock-btn');
      var btnText = document.getElementById('lock-btn-text');
      var hint = document.getElementById('dashboard-hint');
      var icon = btn === null || btn === void 0 ? void 0 : btn.querySelector('.icon-lock, .icon-unlock');
      var addTilesDropdown = document.getElementById('add-tiles-dropdown');
      if (!btn || !btnText || !hint) return;
      if (this.dashboardLocked) {
        // Locked state
        btnText.textContent = 'Unlock Dashboard';
        hint.querySelector('span:last-child').textContent = 'Dashboard is locked. Click unlock to reorder tiles.';
        if (icon) {
          icon.classList.remove('icon-unlock');
          icon.classList.add('icon-lock');
        }
        // Hide Add Tiles button
        if (addTilesDropdown) addTilesDropdown.style.display = 'none';
        // Remove all X buttons
        document.querySelectorAll('.widget-remove-btn').forEach(function (btn) {
          return btn.remove();
        });
      } else {
        // Unlocked state
        btnText.textContent = 'Lock Dashboard';
        hint.querySelector('span:last-child').textContent = 'Drag tiles to reorder your dashboard';
        if (icon) {
          icon.classList.remove('icon-lock');
          icon.classList.add('icon-unlock');
        }
        // Show Add Tiles button
        if (addTilesDropdown) addTilesDropdown.style.display = 'block';
        // Add X buttons to all visible widgets
        this.addRemoveButtons();
      }

      // Update Add Tiles dropdown content
      this.updateAddTilesMenu();
    }
  }, {
    key: "addRemoveButtons",
    value: function addRemoveButtons() {
      var _this19 = this;
      // Add remove button to hero cards
      document.querySelectorAll('.hero-card').forEach(function (card) {
        if (card.querySelector('.widget-remove-btn')) return; // Already has button

        var removeBtn = document.createElement('button');
        removeBtn.className = 'widget-remove-btn';
        removeBtn.setAttribute('aria-label', 'Remove tile');
        removeBtn.innerHTML = '&times;';
        removeBtn.addEventListener('click', function (e) {
          e.stopPropagation();
          _this19.hideWidget(card.dataset.widgetId, 'hero');
        });
        card.appendChild(removeBtn);
      });

      // Add remove button to dashboard cards
      document.querySelectorAll('.dashboard-card').forEach(function (card) {
        if (card.querySelector('.widget-remove-btn')) return; // Already has button

        var removeBtn = document.createElement('button');
        removeBtn.className = 'widget-remove-btn';
        removeBtn.setAttribute('aria-label', 'Remove tile');
        removeBtn.innerHTML = '&times;';
        removeBtn.addEventListener('click', function (e) {
          e.stopPropagation();
          _this19.hideWidget(card.dataset.widgetId, 'widget');
        });
        card.appendChild(removeBtn);
      });
    }
  }, {
    key: "updateAddTilesMenu",
    value: function updateAddTilesMenu() {
      var _this20 = this;
      var menuList = document.getElementById('add-tiles-menu-list');
      if (!menuList) return;
      menuList.innerHTML = '';

      // Group tiles by category
      var tilesByCategory = {};

      // Collect hidden hero tiles
      Object.entries(_config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__.DASHBOARD_WIDGETS.hero).forEach(function (_ref14) {
        var _ref15 = _slicedToArray(_ref14, 2),
          key = _ref15[0],
          widget = _ref15[1];
        if (!_this20.dashboardConfig.hero.visibility[key]) {
          var category = widget.category || 'other';
          if (!tilesByCategory[category]) {
            tilesByCategory[category] = [];
          }
          tilesByCategory[category].push({
            key: key,
            name: widget.name,
            type: 'hero',
            size: 'hero'
          });
        }
      });

      // Collect hidden widget tiles
      Object.entries(_config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_3__.DASHBOARD_WIDGETS.widgets).forEach(function (_ref16) {
        var _ref17 = _slicedToArray(_ref16, 2),
          key = _ref17[0],
          widget = _ref17[1];
        if (!_this20.dashboardConfig.widgets.visibility[key]) {
          var category = widget.category || 'other';
          if (!tilesByCategory[category]) {
            tilesByCategory[category] = [];
          }
          tilesByCategory[category].push({
            key: key,
            name: widget.name,
            type: 'widget',
            size: widget.size
          });
        }
      });

      // Check if any tiles are hidden
      var totalHidden = Object.values(tilesByCategory).reduce(function (sum, tiles) {
        return sum + tiles.length;
      }, 0);
      if (totalHidden === 0) {
        menuList.innerHTML = '<div class="add-tiles-empty">All tiles are visible</div>';
        return;
      }

      // Category display order and labels
      var categoryOrder = [{
        key: 'insights',
        label: 'Insights & Analytics'
      }, {
        key: 'budgeting',
        label: 'Budgeting'
      }, {
        key: 'forecasting',
        label: 'Forecasting'
      }, {
        key: 'transactions',
        label: 'Transactions'
      }, {
        key: 'income',
        label: 'Income'
      }, {
        key: 'debts',
        label: 'Debts'
      }, {
        key: 'goals',
        label: 'Goals'
      }, {
        key: 'bills',
        label: 'Bills'
      }, {
        key: 'alerts',
        label: 'Alerts'
      }, {
        key: 'interactive',
        label: 'Interactive'
      }, {
        key: 'other',
        label: 'Other'
      }];

      // Render tiles grouped by category
      categoryOrder.forEach(function (_ref18) {
        var key = _ref18.key,
          label = _ref18.label;
        var tiles = tilesByCategory[key];
        if (!tiles || tiles.length === 0) return;

        // Add category header
        var categoryHeader = document.createElement('div');
        categoryHeader.className = 'add-tiles-category-header';
        categoryHeader.textContent = label;
        menuList.appendChild(categoryHeader);

        // Add tiles in this category
        tiles.forEach(function (tile) {
          var item = document.createElement('div');
          item.className = 'add-tiles-menu-item';

          // Add size badge for hero tiles
          var sizeBadge = tile.size === 'hero' ? '<span class="tile-size-badge">Hero</span>' : '';
          item.innerHTML = "\n                    <span class=\"tile-name-wrapper\">\n                        <span class=\"tile-name\">".concat(tile.name, "</span>\n                        ").concat(sizeBadge, "\n                    </span>\n                    <button class=\"add-tile-btn\" data-widget-id=\"").concat(tile.key, "\" data-category=\"").concat(tile.type, "\">\n                        <span class=\"icon-add\"></span>\n                    </button>\n                ");
          menuList.appendChild(item);
        });
      });

      // Wire up add buttons
      menuList.querySelectorAll('.add-tile-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          var widgetId = btn.dataset.widgetId;
          var category = btn.dataset.category;
          _this20.showWidget(widgetId, category);
        });
      });
    }
  }, {
    key: "showDashboardDropIndicator",
    value: function showDashboardDropIndicator(e, container) {
      e.preventDefault();

      // Find the card we're hovering over
      var cards = Array.from(container.children).filter(function (el) {
        return el.classList.contains('hero-card') || el.classList.contains('dashboard-card');
      });
      var draggingCard = document.querySelector('.dragging');
      var afterCard = this.getDragAfterElement(container, e.clientY);

      // Remove existing indicators
      this.clearDashboardDropIndicators();

      // Add visual feedback
      if (afterCard) {
        afterCard.classList.add('drag-over');
        var indicator = document.createElement('div');
        indicator.className = 'drop-indicator';
        afterCard.parentElement.insertBefore(indicator, afterCard);
      } else {
        // Drop at the end
        var lastCard = cards[cards.length - 1];
        if (lastCard && lastCard !== draggingCard) {
          lastCard.classList.add('drag-over');
          var _indicator = document.createElement('div');
          _indicator.className = 'drop-indicator';
          container.appendChild(_indicator);
        }
      }
    }
  }, {
    key: "getDragAfterElement",
    value: function getDragAfterElement(container, y) {
      var draggableElements = Array.from(container.children).filter(function (el) {
        return (el.classList.contains('hero-card') || el.classList.contains('dashboard-card')) && !el.classList.contains('dragging');
      });
      return draggableElements.reduce(function (closest, child) {
        var box = child.getBoundingClientRect();
        var offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return {
            offset: offset,
            element: child
          };
        } else {
          return closest;
        }
      }, {
        offset: Number.NEGATIVE_INFINITY
      }).element;
    }
  }, {
    key: "getDashboardDropTarget",
    value: function getDashboardDropTarget(e, container) {
      var afterCard = this.getDragAfterElement(container, e.clientY);
      if (afterCard) {
        return {
          targetId: afterCard.dataset.widgetId,
          position: 'before'
        };
      } else {
        // Drop at end - find last card in container
        var cards = Array.from(container.children).filter(function (el) {
          return (el.classList.contains('hero-card') || el.classList.contains('dashboard-card')) && !el.classList.contains('dragging');
        });
        var lastCard = cards[cards.length - 1];
        if (lastCard) {
          return {
            targetId: lastCard.dataset.widgetId,
            position: 'after'
          };
        }
      }
      return null;
    }
  }, {
    key: "clearDashboardDropIndicators",
    value: function clearDashboardDropIndicators() {
      document.querySelectorAll('.drop-indicator').forEach(function (el) {
        return el.remove();
      });
      document.querySelectorAll('.drag-over').forEach(function (el) {
        return el.classList.remove('drag-over');
      });
    }
  }, {
    key: "reorderDashboardWidget",
    value: function () {
      var _reorderDashboardWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(draggedId, targetId, position, category) {
        var config, order, draggedIndex, targetIndex, settingKey, settings, response, _t19;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              // Determine which config to update
              config = category === 'hero' ? this.dashboardConfig.hero : this.dashboardConfig.widgets;
              order = _toConsumableArray(config.order); // Find indices
              draggedIndex = order.indexOf(draggedId);
              targetIndex = order.indexOf(targetId);
              if (!(draggedIndex === -1 || targetIndex === -1)) {
                _context15.n = 3;
                break;
              }
              console.warn('Widget not found in order array:', {
                draggedId: draggedId,
                targetId: targetId,
                order: order,
                category: category
              });
              // If widget not in order, add it
              if (!(draggedIndex === -1 && targetIndex !== -1)) {
                _context15.n = 2;
                break;
              }
              // Dragged widget not in order, insert it next to target
              if (position === 'before') {
                order.splice(targetIndex, 0, draggedId);
              } else {
                order.splice(targetIndex + 1, 0, draggedId);
              }
              config.order = order;
              _context15.n = 1;
              return this.saveDashboardVisibility();
            case 1:
              this.applyDashboardOrder();
              return _context15.a(2);
            case 2:
              console.error('Cannot reorder - target not found');
              return _context15.a(2);
            case 3:
              // Remove dragged item
              order.splice(draggedIndex, 1);

              // Adjust target index if needed
              if (draggedIndex < targetIndex) {
                targetIndex--;
              }

              // Insert at new position
              if (position === 'before') {
                order.splice(targetIndex, 0, draggedId);
              } else {
                order.splice(targetIndex + 1, 0, draggedId);
              }

              // Update config
              config.order = order;

              // Persist to backend
              _context15.p = 4;
              settingKey = category === 'hero' ? 'dashboard_hero_config' : 'dashboard_widgets_config';
              settings = _defineProperty({}, settingKey, JSON.stringify(config));
              _context15.n = 5;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
              });
            case 5:
              response = _context15.v;
              if (response.ok) {
                _context15.n = 6;
                break;
              }
              throw new Error('Failed to save widget order');
            case 6:
              this.settings[settingKey] = settings[settingKey];
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t19 = _context15.v;
              console.error('Failed to save widget order:', _t19);
              OC.Notification.showTemporary('Failed to save widget order');
            case 8:
              // Reorder DOM elements after config is saved
              this.applyDashboardOrder();

              // Update CSS layout properties
              this.applyDashboardLayout();
            case 9:
              return _context15.a(2);
          }
        }, _callee15, this, [[4, 7]]);
      }));
      function reorderDashboardWidget(_x11, _x12, _x13, _x14) {
        return _reorderDashboardWidget.apply(this, arguments);
      }
      return reorderDashboardWidget;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/forecast/ForecastModule.js":
/*!************************************************!*\
  !*** ./src/modules/forecast/ForecastModule.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ForecastModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var chart_js_auto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Forecast Module - Balance forecasting and trend analysis
 */


var ForecastModule = /*#__PURE__*/function () {
  function ForecastModule(app) {
    _classCallCheck(this, ForecastModule);
    this.app = app;
    this.savingsChart = null;
    this.balanceChart = null;
    this.forecastData = null;
    this.forecastCurrency = null;
    this._eventsSetup = false;
  }

  // Getters for app state
  return _createClass(ForecastModule, [{
    key: "settings",
    get: function get() {
      return this.app.settings;
    }

    // Helper method delegations
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryCurrency(this.app.accounts, this.settings);
    }
  }, {
    key: "loadForecastView",
    value: function () {
      var _loadForecastView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var loadingEl, emptyEl, sections, _document$getElementB, horizon, response, data, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              // Setup event listeners once
              if (!this._eventsSetup) {
                this.setupForecastEventListeners();
                this._eventsSetup = true;
              }
              loadingEl = document.getElementById('forecast-loading');
              emptyEl = document.getElementById('forecast-empty');
              sections = ['forecast-overview', 'forecast-trends', 'forecast-savings', 'forecast-chart', 'forecast-categories', 'forecast-quality']; // Show loading, hide everything else
              if (loadingEl) loadingEl.style.display = 'block';
              if (emptyEl) emptyEl.style.display = 'none';
              sections.forEach(function (id) {
                var el = document.getElementById(id);
                if (el) el.style.display = 'none';
              });
              _context.p = 1;
              horizon = ((_document$getElementB = document.getElementById('forecast-horizon')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || 6;
              _context.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/forecast/live?forecastMonths=".concat(horizon)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context.v;
              if (response.ok) {
                _context.n = 3;
                break;
              }
              throw new Error('Failed to fetch forecast');
            case 3:
              _context.n = 4;
              return response.json();
            case 4:
              data = _context.v;
              this.forecastData = data;
              this.forecastCurrency = data.currency || this.getPrimaryCurrency();

              // Hide loading
              if (loadingEl) loadingEl.style.display = 'none';

              // Check if we have enough data
              if (!(!data.dataQuality.isReliable && data.dataQuality.monthsOfData < 1)) {
                _context.n = 5;
                break;
              }
              if (emptyEl) emptyEl.style.display = 'block';
              return _context.a(2);
            case 5:
              // Display all sections (currency is accessed via this.forecastCurrency)
              this.displayBalanceOverview(data);
              this.displayTrendsSummary(data.trends);
              this.displaySavingsProjection(data.savingsProjection, data.monthlyProjections);
              this.displayBalanceProjectionChart(data.monthlyProjections);
              this.displayCategoryTrends(data.categoryBreakdown);
              this.displayDataQuality(data);

              // Show all sections
              sections.forEach(function (id) {
                var el = document.getElementById(id);
                if (el) el.style.display = 'block';
              });
              _context.n = 7;
              break;
            case 6:
              _context.p = 6;
              _t = _context.v;
              console.error('Failed to load forecast:', _t);
              if (loadingEl) loadingEl.style.display = 'none';
              OC.Notification.showTemporary('Failed to load forecast data');
            case 7:
              return _context.a(2);
          }
        }, _callee, this, [[1, 6]]);
      }));
      function loadForecastView() {
        return _loadForecastView.apply(this, arguments);
      }
      return loadForecastView;
    }()
  }, {
    key: "setupForecastEventListeners",
    value: function setupForecastEventListeners() {
      var _this = this;
      // Forecast horizon dropdown
      var horizonSelect = document.getElementById('forecast-horizon');
      if (horizonSelect) {
        horizonSelect.addEventListener('change', function () {
          _this.loadForecastView();
        });
      }
    }
  }, {
    key: "displayBalanceOverview",
    value: function displayBalanceOverview(data) {
      var currentBalanceEl = document.getElementById('current-balance');
      var projectedBalanceEl = document.getElementById('projected-balance');
      var balanceChangeEl = document.getElementById('balance-change');
      var currency = this.forecastCurrency;
      if (currentBalanceEl) {
        currentBalanceEl.textContent = this.formatCurrency(data.currentBalance, currency);
      }
      if (projectedBalanceEl) {
        projectedBalanceEl.textContent = this.formatCurrency(data.projectedBalance, currency);
      }
      if (balanceChangeEl) {
        var change = data.projectedBalance - data.currentBalance;
        var changePercent = data.currentBalance !== 0 ? (change / Math.abs(data.currentBalance) * 100).toFixed(1) : 0;
        var sign = change >= 0 ? '+' : '';
        balanceChangeEl.textContent = "".concat(sign).concat(this.formatCurrency(change, currency), " (").concat(sign).concat(changePercent, "%)");
        balanceChangeEl.className = "card-change ".concat(change >= 0 ? 'positive' : 'negative');
      }
    }
  }, {
    key: "displayTrendsSummary",
    value: function displayTrendsSummary(trends) {
      var avgIncomeEl = document.getElementById('avg-income');
      var avgExpensesEl = document.getElementById('avg-expenses');
      var avgSavingsEl = document.getElementById('avg-savings');
      var incomeDirectionEl = document.getElementById('income-direction');
      var expenseDirectionEl = document.getElementById('expense-direction');
      var savingsDirectionEl = document.getElementById('savings-direction');
      var currency = this.forecastCurrency;
      if (avgIncomeEl) avgIncomeEl.textContent = this.formatCurrency(trends.avgMonthlyIncome, currency);
      if (avgExpensesEl) avgExpensesEl.textContent = this.formatCurrency(trends.avgMonthlyExpenses, currency);
      if (avgSavingsEl) avgSavingsEl.textContent = this.formatCurrency(trends.avgMonthlySavings, currency);
      this.setDirectionIndicator(incomeDirectionEl, trends.incomeDirection);
      this.setDirectionIndicator(expenseDirectionEl, trends.expenseDirection, true);
      this.setDirectionIndicator(savingsDirectionEl, trends.savingsDirection);
    }
  }, {
    key: "setDirectionIndicator",
    value: function setDirectionIndicator(element, direction) {
      var invertColors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!element) return;
      var arrows = {
        up: '',
        down: '',
        stable: ''
      };
      element.textContent = arrows[direction] || '';

      // For expenses, down is good (green) and up is bad (red)
      var colorClass;
      if (direction === 'up') {
        colorClass = invertColors ? 'negative' : 'positive';
      } else if (direction === 'down') {
        colorClass = invertColors ? 'positive' : 'negative';
      } else {
        colorClass = 'neutral';
      }
      element.className = "trend-direction ".concat(colorClass);
    }
  }, {
    key: "displaySavingsProjection",
    value: function displaySavingsProjection(savings, monthlyProjections) {
      var monthlySavingsEl = document.getElementById('current-monthly-savings');
      var projectedTotalEl = document.getElementById('projected-total-savings');
      var savingsRateEl = document.getElementById('savings-rate');
      var currency = this.forecastCurrency;
      if (monthlySavingsEl) monthlySavingsEl.textContent = this.formatCurrency(savings.currentMonthlySavings, currency);
      if (projectedTotalEl) projectedTotalEl.textContent = this.formatCurrency(savings.projectedTotalSavings, currency);
      if (savingsRateEl) savingsRateEl.textContent = "".concat(savings.savingsRate, "%");

      // Render savings chart
      this.renderSavingsChart(monthlyProjections);
    }
  }, {
    key: "renderSavingsChart",
    value: function renderSavingsChart(monthlyProjections) {
      var _this2 = this;
      var canvas = document.getElementById('savings-chart');
      if (!canvas) return;
      var ctx = canvas.getContext('2d');
      var currency = this.forecastCurrency;
      if (this.savingsChart) {
        this.savingsChart.destroy();
      }
      var labels = monthlyProjections.map(function (p) {
        return p.month;
      });
      var savingsData = [];
      var cumulative = 0;
      monthlyProjections.forEach(function (p) {
        cumulative += p.savings;
        savingsData.push(cumulative);
      });
      this.savingsChart = new chart_js_auto__WEBPACK_IMPORTED_MODULE_1__["default"](ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Cumulative Savings',
            data: savingsData,
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            fill: true,
            tension: 0.3
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function callback(value) {
                  return _this2.formatCurrency(value, currency);
                }
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "Savings: ".concat(_this2.formatCurrency(context.parsed.y, currency));
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "displayBalanceProjectionChart",
    value: function displayBalanceProjectionChart(monthlyProjections) {
      var _this3 = this;
      var canvas = document.getElementById('balance-projection-chart');
      if (!canvas) return;
      var ctx = canvas.getContext('2d');
      var currency = this.forecastCurrency;
      if (this.balanceChart) {
        this.balanceChart.destroy();
      }
      var labels = monthlyProjections.map(function (p) {
        return p.month;
      });
      var balanceData = monthlyProjections.map(function (p) {
        return p.balance;
      });
      var incomeData = monthlyProjections.map(function (p) {
        return p.income;
      });
      var expenseData = monthlyProjections.map(function (p) {
        return p.expenses;
      });
      this.balanceChart = new chart_js_auto__WEBPACK_IMPORTED_MODULE_1__["default"](ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Projected Balance',
            data: balanceData,
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.1)',
            fill: true,
            tension: 0.3,
            yAxisID: 'y'
          }, {
            label: 'Projected Income',
            data: incomeData,
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'transparent',
            borderDash: [5, 5],
            tension: 0.3,
            yAxisID: 'y1'
          }, {
            label: 'Projected Expenses',
            data: expenseData,
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'transparent',
            borderDash: [5, 5],
            tension: 0.3,
            yAxisID: 'y1'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Balance'
              },
              ticks: {
                callback: function callback(value) {
                  return _this3.formatCurrency(value, currency);
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Income/Expenses'
              },
              grid: {
                drawOnChartArea: false
              },
              ticks: {
                callback: function callback(value) {
                  return _this3.formatCurrency(value, currency);
                }
              }
            }
          },
          plugins: {
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this3.formatCurrency(context.parsed.y, currency));
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "displayCategoryTrends",
    value: function displayCategoryTrends(categoryBreakdown) {
      var _this4 = this;
      var container = document.getElementById('category-trends-list');
      if (!container) return;
      container.innerHTML = '';
      var currency = this.forecastCurrency;
      if (!categoryBreakdown || categoryBreakdown.length === 0) {
        container.innerHTML = '<p class="empty-message">No category data available</p>';
        return;
      }
      categoryBreakdown.forEach(function (category) {
        var trendArrow = {
          up: '',
          down: '',
          stable: ''
        }[category.trend] || '';
        var trendClass = category.trend === 'up' ? 'negative' : category.trend === 'down' ? 'positive' : 'neutral';
        var item = document.createElement('div');
        item.className = 'category-trend-item';
        item.innerHTML = "\n                <span class=\"category-name\">".concat(category.name, "</span>\n                <span class=\"category-amount\">").concat(_this4.formatCurrency(category.avgMonthly, currency), "/mo</span>\n                <span class=\"category-trend ").concat(trendClass, "\">").concat(trendArrow, "</span>\n            ");
        container.appendChild(item);
      });
    }
  }, {
    key: "displayDataQuality",
    value: function displayDataQuality(data) {
      var confidenceEl = document.getElementById('forecast-confidence');
      var dataInfoEl = document.getElementById('data-info');
      if (confidenceEl) {
        confidenceEl.textContent = "".concat(data.confidence, "%");
        // Add color class based on confidence
        confidenceEl.className = 'quality-value';
        if (data.confidence >= 75) {
          confidenceEl.classList.add('high');
        } else if (data.confidence >= 50) {
          confidenceEl.classList.add('medium');
        } else {
          confidenceEl.classList.add('low');
        }
      }
      if (dataInfoEl) {
        var quality = data.dataQuality;
        dataInfoEl.textContent = "Based on ".concat(quality.monthsOfData, " month(s) of data (").concat(quality.transactionCount, " transactions)");
      }
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/import/ImportModule.js":
/*!********************************************!*\
  !*** ./src/modules/import/ImportModule.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImportModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Import Module - Bank statement import with CSV/OFX/QIF support
 */


var ImportModule = /*#__PURE__*/function () {
  function ImportModule(app) {
    _classCallCheck(this, ImportModule);
    this.app = app;

    // Import wizard state
    this.currentImportStep = 1;
    this.currentImportData = null;
    this.processedTransactions = null;
    this.sourceAccounts = [];
    this.importFormat = null;
    this.currentDelimiter = ',';
    this.importHistory = [];
    this.availableAccounts = [];
    this.handleDelimiterChange = null;
  }

  // ============================================
  // State Proxies
  // ============================================
  return _createClass(ImportModule, [{
    key: "data",
    get: function get() {
      return this.app.data;
    },
    set: function set(value) {
      this.app.data = value;
    }
  }, {
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }

    // ============================================
    // Helper Method Proxies
    // ============================================
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(date) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(date);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return this.app.getPrimaryCurrency();
    }
  }, {
    key: "loadTransactions",
    value: function loadTransactions() {
      return this.app.loadTransactions();
    }

    // ============================================
    // Import Module Methods
    // ============================================
  }, {
    key: "handleImportFile",
    value: function () {
      var _handleImportFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(file) {
        var formData, response, result, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              formData = new FormData();
              formData.append('file', file);
              _context.p = 1;
              _context.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/import/upload'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                },
                body: formData
              });
            case 2:
              response = _context.v;
              if (!response.ok) {
                _context.n = 4;
                break;
              }
              _context.n = 3;
              return response.json();
            case 3:
              result = _context.v;
              this.currentImportData = result;
              this.showImportMapping(result);
              _context.n = 5;
              break;
            case 4:
              throw new Error('Upload failed');
            case 5:
              _context.n = 7;
              break;
            case 6:
              _context.p = 6;
              _t = _context.v;
              console.error('Failed to upload file:', _t);
              OC.Notification.showTemporary('Failed to upload file');
            case 7:
              return _context.a(2);
          }
        }, _callee, this, [[1, 6]]);
      }));
      function handleImportFile(_x) {
        return _handleImportFile.apply(this, arguments);
      }
      return handleImportFile;
    }() // ============================================
    // Enhanced Import System Methods
    // ============================================
  }, {
    key: "setupImportEventListeners",
    value: function setupImportEventListeners() {
      var _this = this;
      // Tab navigation
      var tabButtons = document.querySelectorAll('.import-tab-btn');
      tabButtons.forEach(function (button) {
        button.addEventListener('click', function (e) {
          var tabName = e.target.dataset.tab;
          _this.switchImportTab(tabName);
        });
      });

      // Wizard navigation
      var nextBtn = document.getElementById('next-step-btn');
      var prevBtn = document.getElementById('prev-step-btn');
      var importBtn = document.getElementById('import-btn');
      var cancelBtn = document.getElementById('cancel-import-btn');
      if (nextBtn) {
        nextBtn.addEventListener('click', function () {
          return _this.nextImportStep();
        });
      }
      if (prevBtn) {
        prevBtn.addEventListener('click', function () {
          return _this.prevImportStep();
        });
      }
      if (importBtn) {
        importBtn.addEventListener('click', function () {
          return _this.executeImport();
        });
      }
      if (cancelBtn) {
        cancelBtn.addEventListener('click', function () {
          return _this.cancelImport();
        });
      }

      // Account selection triggers preview loading
      var importAccountSelect = document.getElementById('import-account');
      if (importAccountSelect) {
        importAccountSelect.addEventListener('change', function () {
          if (importAccountSelect.value && _this.currentImportStep === 3) {
            _this.processImportData();
          }
        });
      }

      // Column mapping change handlers
      var mappingSelects = document.querySelectorAll('#import-step-2 select');
      mappingSelects.forEach(function (select) {
        select.addEventListener('change', function () {
          return _this.updatePreviewMapping();
        });
      });

      // Preview filter checkboxes
      var showDuplicates = document.getElementById('show-duplicates');
      var showUncategorized = document.getElementById('show-uncategorized');
      if (showDuplicates) {
        showDuplicates.addEventListener('change', function () {
          return _this.filterPreviewTransactions();
        });
      }
      if (showUncategorized) {
        showUncategorized.addEventListener('change', function () {
          return _this.filterPreviewTransactions();
        });
      }

      // Initialize import state
      this.currentImportStep = 1;
      this.currentImportData = null;
      this.importHistory = [];
    }
  }, {
    key: "switchImportTab",
    value: function switchImportTab(tabName) {
      // Switch tab buttons
      document.querySelectorAll('.import-tab-btn').forEach(function (btn) {
        btn.classList.remove('active');
      });
      document.querySelector("[data-tab=\"".concat(tabName, "\"]")).classList.add('active');

      // Switch tab content
      document.querySelectorAll('.import-tab-content').forEach(function (content) {
        content.classList.remove('active');
      });
      document.getElementById("import-".concat(tabName, "-tab")).classList.add('active');

      // Load tab-specific data
      if (tabName === 'history') {
        this.loadImportHistory();
      }
    }
  }, {
    key: "showImportMapping",
    value: function showImportMapping(uploadResult) {
      var _this2 = this;
      // Switch to wizard tab if not already active
      this.switchImportTab('wizard');

      // Store source accounts for multi-account mapping
      this.sourceAccounts = uploadResult.sourceAccounts || [];
      this.importFormat = uploadResult.format;
      this.currentDelimiter = uploadResult.delimiter || ',';

      // Update file info
      var fileDetails = document.querySelector('.file-details');
      if (fileDetails) {
        fileDetails.innerHTML = "\n                <span class=\"file-name\">".concat(uploadResult.filename, "</span>\n                <span class=\"file-size\">").concat(this.formatFileSize(uploadResult.size), "</span>\n                <span class=\"record-count\">").concat(uploadResult.recordCount, " records</span>\n            ");
      }

      // Show/hide CSV options based on format
      var csvOptions = document.getElementById('csv-options');
      if (csvOptions) {
        if (uploadResult.format === 'csv') {
          csvOptions.style.display = 'block';
          var delimiterSelect = document.getElementById('csv-delimiter');
          if (delimiterSelect) {
            delimiterSelect.value = this.currentDelimiter;
            // Add change handler for delimiter to reload columns
            delimiterSelect.removeEventListener('change', this.handleDelimiterChange);
            this.handleDelimiterChange = function () {
              return _this2.reloadColumnsWithDelimiter();
            };
            delimiterSelect.addEventListener('change', this.handleDelimiterChange);
          }
        } else {
          csvOptions.style.display = 'none';
        }
      }

      // Populate column mapping dropdowns
      this.populateColumnMappings(uploadResult.columns);

      // Show preview data
      this.showMappingPreview(uploadResult.preview);

      // Move to step 2
      this.setImportStep(2);
    }
  }, {
    key: "reloadColumnsWithDelimiter",
    value: function reloadColumnsWithDelimiter() {
      var delimiterSelect = document.getElementById('csv-delimiter');
      if (!delimiterSelect) return;
      this.currentDelimiter = delimiterSelect.value;
      OC.Notification.showTemporary('Delimiter changed. File will be re-parsed in the next step.');
    }
  }, {
    key: "populateColumnMappings",
    value: function populateColumnMappings(columns) {
      var mappingSelects = {
        'map-date': document.getElementById('map-date'),
        'map-amount': document.getElementById('map-amount'),
        'map-income': document.getElementById('map-income'),
        'map-expense': document.getElementById('map-expense'),
        'map-description': document.getElementById('map-description'),
        'map-type': document.getElementById('map-type'),
        'map-vendor': document.getElementById('map-vendor'),
        'map-reference': document.getElementById('map-reference')
      };

      // Clear existing options and add columns
      Object.values(mappingSelects).forEach(function (select) {
        if (!select) return;
        var firstOption = select.firstElementChild;
        select.innerHTML = '';
        if (firstOption) select.appendChild(firstOption);
        columns.forEach(function (column, index) {
          var option = document.createElement('option');
          option.value = column;
          option.textContent = column;
          select.appendChild(option);
        });
      });

      // Auto-detect common column mappings
      this.autoDetectMappings(columns, mappingSelects);
    }
  }, {
    key: "autoDetectMappings",
    value: function autoDetectMappings(columns, mappingSelects) {
      var patterns = {
        'map-date': ['date', 'transaction date', 'trans date', 'posting date'],
        'map-amount': ['amount', 'transaction amount', 'trans amount', 'value'],
        'map-income': ['income', 'credit', 'deposits', 'deposit', 'credits', 'receipts'],
        'map-expense': ['expense', 'debit', 'withdrawals', 'withdrawal', 'debits', 'payments', 'payment'],
        'map-description': ['description', 'memo', 'details', 'transaction details'],
        'map-type': ['type', 'transaction type', 'debit/credit', 'dr/cr'],
        'map-vendor': ['vendor', 'payee', 'merchant', 'counterparty'],
        'map-reference': ['reference', 'ref', 'check number', 'transaction id']
      };
      Object.entries(patterns).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          fieldId = _ref2[0],
          patternList = _ref2[1];
        var select = mappingSelects[fieldId];
        if (!select) return;
        var matchingColumn = columns.find(function (col) {
          return patternList.some(function (pattern) {
            return col.toLowerCase().includes(pattern.toLowerCase());
          });
        });
        if (matchingColumn) {
          select.value = matchingColumn;
        }
      });
    }
  }, {
    key: "showMappingPreview",
    value: function showMappingPreview(previewData) {
      var table = document.getElementById('mapping-preview-table');
      if (!table || !previewData.length) return;

      // Create header
      var thead = table.querySelector('thead');
      var tbody = table.querySelector('tbody');
      thead.innerHTML = '';
      tbody.innerHTML = '';
      var headerRow = document.createElement('tr');
      previewData[0].forEach(function (header, index) {
        var th = document.createElement('th');
        th.textContent = "".concat(index + 1, ". ").concat(header);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      // Show first 5 rows of data
      previewData.slice(1, 6).forEach(function (row) {
        var tr = document.createElement('tr');
        row.forEach(function (cell) {
          var td = document.createElement('td');
          // Handle objects/arrays by converting to string
          if (cell === null || cell === undefined) {
            td.textContent = '';
          } else if (_typeof(cell) === 'object') {
            td.textContent = JSON.stringify(cell);
          } else {
            td.textContent = String(cell);
          }
          td.title = td.textContent; // Show full text on hover
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }
  }, {
    key: "updatePreviewMapping",
    value: function updatePreviewMapping() {
      // Update the mapping preview when selections change
      var mapping = this.getCurrentMapping();
      // Update mapping indicators in preview table
      this.highlightMappedColumns(mapping);
      this.validateMappingStep();
    }
  }, {
    key: "getCurrentMapping",
    value: function getCurrentMapping() {
      var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4, _document$getElementB5, _document$getElementB6, _document$getElementB7, _document$getElementB8, _document$getElementB9, _document$getElementB0;
      return {
        date: ((_document$getElementB = document.getElementById('map-date')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || null,
        amount: ((_document$getElementB2 = document.getElementById('map-amount')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value) || null,
        incomeColumn: ((_document$getElementB3 = document.getElementById('map-income')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.value) || null,
        expenseColumn: ((_document$getElementB4 = document.getElementById('map-expense')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value) || null,
        description: ((_document$getElementB5 = document.getElementById('map-description')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value) || null,
        type: ((_document$getElementB6 = document.getElementById('map-type')) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.value) || null,
        vendor: ((_document$getElementB7 = document.getElementById('map-vendor')) === null || _document$getElementB7 === void 0 ? void 0 : _document$getElementB7.value) || null,
        reference: ((_document$getElementB8 = document.getElementById('map-reference')) === null || _document$getElementB8 === void 0 ? void 0 : _document$getElementB8.value) || null,
        skipFirstRow: ((_document$getElementB9 = document.getElementById('skip-first-row')) === null || _document$getElementB9 === void 0 ? void 0 : _document$getElementB9.checked) || false,
        applyRules: ((_document$getElementB0 = document.getElementById('apply-rules')) === null || _document$getElementB0 === void 0 ? void 0 : _document$getElementB0.checked) || false
      };
    }
  }, {
    key: "highlightMappedColumns",
    value: function highlightMappedColumns(mapping) {
      var table = document.getElementById('mapping-preview-table');
      var headers = table.querySelectorAll('th');

      // Reset highlighting
      headers.forEach(function (th) {
        return th.classList.remove('mapped-column');
      });

      // Highlight mapped columns
      Object.values(mapping).forEach(function (columnIndex) {
        if (columnIndex !== null && columnIndex !== '') {
          var header = headers[parseInt(columnIndex)];
          if (header) header.classList.add('mapped-column');
        }
      });
    }
  }, {
    key: "nextImportStep",
    value: function () {
      var _nextImportStep = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(this.currentImportStep === 1)) {
                _context2.n = 2;
                break;
              }
              if (this.currentImportData) {
                _context2.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select a file first');
              return _context2.a(2);
            case 1:
              this.setImportStep(2);
              _context2.n = 4;
              break;
            case 2:
              if (!(this.currentImportStep === 2)) {
                _context2.n = 4;
                break;
              }
              if (this.validateMappingStep()) {
                _context2.n = 3;
                break;
              }
              return _context2.a(2);
            case 3:
              this.setImportStep(3);
              // Preview will be loaded when user selects an account
            case 4:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function nextImportStep() {
        return _nextImportStep.apply(this, arguments);
      }
      return nextImportStep;
    }()
  }, {
    key: "prevImportStep",
    value: function prevImportStep() {
      if (this.currentImportStep > 1) {
        this.setImportStep(this.currentImportStep - 1);
      }
    }
  }, {
    key: "setImportStep",
    value: function setImportStep(step) {
      this.currentImportStep = step;

      // Update progress bar
      document.querySelectorAll('.wizard-step').forEach(function (stepEl, index) {
        stepEl.classList.remove('active', 'completed');
        if (index + 1 < step) {
          stepEl.classList.add('completed');
        } else if (index + 1 === step) {
          stepEl.classList.add('active');
        }
      });

      // Show/hide steps
      document.querySelectorAll('.import-step').forEach(function (stepEl, index) {
        stepEl.classList.remove('active');
        stepEl.style.display = 'none';
        if (index + 1 === step) {
          stepEl.classList.add('active');
          stepEl.style.display = 'block';
        }
      });

      // Update navigation buttons
      var prevBtn = document.getElementById('prev-step-btn');
      var nextBtn = document.getElementById('next-step-btn');
      var importBtn = document.getElementById('import-btn');
      if (prevBtn) {
        prevBtn.style.display = step > 1 ? 'block' : 'none';
      }
      if (nextBtn) {
        nextBtn.style.display = step < 3 ? 'block' : 'none';
        nextBtn.disabled = !this.canProceedToNextStep();
      }
      if (importBtn) {
        importBtn.style.display = step === 3 ? 'block' : 'none';
      }

      // Load step-specific data
      if (step === 3) {
        this.loadAccountsForImport();
      }
    }
  }, {
    key: "canProceedToNextStep",
    value: function canProceedToNextStep() {
      if (this.currentImportStep === 1) {
        return this.currentImportData !== null;
      } else if (this.currentImportStep === 2) {
        return this.validateMappingStep();
      }
      return false;
    }
  }, {
    key: "validateMappingStep",
    value: function validateMappingStep() {
      var mapping = this.getCurrentMapping();

      // Check required fields: date and description
      var hasDate = mapping.date !== null && mapping.date !== '';
      var hasDescription = mapping.description !== null && mapping.description !== '';

      // Check amount: either single amount column OR both income and expense columns
      var hasAmount = mapping.amount !== null && mapping.amount !== '';
      var hasIncome = mapping.incomeColumn !== null && mapping.incomeColumn !== '';
      var hasExpense = mapping.expenseColumn !== null && mapping.expenseColumn !== '';
      var hasDualColumns = hasIncome || hasExpense;

      // Valid if we have (amount XOR dual-columns)
      var hasValidAmount = hasAmount && !hasDualColumns || !hasAmount && hasDualColumns;
      var isValid = hasDate && hasDescription && hasValidAmount;

      // Update next button state
      var nextBtn = document.getElementById('next-step-btn');
      if (nextBtn) {
        nextBtn.disabled = !isValid;
      }
      return isValid;
    }
  }, {
    key: "processImportData",
    value: function () {
      var _processImportData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var _document$getElementB1, _document$getElementB10, _document$getElementB11;
        var mapping, isMultiAccount, requestBody, accountMapping, _document$getElementB12, accountId, response, result, errorData, _t2;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              mapping = this.getCurrentMapping();
              isMultiAccount = this.sourceAccounts && this.sourceAccounts.length > 0; // Build request body based on import type
              requestBody = {
                fileId: this.currentImportData.fileId,
                mapping: mapping,
                skipDuplicates: !((_document$getElementB1 = (_document$getElementB10 = document.getElementById('show-duplicates')) === null || _document$getElementB10 === void 0 ? void 0 : _document$getElementB10.checked) !== null && _document$getElementB1 !== void 0 ? _document$getElementB1 : true),
                delimiter: ((_document$getElementB11 = document.getElementById('csv-delimiter')) === null || _document$getElementB11 === void 0 ? void 0 : _document$getElementB11.value) || ','
              };
              if (!isMultiAccount) {
                _context3.n = 2;
                break;
              }
              accountMapping = this.getAccountMapping();
              if (!(Object.keys(accountMapping).length === 0)) {
                _context3.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please map at least one account');
              return _context3.a(2);
            case 1:
              requestBody.accountMapping = accountMapping;
              _context3.n = 4;
              break;
            case 2:
              accountId = (_document$getElementB12 = document.getElementById('import-account')) === null || _document$getElementB12 === void 0 ? void 0 : _document$getElementB12.value;
              if (accountId) {
                _context3.n = 3;
                break;
              }
              OC.Notification.showTemporary('Please select an account first');
              return _context3.a(2);
            case 3:
              requestBody.accountId = parseInt(accountId);
            case 4:
              _context3.p = 4;
              _context3.n = 5;
              return fetch(OC.generateUrl('/apps/budget/api/import/preview'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(requestBody)
              });
            case 5:
              response = _context3.v;
              if (!response.ok) {
                _context3.n = 7;
                break;
              }
              _context3.n = 6;
              return response.json();
            case 6:
              result = _context3.v;
              this.processedTransactions = result.transactions;
              this.updateImportSummary(result);
              this.showTransactionPreview(result.transactions);
              this.filterPreviewTransactions();
              _context3.n = 9;
              break;
            case 7:
              _context3.n = 8;
              return response.json();
            case 8:
              errorData = _context3.v;
              throw new Error(errorData.error || 'Processing failed');
            case 9:
              _context3.n = 11;
              break;
            case 10:
              _context3.p = 10;
              _t2 = _context3.v;
              console.error('Failed to process import data:', _t2);
              OC.Notification.showTemporary('Failed to process import data: ' + _t2.message);
            case 11:
              return _context3.a(2);
          }
        }, _callee3, this, [[4, 10]]);
      }));
      function processImportData() {
        return _processImportData.apply(this, arguments);
      }
      return processImportData;
    }()
  }, {
    key: "updateImportSummary",
    value: function updateImportSummary(result) {
      document.getElementById('total-transactions').textContent = result.totalRows || 0;
      document.getElementById('new-transactions').textContent = result.validTransactions || 0;
      document.getElementById('duplicate-transactions').textContent = result.duplicates || 0;
      // Count transactions with categoryId set
      var categorized = (result.transactions || []).filter(function (t) {
        return t.categoryId;
      }).length;
      document.getElementById('categorized-transactions').textContent = categorized;
    }
  }, {
    key: "showTransactionPreview",
    value: function showTransactionPreview(transactions) {
      var _this3 = this;
      var tbody = document.querySelector('#preview-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!transactions || transactions.length === 0) {
        var row = document.createElement('tr');
        row.innerHTML = '<td colspan="6" style="text-align: center; padding: 20px;">No transactions to import</td>';
        tbody.appendChild(row);
        document.getElementById('preview-info').textContent = 'No transactions found';
        return;
      }
      transactions.slice(0, 50).forEach(function (transaction, index) {
        var _transaction$rowIndex;
        var row = document.createElement('tr');
        var amount = parseFloat(transaction.amount) || 0;
        var isDuplicate = transaction.isDuplicate || false;
        var statusBadge = isDuplicate ? '<span class="status-badge status-error">Duplicate</span>' : '<span class="status-badge status-success">New</span>';
        row.innerHTML = "\n                <td>\n                    <input type=\"checkbox\" ".concat(isDuplicate ? '' : 'checked', " data-row-index=\"").concat((_transaction$rowIndex = transaction.rowIndex) !== null && _transaction$rowIndex !== void 0 ? _transaction$rowIndex : index, "\">\n                </td>\n                <td>").concat(transaction.date || '', "</td>\n                <td>").concat(transaction.description || '', "</td>\n                <td class=\"").concat(amount >= 0 ? 'positive' : 'negative', "\">\n                    ").concat(_this3.formatCurrency(amount), "\n                </td>\n                <td>").concat(transaction.ruleName || 'Uncategorized', "</td>\n                <td>\n                    ").concat(statusBadge, "\n                </td>\n            ");
        tbody.appendChild(row);
      });
      document.getElementById('preview-info').textContent = "Showing ".concat(Math.min(50, transactions.length), " of ").concat(transactions.length);
    }
  }, {
    key: "filterPreviewTransactions",
    value: function filterPreviewTransactions() {
      var _document$getElementB13, _document$getElementB14, _document$getElementB15, _document$getElementB16;
      var showDuplicates = (_document$getElementB13 = (_document$getElementB14 = document.getElementById('show-duplicates')) === null || _document$getElementB14 === void 0 ? void 0 : _document$getElementB14.checked) !== null && _document$getElementB13 !== void 0 ? _document$getElementB13 : true;
      var showUncategorized = (_document$getElementB15 = (_document$getElementB16 = document.getElementById('show-uncategorized')) === null || _document$getElementB16 === void 0 ? void 0 : _document$getElementB16.checked) !== null && _document$getElementB15 !== void 0 ? _document$getElementB15 : true;
      var tbody = document.querySelector('#preview-table tbody');
      if (!tbody) return;
      var rows = tbody.querySelectorAll('tr');
      var visibleCount = 0;
      rows.forEach(function (row) {
        var _row$cells$, _statusBadge$textCont;
        var statusBadge = row.querySelector('.status-badge');
        var category = (_row$cells$ = row.cells[4]) === null || _row$cells$ === void 0 || (_row$cells$ = _row$cells$.textContent) === null || _row$cells$ === void 0 ? void 0 : _row$cells$.trim();
        var isDuplicate = (statusBadge === null || statusBadge === void 0 || (_statusBadge$textCont = statusBadge.textContent) === null || _statusBadge$textCont === void 0 ? void 0 : _statusBadge$textCont.trim()) === 'Duplicate';
        var isUncategorized = category === 'Uncategorized';
        var shouldShow = true;
        if (isDuplicate && !showDuplicates) {
          shouldShow = false;
        }
        if (isUncategorized && !showUncategorized) {
          shouldShow = false;
        }
        if (shouldShow) {
          row.style.display = '';
          visibleCount++;
        } else {
          row.style.display = 'none';
        }
      });

      // Update the preview info text
      var totalCount = rows.length;
      document.getElementById('preview-info').textContent = "Showing ".concat(visibleCount, " of ").concat(totalCount);
    }
  }, {
    key: "loadAccountsForImport",
    value: function () {
      var _loadAccountsForImport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var response, accounts, singleAccountSection, multiAccountSection, select, _t3;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              _context4.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/accounts'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context4.v;
              _context4.n = 2;
              return response.json();
            case 2:
              accounts = _context4.v;
              this.availableAccounts = accounts;
              singleAccountSection = document.getElementById('single-account-selection');
              multiAccountSection = document.getElementById('multi-account-mapping'); // Check if we have multi-account OFX/QIF file
              if (this.sourceAccounts && this.sourceAccounts.length > 0) {
                // Show multi-account mapping UI
                if (singleAccountSection) singleAccountSection.style.display = 'none';
                if (multiAccountSection) multiAccountSection.style.display = 'block';
                this.renderAccountMappingUI(accounts);
              } else {
                // Show single account selection (for CSV)
                if (singleAccountSection) singleAccountSection.style.display = 'flex';
                if (multiAccountSection) multiAccountSection.style.display = 'none';
                select = document.getElementById('import-account');
                if (select) {
                  select.innerHTML = '<option value="">Select account...</option>';
                  accounts.forEach(function (account) {
                    var option = document.createElement('option');
                    option.value = account.id;
                    var accountNum = account.accountNumber ? " - ".concat(account.accountNumber) : '';
                    option.textContent = "".concat(account.name, " (").concat(account.type).concat(accountNum, ")");
                    select.appendChild(option);
                  });
                }
              }
              _context4.n = 4;
              break;
            case 3:
              _context4.p = 3;
              _t3 = _context4.v;
              console.error('Failed to load accounts:', _t3);
            case 4:
              return _context4.a(2);
          }
        }, _callee4, this, [[0, 3]]);
      }));
      function loadAccountsForImport() {
        return _loadAccountsForImport.apply(this, arguments);
      }
      return loadAccountsForImport;
    }()
  }, {
    key: "renderAccountMappingUI",
    value: function renderAccountMappingUI(accounts) {
      var _this4 = this;
      var container = document.getElementById('account-mapping-list');
      if (!container) return;
      container.innerHTML = '';
      this.sourceAccounts.forEach(function (sourceAccount) {
        var row = document.createElement('div');
        row.className = 'account-mapping-row';
        row.dataset.sourceAccountId = sourceAccount.accountId;

        // Build details string
        var details = [];
        if (sourceAccount.type) details.push(sourceAccount.type);
        if (sourceAccount.currency) details.push(sourceAccount.currency);
        if (sourceAccount.transactionCount) details.push("".concat(sourceAccount.transactionCount, " transactions"));
        if (sourceAccount.ledgerBalance !== null && sourceAccount.ledgerBalance !== undefined) {
          details.push("Balance: ".concat(_this4.formatCurrency(sourceAccount.ledgerBalance)));
        }

        // Build account options HTML with auto-match selection
        var suggestedMatch = sourceAccount.suggestedMatch;
        var optionsHtml = '<option value="">Skip this account</option>';
        accounts.forEach(function (account) {
          var accountNum = account.accountNumber ? " - ".concat(account.accountNumber) : '';
          var selected = suggestedMatch === account.id ? ' selected' : '';
          optionsHtml += "<option value=\"".concat(account.id, "\"").concat(selected, ">").concat(account.name, " (").concat(account.type).concat(accountNum, ")</option>");
        });
        row.innerHTML = "\n                <div class=\"source-account-info\">\n                    <span class=\"source-account-id\">".concat(sourceAccount.accountId, "</span>\n                    <span class=\"source-account-details\">").concat(details.join('  '), "</span>\n                </div>\n                <span class=\"mapping-arrow\">\u2192</span>\n                <select class=\"destination-account-select\" data-source-id=\"").concat(sourceAccount.accountId, "\">\n                    ").concat(optionsHtml, "\n                </select>\n            ");
        container.appendChild(row);
      });

      // Add change listeners to trigger preview
      container.querySelectorAll('.destination-account-select').forEach(function (select) {
        select.addEventListener('change', function () {
          if (_this4.hasAnyAccountMapping()) {
            _this4.processImportData();
          }
        });
      });

      // Auto-trigger preview if any accounts were auto-matched
      if (this.hasAnyAccountMapping()) {
        this.processImportData();
      }
    }
  }, {
    key: "hasAnyAccountMapping",
    value: function hasAnyAccountMapping() {
      var selects = document.querySelectorAll('.destination-account-select');
      return Array.from(selects).some(function (select) {
        return select.value;
      });
    }
  }, {
    key: "getAccountMapping",
    value: function getAccountMapping() {
      var mapping = {};
      document.querySelectorAll('.destination-account-select').forEach(function (select) {
        if (select.value) {
          mapping[select.dataset.sourceId] = parseInt(select.value);
        }
      });
      return mapping;
    }
  }, {
    key: "executeImport",
    value: function () {
      var _executeImport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var _this$currentImportDa, _document$getElementB17, _document$getElementB18, _document$getElementB19;
        var mapping, isMultiAccount, requestBody, accountMapping, accountId, importBtn, originalText, response, responseText, result, _t4, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              if ((_this$currentImportDa = this.currentImportData) !== null && _this$currentImportDa !== void 0 && _this$currentImportDa.fileId) {
                _context5.n = 1;
                break;
              }
              OC.Notification.showTemporary('No file data available');
              return _context5.a(2);
            case 1:
              mapping = this.getCurrentMapping();
              isMultiAccount = this.sourceAccounts && this.sourceAccounts.length > 0; // Build request body based on import type
              requestBody = {
                fileId: this.currentImportData.fileId,
                mapping: mapping,
                skipDuplicates: !((_document$getElementB17 = (_document$getElementB18 = document.getElementById('show-duplicates')) === null || _document$getElementB18 === void 0 ? void 0 : _document$getElementB18.checked) !== null && _document$getElementB17 !== void 0 ? _document$getElementB17 : true),
                applyRules: true,
                delimiter: ((_document$getElementB19 = document.getElementById('csv-delimiter')) === null || _document$getElementB19 === void 0 ? void 0 : _document$getElementB19.value) || ','
              };
              if (!isMultiAccount) {
                _context5.n = 3;
                break;
              }
              accountMapping = this.getAccountMapping();
              if (!(Object.keys(accountMapping).length === 0)) {
                _context5.n = 2;
                break;
              }
              OC.Notification.showTemporary('Please map at least one account');
              return _context5.a(2);
            case 2:
              requestBody.accountMapping = accountMapping;
              _context5.n = 5;
              break;
            case 3:
              accountId = document.getElementById('import-account').value;
              if (accountId) {
                _context5.n = 4;
                break;
              }
              OC.Notification.showTemporary('Please select an account');
              return _context5.a(2);
            case 4:
              requestBody.accountId = parseInt(accountId);
            case 5:
              // Show loading state on import button
              importBtn = document.getElementById('import-btn');
              originalText = importBtn.textContent;
              importBtn.disabled = true;
              importBtn.textContent = 'Importing...';
              _context5.p = 6;
              _context5.n = 7;
              return fetch(OC.generateUrl('/apps/budget/api/import/process'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(requestBody)
              });
            case 7:
              response = _context5.v;
              _context5.n = 8;
              return response.text();
            case 8:
              responseText = _context5.v;
              _context5.p = 9;
              result = JSON.parse(responseText);
              _context5.n = 11;
              break;
            case 10:
              _context5.p = 10;
              _t4 = _context5.v;
              console.error('Server response:', responseText);
              throw new Error("Server error (".concat(response.status, "): Invalid response"));
            case 11:
              if (!response.ok) {
                _context5.n = 12;
                break;
              }
              OC.Notification.showTemporary("Successfully imported ".concat(result.imported, " transactions (").concat(result.skipped, " skipped)"));
              this.resetImportWizard();
              this.loadTransactions();
              _context5.n = 13;
              break;
            case 12:
              throw new Error(result.error || 'Import failed');
            case 13:
              _context5.n = 15;
              break;
            case 14:
              _context5.p = 14;
              _t5 = _context5.v;
              console.error('Failed to execute import:', _t5);
              OC.Notification.showTemporary('Failed to import transactions: ' + _t5.message);
            case 15:
              _context5.p = 15;
              // Restore button state
              importBtn.disabled = false;
              importBtn.textContent = originalText;
              return _context5.f(15);
            case 16:
              return _context5.a(2);
          }
        }, _callee5, this, [[9, 10], [6, 14, 15, 16]]);
      }));
      function executeImport() {
        return _executeImport.apply(this, arguments);
      }
      return executeImport;
    }()
  }, {
    key: "cancelImport",
    value: function cancelImport() {
      this.resetImportWizard();
    }
  }, {
    key: "resetImportWizard",
    value: function resetImportWizard() {
      this.currentImportStep = 1;
      this.currentImportData = null;
      this.processedTransactions = null;
      this.sourceAccounts = [];
      this.importFormat = null;
      this.setImportStep(1);

      // Clear form fields
      document.getElementById('import-file-input').value = '';
      document.querySelectorAll('#import-step-2 select').forEach(function (select) {
        select.selectedIndex = 0;
      });

      // Reset account selection UI
      var singleAccountSection = document.getElementById('single-account-selection');
      var multiAccountSection = document.getElementById('multi-account-mapping');
      if (singleAccountSection) singleAccountSection.style.display = 'flex';
      if (multiAccountSection) multiAccountSection.style.display = 'none';

      // Clear preview tables
      var mappingPreviewBody = document.querySelector('#mapping-preview-table tbody');
      var previewTableBody = document.querySelector('#preview-table tbody');
      var accountMappingList = document.getElementById('account-mapping-list');
      if (mappingPreviewBody) mappingPreviewBody.innerHTML = '';
      if (previewTableBody) previewTableBody.innerHTML = '';
      if (accountMappingList) accountMappingList.innerHTML = '';
    }

    // Import History Management
  }, {
    key: "loadImportHistory",
    value: function () {
      var _loadImportHistory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var response, history, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              _context6.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/import/history'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context6.v;
              _context6.n = 2;
              return response.json();
            case 2:
              history = _context6.v;
              this.importHistory = history;
              this.renderImportHistory(history);
              _context6.n = 4;
              break;
            case 3:
              _context6.p = 3;
              _t6 = _context6.v;
              console.error('Failed to load import history:', _t6);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this, [[0, 3]]);
      }));
      function loadImportHistory() {
        return _loadImportHistory.apply(this, arguments);
      }
      return loadImportHistory;
    }()
  }, {
    key: "renderImportHistory",
    value: function renderImportHistory(history) {
      var _this5 = this;
      var tbody = document.querySelector('#history-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      history.forEach(function (item) {
        var row = document.createElement('tr');
        row.innerHTML = "\n                <td>".concat(_this5.formatDate(item.importDate), "</td>\n                <td>").concat(item.filename, "</td>\n                <td>").concat(item.accountName, "</td>\n                <td>").concat(item.transactionCount, "</td>\n                <td>\n                    <span class=\"status-badge status-").concat(item.status, "\">\n                        ").concat(item.status.charAt(0).toUpperCase() + item.status.slice(1), "\n                    </span>\n                </td>\n                <td>\n                    <button class=\"icon-download import-download-btn\" data-import-id=\"").concat(item.id, "\" title=\"Download\"></button>\n                    <button class=\"icon-delete import-rollback-btn\" data-import-id=\"").concat(item.id, "\" title=\"Rollback\"></button>\n                </td>\n            ");
        tbody.appendChild(row);
      });

      // Setup event listeners
      document.querySelectorAll('.import-download-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          var importId = parseInt(btn.dataset.importId);
          _this5.downloadImport(importId);
        });
      });
      document.querySelectorAll('.import-rollback-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          var importId = parseInt(btn.dataset.importId);
          _this5.rollbackImport(importId);
        });
      });
    }
  }, {
    key: "formatFileSize",
    value: function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      var k = 1024;
      var sizes = ['Bytes', 'KB', 'MB', 'GB'];
      var i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  }, {
    key: "downloadImport",
    value: function () {
      var _downloadImport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(importId) {
        var response, blob, url, a, _t7;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              _context7.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/import/download/".concat(importId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context7.v;
              if (!response.ok) {
                _context7.n = 3;
                break;
              }
              _context7.n = 2;
              return response.blob();
            case 2:
              blob = _context7.v;
              url = window.URL.createObjectURL(blob);
              a = document.createElement('a');
              a.href = url;
              a.download = "import_".concat(importId, ".csv");
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);
              _context7.n = 4;
              break;
            case 3:
              throw new Error('Download failed');
            case 4:
              _context7.n = 6;
              break;
            case 5:
              _context7.p = 5;
              _t7 = _context7.v;
              console.error('Failed to download import:', _t7);
              OC.Notification.showTemporary('Failed to download import file');
            case 6:
              return _context7.a(2);
          }
        }, _callee7, null, [[0, 5]]);
      }));
      function downloadImport(_x2) {
        return _downloadImport.apply(this, arguments);
      }
      return downloadImport;
    }()
  }, {
    key: "rollbackImport",
    value: function () {
      var _rollbackImport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(importId) {
        var response, result, errorData, _t8;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              if (confirm('Are you sure you want to rollback this import? All imported transactions will be deleted.')) {
                _context8.n = 1;
                break;
              }
              return _context8.a(2);
            case 1:
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/import/rollback/".concat(importId)), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                }
              });
            case 2:
              response = _context8.v;
              if (!response.ok) {
                _context8.n = 4;
                break;
              }
              _context8.n = 3;
              return response.json();
            case 3:
              result = _context8.v;
              OC.Notification.showTemporary("Rolled back ".concat(result.deleted, " transactions"));
              this.loadImportHistory();
              this.loadTransactions();
              _context8.n = 6;
              break;
            case 4:
              _context8.n = 5;
              return response.json();
            case 5:
              errorData = _context8.v;
              throw new Error(errorData.error || 'Rollback failed');
            case 6:
              _context8.n = 8;
              break;
            case 7:
              _context8.p = 7;
              _t8 = _context8.v;
              console.error('Failed to rollback import:', _t8);
              OC.Notification.showTemporary('Failed to rollback import: ' + _t8.message);
            case 8:
              return _context8.a(2);
          }
        }, _callee8, this, [[1, 7]]);
      }));
      function rollbackImport(_x3) {
        return _rollbackImport.apply(this, arguments);
      }
      return rollbackImport;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/income/IncomeModule.js":
/*!********************************************!*\
  !*** ./src/modules/income/IncomeModule.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IncomeModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Income Module - Recurring income tracking and detection
 */


var IncomeModule = /*#__PURE__*/function () {
  function IncomeModule(app) {
    _classCallCheck(this, IncomeModule);
    this.app = app;
    this._eventsSetup = false;
    this._detectedIncome = [];
    this._undoTimer = null;
    this._undoData = null;
  }

  // Getters for app state
  return _createClass(IncomeModule, [{
    key: "recurringIncome",
    get: function get() {
      return this.app.recurringIncome;
    },
    set: function set(value) {
      this.app.recurringIncome = value;
    }
  }, {
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "loadIncomeView",
    value: function () {
      var _loadIncomeView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return this.loadIncomeSummary();
            case 1:
              _context.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/recurring-income'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context.v;
              if (response.ok) {
                _context.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              _context.n = 4;
              return response.json();
            case 4:
              this.recurringIncome = _context.v;
              this.renderRecurringIncome(this.recurringIncome);

              // Setup event listeners (only once)
              if (!this._eventsSetup) {
                this.setupIncomeEventListeners();
                this._eventsSetup = true;
              }

              // Populate dropdowns in income modal
              this.populateIncomeModalDropdowns();
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              console.error('Failed to load recurring income:', _t);
              OC.Notification.showTemporary('Failed to load recurring income');
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[0, 5]]);
      }));
      function loadIncomeView() {
        return _loadIncomeView.apply(this, arguments);
      }
      return loadIncomeView;
    }()
  }, {
    key: "loadIncomeSummary",
    value: function () {
      var _loadIncomeSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response, summary, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/recurring-income/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context2.n = 3;
              return response.json();
            case 3:
              summary = _context2.v;
              // Update summary cards
              document.getElementById('income-expected-count').textContent = summary.expectedThisMonth || 0;
              document.getElementById('income-monthly-total').textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(summary.monthlyTotal || 0, null, this.settings);
              document.getElementById('income-received-count').textContent = summary.receivedThisMonth || 0;
              document.getElementById('income-active-count').textContent = summary.activeCount || 0;
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t2 = _context2.v;
              console.error('Failed to load income summary:', _t2);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 4]]);
      }));
      function loadIncomeSummary() {
        return _loadIncomeSummary.apply(this, arguments);
      }
      return loadIncomeSummary;
    }()
  }, {
    key: "renderRecurringIncome",
    value: function renderRecurringIncome(incomeItems) {
      var _this = this;
      var incomeList = document.getElementById('income-list');
      var emptyIncome = document.getElementById('empty-income');
      if (!incomeItems || incomeItems.length === 0) {
        incomeList.innerHTML = '';
        emptyIncome.style.display = 'flex';
        return;
      }
      emptyIncome.style.display = 'none';
      incomeList.innerHTML = incomeItems.map(function (income) {
        var nextDate = income.nextExpectedDate || income.next_expected_date;
        var isReceivedThisMonth = _this.isIncomeReceivedThisMonth(income);
        var isExpectedSoon = !isReceivedThisMonth && nextDate && _this.isExpectedSoon(nextDate);
        var statusClass = '';
        var statusText = '';
        if (isReceivedThisMonth) {
          statusClass = 'received';
          statusText = 'Received';
        } else if (isExpectedSoon) {
          statusClass = 'expected-soon';
          statusText = 'Expected Soon';
        } else {
          statusClass = 'upcoming';
          statusText = 'Upcoming';
        }
        var frequency = income.frequency || 'monthly';
        var frequencyLabel = frequency.charAt(0).toUpperCase() + frequency.slice(1);
        var source = income.source || '';
        return "\n                <div class=\"income-card ".concat(statusClass, "\" data-income-id=\"").concat(income.id, "\" data-status=\"").concat(statusClass, "\">\n                    <div class=\"income-header\">\n                        <div class=\"income-info\">\n                            <h4 class=\"income-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(income.name), "</h4>\n                            <span class=\"income-frequency\">").concat(frequencyLabel, "</span>\n                            ").concat(source ? "<span class=\"income-source\">".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(source), "</span>") : '', "\n                        </div>\n                        <div class=\"income-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(income.amount, null, _this.settings), "</div>\n                    </div>\n                    <div class=\"income-details\">\n                        <div class=\"income-next-date\">\n                            <span class=\"icon-calendar\" aria-hidden=\"true\"></span>\n                            ").concat(nextDate ? _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(nextDate, _this.settings) : 'No date set', "\n                        </div>\n                        <div class=\"income-status ").concat(statusClass, "\">\n                            <span class=\"status-badge\">").concat(statusText, "</span>\n                        </div>\n                    </div>\n                    <div class=\"income-actions\">\n                        ").concat(!isReceivedThisMonth ? "\n                            <button class=\"income-action-btn income-received-btn\" data-income-id=\"".concat(income.id, "\" title=\"Mark as received\">\n                                <span class=\"icon-checkmark\" aria-hidden=\"true\"></span>\n                                Mark Received\n                            </button>\n                        ") : '', "\n                        <button class=\"income-action-btn income-edit-btn\" data-income-id=\"").concat(income.id, "\" title=\"Edit income\">\n                            <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                        </button>\n                        <button class=\"income-action-btn income-delete-btn\" data-income-id=\"").concat(income.id, "\" title=\"Delete income\">\n                            <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                        </button>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "isIncomeReceivedThisMonth",
    value: function isIncomeReceivedThisMonth(income) {
      var lastReceived = income.lastReceivedDate || income.last_received_date;
      if (!lastReceived) return false;
      var receivedDate = new Date(lastReceived);
      var now = new Date();
      return receivedDate.getMonth() === now.getMonth() && receivedDate.getFullYear() === now.getFullYear();
    }
  }, {
    key: "isExpectedSoon",
    value: function isExpectedSoon(dateStr) {
      var expectedDate = new Date(dateStr);
      var now = new Date();
      var diffDays = Math.ceil((expectedDate - now) / (1000 * 60 * 60 * 24));
      return diffDays >= 0 && diffDays <= 7;
    }
  }, {
    key: "filterIncome",
    value: function filterIncome(filter) {
      var incomeCards = document.querySelectorAll('.income-card');
      incomeCards.forEach(function (card) {
        var status = card.dataset.status;
        var show = false;
        switch (filter) {
          case 'all':
            show = true;
            break;
          case 'expected':
            show = status === 'expected-soon' || status === 'upcoming';
            break;
          case 'received':
            show = status === 'received';
            break;
          default:
            show = true;
        }
        card.style.display = show ? 'flex' : 'none';
      });
    }
  }, {
    key: "setupIncomeEventListeners",
    value: function setupIncomeEventListeners() {
      var _this2 = this;
      // Add income button
      var addIncomeBtn = document.getElementById('add-income-btn');
      var emptyIncomeAddBtn = document.getElementById('empty-income-add-btn');
      if (addIncomeBtn) {
        addIncomeBtn.addEventListener('click', function () {
          return _this2.showIncomeModal();
        });
      }
      if (emptyIncomeAddBtn) {
        emptyIncomeAddBtn.addEventListener('click', function () {
          return _this2.showIncomeModal();
        });
      }

      // Detect income button
      var detectIncomeBtn = document.getElementById('detect-income-btn');
      if (detectIncomeBtn) {
        detectIncomeBtn.addEventListener('click', function () {
          return _this2.detectIncome();
        });
      }

      // Close detected income panel
      var closeDetectedIncomePanel = document.getElementById('close-detected-income-panel');
      if (closeDetectedIncomePanel) {
        closeDetectedIncomePanel.addEventListener('click', function () {
          document.getElementById('detected-income-panel').style.display = 'none';
        });
      }

      // Cancel detected income
      var cancelDetectedIncomeBtn = document.getElementById('cancel-detected-income-btn');
      if (cancelDetectedIncomeBtn) {
        cancelDetectedIncomeBtn.addEventListener('click', function () {
          document.getElementById('detected-income-panel').style.display = 'none';
        });
      }

      // Add selected income from detection
      var addSelectedIncomeBtn = document.getElementById('add-selected-income-btn');
      if (addSelectedIncomeBtn) {
        addSelectedIncomeBtn.addEventListener('click', function () {
          return _this2.addSelectedDetectedIncome();
        });
      }

      // Income modal form
      var incomeForm = document.getElementById('income-form');
      if (incomeForm) {
        incomeForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveIncome();
        });
      }

      // Income modal cancel
      var incomeModal = document.getElementById('income-modal');
      if (incomeModal) {
        incomeModal.querySelectorAll('.cancel-btn').forEach(function (btn) {
          btn.addEventListener('click', function () {
            return _this2.hideIncomeModal();
          });
        });
        incomeModal.addEventListener('click', function (e) {
          if (e.target === incomeModal) _this2.hideIncomeModal();
        });
      }

      // Frequency change (show/hide month selector)
      var frequencySelect = document.getElementById('income-frequency');
      if (frequencySelect) {
        frequencySelect.addEventListener('change', function () {
          return _this2.updateIncomeFormFields();
        });
      }

      // Filter tabs
      var incomeTabs = document.querySelectorAll('.income-tabs .tab-button');
      incomeTabs.forEach(function (tab) {
        tab.addEventListener('click', function () {
          incomeTabs.forEach(function (t) {
            return t.classList.remove('active');
          });
          tab.classList.add('active');
          _this2.filterIncome(tab.dataset.filter);
        });
      });

      // Income list actions (delegated)
      var incomeList = document.getElementById('income-list');
      if (incomeList) {
        incomeList.addEventListener('click', function (e) {
          var editBtn = e.target.closest('.income-edit-btn');
          var deleteBtn = e.target.closest('.income-delete-btn');
          var receivedBtn = e.target.closest('.income-received-btn');
          if (editBtn) {
            var incomeId = parseInt(editBtn.dataset.incomeId);
            var income = _this2.recurringIncome.find(function (i) {
              return i.id === incomeId;
            });
            if (income) _this2.showIncomeModal(income);
          }
          if (deleteBtn) {
            var _incomeId = parseInt(deleteBtn.dataset.incomeId);
            _this2.deleteIncome(_incomeId);
          }
          if (receivedBtn) {
            var _incomeId2 = parseInt(receivedBtn.dataset.incomeId);
            _this2.markIncomeReceived(_incomeId2);
          }
        });
      }
    }
  }, {
    key: "showIncomeModal",
    value: function showIncomeModal() {
      var income = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('income-modal');
      var title = document.getElementById('income-modal-title');
      var form = document.getElementById('income-form');
      form.reset();
      document.getElementById('income-id').value = '';
      if (income) {
        title.textContent = 'Edit Recurring Income';
        document.getElementById('income-id').value = income.id;
        document.getElementById('income-name').value = income.name || '';
        document.getElementById('income-amount').value = income.amount || '';
        document.getElementById('income-source').value = income.source || '';
        document.getElementById('income-frequency').value = income.frequency || 'monthly';
        document.getElementById('income-expected-day').value = income.expectedDay || income.expected_day || '';
        document.getElementById('income-expected-month').value = income.expectedMonth || income.expected_month || '';
        document.getElementById('income-category').value = income.categoryId || income.category_id || '';
        document.getElementById('income-account').value = income.accountId || income.account_id || '';
        document.getElementById('income-auto-pattern').value = income.autoDetectPattern || income.auto_detect_pattern || '';
        document.getElementById('income-notes').value = income.notes || '';
      } else {
        title.textContent = 'Add Recurring Income';
      }
      this.updateIncomeFormFields();
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }
  }, {
    key: "hideIncomeModal",
    value: function hideIncomeModal() {
      var modal = document.getElementById('income-modal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }
  }, {
    key: "updateIncomeFormFields",
    value: function updateIncomeFormFields() {
      var frequency = document.getElementById('income-frequency').value;
      var expectedDayGroup = document.getElementById('expected-day-group');
      var expectedMonthGroup = document.getElementById('expected-month-group');

      // Show expected month only for yearly income
      if (frequency === 'yearly') {
        expectedMonthGroup.style.display = 'block';
      } else {
        expectedMonthGroup.style.display = 'none';
      }

      // Update expected day label based on frequency
      var expectedDayLabel = expectedDayGroup.querySelector('label');
      var expectedDayHelp = document.getElementById('income-expected-day-help');
      if (frequency === 'weekly') {
        expectedDayLabel.textContent = 'Expected Day (1-7)';
        expectedDayHelp.textContent = 'Day of the week (1=Monday, 7=Sunday)';
        document.getElementById('income-expected-day').max = 7;
      } else {
        expectedDayLabel.textContent = 'Expected Day';
        expectedDayHelp.textContent = 'Day of the month when income is expected';
        document.getElementById('income-expected-day').max = 31;
      }
    }
  }, {
    key: "populateIncomeModalDropdowns",
    value: function populateIncomeModalDropdowns() {
      // Populate category dropdown (income categories)
      var categorySelect = document.getElementById('income-category');
      if (categorySelect && this.categories) {
        var currentValue = categorySelect.value;
        categorySelect.innerHTML = '<option value="">No category</option>';
        this.categories.filter(function (c) {
          return c.type === 'income';
        }).forEach(function (cat) {
          categorySelect.innerHTML += "<option value=\"".concat(cat.id, "\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(cat.name), "</option>");
        });
        if (currentValue) categorySelect.value = currentValue;
      }

      // Populate account dropdown
      var accountSelect = document.getElementById('income-account');
      if (accountSelect && this.accounts) {
        var _currentValue = accountSelect.value;
        accountSelect.innerHTML = '<option value="">No specific account</option>';
        this.accounts.forEach(function (account) {
          accountSelect.innerHTML += "<option value=\"".concat(account.id, "\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(account.name), "</option>");
        });
        if (_currentValue) accountSelect.value = _currentValue;
      }
    }
  }, {
    key: "saveIncome",
    value: function () {
      var _saveIncome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var id, isNew, data, url, response, error, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              id = document.getElementById('income-id').value;
              isNew = !id;
              data = {
                name: document.getElementById('income-name').value.trim(),
                amount: parseFloat(document.getElementById('income-amount').value) || 0,
                source: document.getElementById('income-source').value.trim() || null,
                frequency: document.getElementById('income-frequency').value,
                expectedDay: parseInt(document.getElementById('income-expected-day').value) || null,
                expectedMonth: parseInt(document.getElementById('income-expected-month').value) || null,
                categoryId: parseInt(document.getElementById('income-category').value) || null,
                accountId: parseInt(document.getElementById('income-account').value) || null,
                autoDetectPattern: document.getElementById('income-auto-pattern').value.trim() || null,
                notes: document.getElementById('income-notes').value.trim() || null
              };
              url = isNew ? OC.generateUrl('/apps/budget/api/recurring-income') : OC.generateUrl("/apps/budget/api/recurring-income/".concat(id));
              _context3.n = 1;
              return fetch(url, {
                method: isNew ? 'POST' : 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(data)
              });
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 3;
                break;
              }
              _context3.n = 2;
              return response.json();
            case 2:
              error = _context3.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              this.hideIncomeModal();
              OC.Notification.showTemporary(isNew ? 'Income source created successfully' : 'Income source updated successfully');
              _context3.n = 4;
              return this.loadIncomeView();
            case 4:
              _context3.n = 6;
              break;
            case 5:
              _context3.p = 5;
              _t3 = _context3.v;
              console.error('Failed to save income:', _t3);
              OC.Notification.showTemporary(_t3.message || 'Failed to save income');
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 5]]);
      }));
      function saveIncome() {
        return _saveIncome.apply(this, arguments);
      }
      return saveIncome;
    }()
  }, {
    key: "deleteIncome",
    value: function () {
      var _deleteIncome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(incomeId) {
        var response, _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              if (confirm('Are you sure you want to delete this recurring income?')) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              _context4.p = 1;
              _context4.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/recurring-income/".concat(incomeId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              OC.Notification.showTemporary('Income source deleted successfully');
              _context4.n = 4;
              return this.loadIncomeView();
            case 4:
              _context4.n = 6;
              break;
            case 5:
              _context4.p = 5;
              _t4 = _context4.v;
              console.error('Failed to delete income:', _t4);
              OC.Notification.showTemporary('Failed to delete income');
            case 6:
              return _context4.a(2);
          }
        }, _callee4, this, [[1, 5]]);
      }));
      function deleteIncome(_x) {
        return _deleteIncome.apply(this, arguments);
      }
      return deleteIncome;
    }()
  }, {
    key: "markIncomeReceived",
    value: function () {
      var _markIncomeReceived = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(incomeId) {
        var _this3 = this;
        var income, previousReceivedDate, currentDate, response, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              // Find the income item to store its previous state
              income = this.recurringIncome.find(function (i) {
                return i.id === incomeId;
              });
              if (income) {
                _context5.n = 1;
                break;
              }
              throw new Error('Income not found');
            case 1:
              previousReceivedDate = income.lastReceivedDate || income.last_received_date || null;
              currentDate = new Date().toISOString().split('T')[0]; // Mark as received on the server
              _context5.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/recurring-income/".concat(incomeId, "/received")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  receivedDate: currentDate
                })
              });
            case 2:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              // Store undo data BEFORE reloading
              this._undoData = {
                incomeId: incomeId,
                previousReceivedDate: previousReceivedDate,
                action: 'markReceived'
              };

              // Update local state immediately
              _context5.n = 4;
              return this.loadIncomeView();
            case 4:
              // Clear any existing undo timer
              if (this._undoTimer) {
                clearTimeout(this._undoTimer);
              }

              // Show notification with undo option
              this.showUndoNotification('Income marked as received', function () {
                return _this3.undoMarkReceived();
              });

              // Set timer to clear undo data after 5 seconds
              this._undoTimer = setTimeout(function () {
                _this3._undoData = null;
                _this3._undoTimer = null;
              }, 5000);
              _context5.n = 6;
              break;
            case 5:
              _context5.p = 5;
              _t5 = _context5.v;
              console.error('Failed to mark income as received:', _t5);
              OC.Notification.showTemporary('Failed to mark income as received');
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this, [[0, 5]]);
      }));
      function markIncomeReceived(_x2) {
        return _markIncomeReceived.apply(this, arguments);
      }
      return markIncomeReceived;
    }()
  }, {
    key: "undoMarkReceived",
    value: function () {
      var _undoMarkReceived = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var _this$_undoData, incomeId, previousReceivedDate, response, errorData, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              if (this._undoData) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              _context6.p = 1;
              _this$_undoData = this._undoData, incomeId = _this$_undoData.incomeId, previousReceivedDate = _this$_undoData.previousReceivedDate; // Clear the undo timer
              if (this._undoTimer) {
                clearTimeout(this._undoTimer);
                this._undoTimer = null;
              }

              // Use the update endpoint to restore the previous state
              // This allows us to set lastReceivedDate to null if needed
              _context6.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/recurring-income/".concat(incomeId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  lastReceivedDate: previousReceivedDate
                })
              });
            case 2:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 4;
                break;
              }
              _context6.n = 3;
              return response.json()["catch"](function () {
                return {};
              });
            case 3:
              errorData = _context6.v;
              throw new Error(errorData.error || "HTTP ".concat(response.status));
            case 4:
              // Clear undo data
              this._undoData = null;

              // Reload the view
              _context6.n = 5;
              return this.loadIncomeView();
            case 5:
              OC.Notification.showTemporary('Action undone');
              _context6.n = 7;
              break;
            case 6:
              _context6.p = 6;
              _t6 = _context6.v;
              console.error('Failed to undo mark received:', _t6);
              OC.Notification.showTemporary("Failed to undo action: ".concat(_t6.message));
            case 7:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 6]]);
      }));
      function undoMarkReceived() {
        return _undoMarkReceived.apply(this, arguments);
      }
      return undoMarkReceived;
    }()
  }, {
    key: "showUndoNotification",
    value: function showUndoNotification(message, undoCallback) {
      // Create a custom notification element with an undo button
      var notification = document.createElement('div');
      notification.className = 'undo-notification';
      notification.innerHTML = "\n            <span class=\"undo-message\">".concat(message, "</span>\n            <button class=\"undo-btn\">Undo</button>\n        ");

      // Style the notification
      Object.assign(notification.style, {
        position: 'fixed',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: '#333',
        color: '#fff',
        padding: '12px 20px',
        borderRadius: '4px',
        display: 'flex',
        alignItems: 'center',
        gap: '15px',
        zIndex: '10000',
        boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
        animation: 'slideUp 0.3s ease-out'
      });
      var undoBtn = notification.querySelector('.undo-btn');
      Object.assign(undoBtn.style, {
        backgroundColor: '#fff',
        color: '#333',
        border: 'none',
        padding: '6px 12px',
        borderRadius: '3px',
        cursor: 'pointer',
        fontWeight: 'bold',
        fontSize: '13px'
      });
      undoBtn.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        undoCallback();
        notification.remove();
      });
      document.body.appendChild(notification);

      // Auto-remove after 5 seconds
      setTimeout(function () {
        notification.style.animation = 'slideDown 0.3s ease-in';
        setTimeout(function () {
          return notification.remove();
        }, 300);
      }, 5000);
    }
  }, {
    key: "detectIncome",
    value: function () {
      var _detectIncome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var detectBtn, response, detected, _t7;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              detectBtn = document.getElementById('detect-income-btn');
              detectBtn.disabled = true;
              detectBtn.innerHTML = '<span class="icon-loading-small" aria-hidden="true"></span> Detecting...';
              _context7.p = 1;
              _context7.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/recurring-income/detect?months=6'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context7.v;
              if (response.ok) {
                _context7.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              _context7.n = 4;
              return response.json();
            case 4:
              detected = _context7.v;
              if (!(detected.length === 0)) {
                _context7.n = 5;
                break;
              }
              OC.Notification.showTemporary('No recurring income patterns found in your transactions');
              return _context7.a(2);
            case 5:
              this._detectedIncome = detected;
              this.renderDetectedIncome(detected);
              document.getElementById('detected-income-panel').style.display = 'flex';
              _context7.n = 7;
              break;
            case 6:
              _context7.p = 6;
              _t7 = _context7.v;
              console.error('Failed to detect income:', _t7);
              OC.Notification.showTemporary('Failed to detect recurring income');
            case 7:
              _context7.p = 7;
              detectBtn.disabled = false;
              detectBtn.innerHTML = '<span class="icon-search" aria-hidden="true"></span> Detect Income';
              return _context7.f(7);
            case 8:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 6, 7, 8]]);
      }));
      function detectIncome() {
        return _detectIncome.apply(this, arguments);
      }
      return detectIncome;
    }()
  }, {
    key: "renderDetectedIncome",
    value: function renderDetectedIncome(detected) {
      var _this4 = this;
      var list = document.getElementById('detected-income-list');
      list.innerHTML = detected.map(function (item, index) {
        var confidenceClass = item.confidence >= 0.8 ? 'high' : item.confidence >= 0.5 ? 'medium' : 'low';
        var confidencePercent = Math.round(item.confidence * 100);
        return "\n                <div class=\"detected-bill-item\" data-index=\"".concat(index, "\">\n                    <div class=\"detected-bill-select\">\n                        <input type=\"checkbox\" id=\"detected-income-").concat(index, "\" ").concat(item.confidence >= 0.7 ? 'checked' : '', ">\n                    </div>\n                    <div class=\"detected-bill-info\">\n                        <div class=\"detected-bill-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(item.suggestedName), "</div>\n                        <div class=\"detected-bill-meta\">\n                            <span class=\"detected-bill-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(item.amount, null, _this4.settings), "</span>\n                            <span class=\"detected-bill-frequency\">").concat(item.frequency, "</span>\n                            <span class=\"detected-bill-occurrences\">").concat(item.occurrences, " occurrences</span>\n                            <span class=\"detected-bill-source\">Source: ").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(item.source), "</span>\n                        </div>\n                        <div class=\"detected-bill-confidence\">\n                            <span class=\"confidence-badge ").concat(confidenceClass, "\">").concat(confidencePercent, "% confidence</span>\n                            ").concat(item.amountVariance ? "<span class=\"variance-info\">\xB1".concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(item.amountVariance, null, _this4.settings), "</span>") : '', "\n                        </div>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "addSelectedDetectedIncome",
    value: function () {
      var _addSelectedDetectedIncome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var _this5 = this;
        var checkboxes, selectedIndices, incomeToAdd, response, result, _t8;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              checkboxes = document.querySelectorAll('#detected-income-list input[type="checkbox"]:checked');
              selectedIndices = Array.from(checkboxes).map(function (cb) {
                return parseInt(cb.id.replace('detected-income-', ''));
              });
              if (!(selectedIndices.length === 0)) {
                _context8.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select at least one income source to add');
              return _context8.a(2);
            case 1:
              incomeToAdd = selectedIndices.map(function (i) {
                return _this5._detectedIncome[i];
              });
              _context8.p = 2;
              _context8.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/recurring-income/create-from-detected'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  incomes: incomeToAdd
                })
              });
            case 3:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 4;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 4:
              _context8.n = 5;
              return response.json();
            case 5:
              result = _context8.v;
              document.getElementById('detected-income-panel').style.display = 'none';
              OC.Notification.showTemporary("".concat(result.created, " income sources added successfully"));
              _context8.n = 6;
              return this.loadIncomeView();
            case 6:
              _context8.n = 8;
              break;
            case 7:
              _context8.p = 7;
              _t8 = _context8.v;
              console.error('Failed to add income:', _t8);
              OC.Notification.showTemporary('Failed to add selected income sources');
            case 8:
              return _context8.a(2);
          }
        }, _callee8, this, [[2, 7]]);
      }));
      function addSelectedDetectedIncome() {
        return _addSelectedDetectedIncome.apply(this, arguments);
      }
      return addSelectedDetectedIncome;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/pensions/PensionsModule.js":
/*!************************************************!*\
  !*** ./src/modules/pensions/PensionsModule.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PensionsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
/* harmony import */ var chart_js_auto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Pensions Module - Pension tracking and projection
 */



var PensionsModule = /*#__PURE__*/function () {
  function PensionsModule(app) {
    _classCallCheck(this, PensionsModule);
    this.app = app;
  }

  // Getters for app state
  return _createClass(PensionsModule, [{
    key: "pensions",
    get: function get() {
      return this.app.pensions;
    },
    set: function set(value) {
      this.app.pensions = value;
    }
  }, {
    key: "currentPension",
    get: function get() {
      return this.app.currentPension;
    },
    set: function set(value) {
      this.app.currentPension = value;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "charts",
    get: function get() {
      return this.app.charts;
    }
  }, {
    key: "loadPensionsView",
    value: function () {
      var _loadPensionsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return this.loadPensions();
            case 1:
              this.renderPensions();
              this.setupPensionEventListeners();
              _context.n = 3;
              break;
            case 2:
              _context.p = 2;
              _t = _context.v;
              console.error('Failed to load pensions view:', _t);
              OC.Notification.showTemporary('Failed to load pensions');
            case 3:
              return _context.a(2);
          }
        }, _callee, this, [[0, 2]]);
      }));
      function loadPensionsView() {
        return _loadPensionsView.apply(this, arguments);
      }
      return loadPensionsView;
    }()
  }, {
    key: "loadPensions",
    value: function () {
      var _loadPensions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/pensions'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 2;
                break;
              }
              throw new Error('Failed to fetch pensions');
            case 2:
              _context2.n = 3;
              return response.json();
            case 3:
              this.pensions = _context2.v;
            case 4:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function loadPensions() {
        return _loadPensions.apply(this, arguments);
      }
      return loadPensions;
    }()
  }, {
    key: "loadPensionSummary",
    value: function () {
      var _loadPensionSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var response;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/pensions/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 2;
                break;
              }
              throw new Error('Failed to fetch pension summary');
            case 2:
              _context3.n = 3;
              return response.json();
            case 3:
              return _context3.a(2, _context3.v);
          }
        }, _callee3);
      }));
      function loadPensionSummary() {
        return _loadPensionSummary.apply(this, arguments);
      }
      return loadPensionSummary;
    }()
  }, {
    key: "loadPensionProjection",
    value: function () {
      var _loadPensionProjection = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var response;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/pensions/projection'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              throw new Error('Failed to fetch pension projection');
            case 2:
              _context4.n = 3;
              return response.json();
            case 3:
              return _context4.a(2, _context4.v);
          }
        }, _callee4);
      }));
      function loadPensionProjection() {
        return _loadPensionProjection.apply(this, arguments);
      }
      return loadPensionProjection;
    }()
  }, {
    key: "renderPensions",
    value: function renderPensions() {
      var _this = this;
      var list = document.getElementById('pensions-list');
      var emptyState = document.getElementById('empty-pensions');
      if (!this.pensions || this.pensions.length === 0) {
        list.innerHTML = '';
        emptyState.style.display = 'block';
        this.updatePensionsSummary({
          totalPensionWorth: 0,
          pensionCount: 0
        });
        return;
      }
      emptyState.style.display = 'none';
      list.innerHTML = this.pensions.map(function (pension) {
        return _this.renderPensionCard(pension);
      }).join('');

      // Load and update summary
      this.loadPensionSummary().then(function (summary) {
        _this.updatePensionsSummary(summary);
      });

      // Load and update projections
      this.loadPensionProjection().then(function (projection) {
        _this.updatePensionsProjection(projection);
      });
    }
  }, {
    key: "renderPensionCard",
    value: function renderPensionCard(pension) {
      var currency = pension.currency || 'GBP';
      var typeLabels = {
        workplace: 'Workplace',
        personal: 'Personal',
        sipp: 'SIPP',
        defined_benefit: 'Defined Benefit',
        state: 'State Pension'
      };
      var typeLabel = typeLabels[pension.type] || pension.type;
      var valueDisplay = '--';
      if (pension.isDefinedContribution && pension.currentBalance !== null) {
        valueDisplay = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pension.currentBalance, currency, this.settings);
      } else if (pension.annualIncome !== null) {
        valueDisplay = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pension.annualIncome, currency, this.settings) + '/year';
      }
      return "\n            <div class=\"pension-card\" data-id=\"".concat(pension.id, "\">\n                <div class=\"pension-card-header\">\n                    <h4 class=\"pension-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(pension.name), "</h4>\n                    <span class=\"pension-type-badge pension-type-").concat(pension.type, "\">").concat(typeLabel, "</span>\n                </div>\n                <div class=\"pension-card-body\">\n                    <div class=\"pension-value\">").concat(valueDisplay, "</div>\n                    ").concat(pension.provider ? "<div class=\"pension-provider\">".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(pension.provider), "</div>") : '', "\n                    ").concat(pension.monthlyContribution ? "<div class=\"pension-contribution\">".concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pension.monthlyContribution, currency, this.settings), "/month</div>") : '', "\n                </div>\n                <div class=\"pension-card-actions\">\n                    <button class=\"pension-view-btn icon-button\" title=\"View details\" data-id=\"").concat(pension.id, "\">\n                        <span class=\"icon-info\" aria-hidden=\"true\"></span>\n                    </button>\n                    <button class=\"pension-edit-btn icon-button\" title=\"Edit\" data-id=\"").concat(pension.id, "\">\n                        <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                    </button>\n                    <button class=\"pension-delete-btn icon-button\" title=\"Delete\" data-id=\"").concat(pension.id, "\">\n                        <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                    </button>\n                </div>\n            </div>\n        ");
    }
  }, {
    key: "updatePensionsSummary",
    value: function updatePensionsSummary(summary) {
      var currency = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryCurrency(this.app.accounts, this.settings);
      var pensionWorth = summary.totalPensionWorth || 0;
      var projectedIncome = summary.totalProjectedIncome || 0;
      var count = summary.pensionCount || 0;
      var worthEl = document.getElementById('pensions-total-worth');
      var countEl = document.getElementById('pensions-count');
      if (worthEl) {
        worthEl.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pensionWorth, currency, this.settings);
      }
      if (countEl) {
        countEl.textContent = count;
      }

      // Update dashboard hero card
      var heroPensionValue = document.getElementById('hero-pension-value');
      var heroPensionCount = document.getElementById('hero-pension-count');
      var heroPensionLabel = document.querySelector('.hero-pension .hero-label');
      if (heroPensionValue) {
        // Show pension worth if available, otherwise show projected income
        if (pensionWorth > 0) {
          heroPensionValue.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pensionWorth, currency, this.settings);
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Worth';
        } else if (projectedIncome > 0) {
          heroPensionValue.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(projectedIncome, currency, this.settings) + '/yr';
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Income';
        } else {
          heroPensionValue.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(0, currency, this.settings);
          if (heroPensionLabel) heroPensionLabel.textContent = 'Pension Worth';
        }
      }
      if (heroPensionCount) {
        var subtext = count === 1 ? '1 pension' : "".concat(count, " pensions");
        // If showing income but also have some pot value, mention it
        if (pensionWorth > 0 && projectedIncome > 0) {
          subtext += " \xB7 ".concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(projectedIncome, currency, this.settings), "/yr income");
        }
        heroPensionCount.textContent = subtext;
      }
    }
  }, {
    key: "updatePensionsProjection",
    value: function updatePensionsProjection(projection) {
      var currency = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryCurrency(this.app.accounts, this.settings);
      var projectedValueEl = document.getElementById('pensions-projected-value');
      var projectedIncomeEl = document.getElementById('pensions-projected-income');
      if (projectedValueEl) {
        projectedValueEl.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(projection.totalProjectedValue || 0, currency, this.settings);
      }
      if (projectedIncomeEl) {
        projectedIncomeEl.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(projection.totalProjectedAnnualIncome || 0, currency, this.settings);
      }
    }
  }, {
    key: "setupPensionEventListeners",
    value: function setupPensionEventListeners() {
      var _this2 = this;
      // Add pension button
      var addBtn = document.getElementById('add-pension-btn');
      var emptyAddBtn = document.getElementById('empty-pensions-add-btn');
      if (addBtn) {
        addBtn.onclick = function () {
          return _this2.showPensionModal();
        };
      }
      if (emptyAddBtn) {
        emptyAddBtn.onclick = function () {
          return _this2.showPensionModal();
        };
      }

      // Pension form
      var pensionForm = document.getElementById('pension-form');
      if (pensionForm) {
        pensionForm.onsubmit = function (e) {
          e.preventDefault();
          _this2.savePension();
        };
      }

      // Pension type change (toggle DC/DB fields)
      var pensionType = document.getElementById('pension-type');
      if (pensionType) {
        pensionType.onchange = function () {
          return _this2.togglePensionFields();
        };
      }

      // Modal close buttons
      document.querySelectorAll('#pension-modal .cancel-btn').forEach(function (btn) {
        btn.onclick = function () {
          return _this2.closePensionModal();
        };
      });

      // Balance form
      var balanceForm = document.getElementById('pension-balance-form');
      if (balanceForm) {
        balanceForm.onsubmit = function (e) {
          e.preventDefault();
          _this2.saveSnapshot();
        };
      }
      document.querySelectorAll('#pension-balance-modal .cancel-btn').forEach(function (btn) {
        btn.onclick = function () {
          return _this2.closeBalanceModal();
        };
      });

      // Contribution form
      var contributionForm = document.getElementById('pension-contribution-form');
      if (contributionForm) {
        contributionForm.onsubmit = function (e) {
          e.preventDefault();
          _this2.saveContribution();
        };
      }
      document.querySelectorAll('#pension-contribution-modal .cancel-btn').forEach(function (btn) {
        btn.onclick = function () {
          return _this2.closeContributionModal();
        };
      });

      // Pension card actions (delegated)
      var pensionsList = document.getElementById('pensions-list');
      if (pensionsList) {
        pensionsList.onclick = function (e) {
          var viewBtn = e.target.closest('.pension-view-btn');
          var editBtn = e.target.closest('.pension-edit-btn');
          var deleteBtn = e.target.closest('.pension-delete-btn');
          var card = e.target.closest('.pension-card');
          if (viewBtn) {
            _this2.showPensionDetails(parseInt(viewBtn.dataset.id));
          } else if (editBtn) {
            _this2.showPensionModal(parseInt(editBtn.dataset.id));
          } else if (deleteBtn) {
            _this2.deletePension(parseInt(deleteBtn.dataset.id));
          } else if (card) {
            _this2.showPensionDetails(parseInt(card.dataset.id));
          }
        };
      }

      // Detail panel buttons
      var closeDetailBtn = document.getElementById('pension-close-btn');
      if (closeDetailBtn) {
        closeDetailBtn.onclick = function () {
          return _this2.closePensionDetails();
        };
      }
      var editDetailBtn = document.getElementById('pension-edit-btn');
      if (editDetailBtn) {
        editDetailBtn.onclick = function () {
          if (_this2.currentPension) {
            _this2.showPensionModal(_this2.currentPension.id);
          }
        };
      }
      var updateBalanceBtn = document.getElementById('update-balance-btn');
      if (updateBalanceBtn) {
        updateBalanceBtn.onclick = function () {
          return _this2.showBalanceModal();
        };
      }
      var addContributionBtn = document.getElementById('add-contribution-btn');
      if (addContributionBtn) {
        addContributionBtn.onclick = function () {
          return _this2.showContributionModal();
        };
      }
    }
  }, {
    key: "togglePensionFields",
    value: function togglePensionFields() {
      var type = document.getElementById('pension-type').value;
      var dcFields = document.getElementById('dc-pension-fields');
      var dbFields = document.getElementById('db-pension-fields');
      if (type === 'defined_benefit' || type === 'state') {
        dcFields.style.display = 'none';
        dbFields.style.display = 'block';
      } else {
        dcFields.style.display = 'block';
        dbFields.style.display = 'none';
      }
    }
  }, {
    key: "showPensionModal",
    value: function showPensionModal() {
      var pensionId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('pension-modal');
      var form = document.getElementById('pension-form');
      var title = document.getElementById('pension-modal-title');
      form.reset();
      if (pensionId) {
        var pension = this.pensions.find(function (p) {
          return p.id === pensionId;
        });
        if (!pension) return;
        title.textContent = 'Edit Pension';
        document.getElementById('pension-id').value = pension.id;
        document.getElementById('pension-name').value = pension.name;
        document.getElementById('pension-type').value = pension.type;
        document.getElementById('pension-provider').value = pension.provider || '';
        document.getElementById('pension-currency').value = pension.currency || 'GBP';
        if (pension.isDefinedContribution) {
          document.getElementById('pension-balance').value = pension.currentBalance || '';
          document.getElementById('pension-monthly').value = pension.monthlyContribution || '';
        } else {
          document.getElementById('pension-income').value = pension.annualIncome || '';
        }
        this.togglePensionFields();
      } else {
        title.textContent = 'Add Pension';
        document.getElementById('pension-id').value = '';
        this.togglePensionFields();
      }
      modal.style.display = 'flex';
    }
  }, {
    key: "closePensionModal",
    value: function closePensionModal() {
      document.getElementById('pension-modal').style.display = 'none';
    }
  }, {
    key: "savePension",
    value: function () {
      var _savePension = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var form, formData, pensionId, type, isDefinedContribution, data, url, response, error, _t2;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              form = document.getElementById('pension-form');
              formData = new FormData(form);
              pensionId = formData.get('id');
              type = formData.get('type');
              isDefinedContribution = type !== 'defined_benefit' && type !== 'state';
              data = {
                name: formData.get('name'),
                type: type,
                provider: formData.get('provider') || null,
                accountNumber: formData.get('accountNumber') || null,
                currency: formData.get('currency') || 'GBP',
                isDefinedContribution: isDefinedContribution
              };
              if (isDefinedContribution) {
                data.currentBalance = formData.get('currentBalance') ? parseFloat(formData.get('currentBalance')) : null;
                data.monthlyContribution = formData.get('monthlyContribution') ? parseFloat(formData.get('monthlyContribution')) : null;
              } else {
                data.annualIncome = formData.get('annualIncome') ? parseFloat(formData.get('annualIncome')) : null;
                data.startDate = formData.get('startDate') || null;
              }
              _context5.p = 1;
              url = pensionId ? OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId)) : OC.generateUrl('/apps/budget/api/pensions');
              _context5.n = 2;
              return fetch(url, {
                method: pensionId ? 'PUT' : 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(data)
              });
            case 2:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 4;
                break;
              }
              _context5.n = 3;
              return response.json();
            case 3:
              error = _context5.v;
              throw new Error(error.error || 'Failed to save pension');
            case 4:
              this.closePensionModal();
              _context5.n = 5;
              return this.loadPensions();
            case 5:
              this.renderPensions();
              OC.Notification.showTemporary(pensionId ? 'Pension updated' : 'Pension added');
              _context5.n = 7;
              break;
            case 6:
              _context5.p = 6;
              _t2 = _context5.v;
              OC.Notification.showTemporary(_t2.message);
            case 7:
              return _context5.a(2);
          }
        }, _callee5, this, [[1, 6]]);
      }));
      function savePension() {
        return _savePension.apply(this, arguments);
      }
      return savePension;
    }()
  }, {
    key: "deletePension",
    value: function () {
      var _deletePension = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(pensionId) {
        var response, error, _t3;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              if (confirm('Are you sure you want to delete this pension? This action cannot be undone.')) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              _context6.p = 1;
              _context6.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 4;
                break;
              }
              _context6.n = 3;
              return response.json();
            case 3:
              error = _context6.v;
              throw new Error(error.error || 'Failed to delete pension');
            case 4:
              _context6.n = 5;
              return this.loadPensions();
            case 5:
              this.renderPensions();
              this.closePensionDetails();
              OC.Notification.showTemporary('Pension deleted');
              _context6.n = 7;
              break;
            case 6:
              _context6.p = 6;
              _t3 = _context6.v;
              OC.Notification.showTemporary(_t3.message);
            case 7:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 6]]);
      }));
      function deletePension(_x) {
        return _deletePension.apply(this, arguments);
      }
      return deletePension;
    }()
  }, {
    key: "showPensionDetails",
    value: function () {
      var _showPensionDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(pensionId) {
        var pension, panel, nameEl, typeEl, providerEl, valueEl, currency;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              pension = this.pensions.find(function (p) {
                return p.id === pensionId;
              });
              if (pension) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2);
            case 1:
              this.currentPension = pension;
              panel = document.getElementById('pension-detail-panel');
              nameEl = document.getElementById('pension-detail-name');
              typeEl = document.getElementById('pension-detail-type');
              providerEl = document.getElementById('pension-detail-provider');
              valueEl = document.getElementById('pension-detail-value');
              nameEl.textContent = pension.name;
              typeEl.textContent = {
                workplace: 'Workplace',
                personal: 'Personal',
                sipp: 'SIPP',
                defined_benefit: 'Defined Benefit',
                state: 'State Pension'
              }[pension.type] || pension.type;
              if (pension.provider) {
                providerEl.textContent = pension.provider;
                providerEl.style.display = 'block';
              } else {
                providerEl.style.display = 'none';
              }
              currency = pension.currency || 'GBP';
              if (pension.isDefinedContribution && pension.currentBalance !== null) {
                valueEl.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pension.currentBalance, currency, this.settings);
              } else if (pension.annualIncome !== null) {
                valueEl.textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(pension.annualIncome, currency, this.settings) + '/year';
              } else {
                valueEl.textContent = '--';
              }
              panel.classList.add('active');

              // Load charts and activity
              _context7.n = 2;
              return this.loadPensionBalanceChart(pensionId);
            case 2:
              _context7.n = 3;
              return this.loadPensionProjectionChart(pensionId);
            case 3:
              _context7.n = 4;
              return this.loadPensionActivity(pensionId);
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this);
      }));
      function showPensionDetails(_x2) {
        return _showPensionDetails.apply(this, arguments);
      }
      return showPensionDetails;
    }()
  }, {
    key: "closePensionDetails",
    value: function closePensionDetails() {
      document.getElementById('pension-detail-panel').classList.remove('active');
      this.currentPension = null;
    }
  }, {
    key: "loadPensionBalanceChart",
    value: function () {
      var _loadPensionBalanceChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(pensionId) {
        var _this3 = this;
        var response, data, canvas, ctx, _t4;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              _context8.p = 0;
              _context8.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId, "/balance-history")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 2;
                break;
              }
              return _context8.a(2);
            case 2:
              _context8.n = 3;
              return response.json();
            case 3:
              data = _context8.v;
              canvas = document.getElementById('pension-balance-chart');
              ctx = canvas.getContext('2d'); // Destroy existing chart
              if (this.charts.pensionBalance) {
                this.charts.pensionBalance.destroy();
              }
              this.charts.pensionBalance = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
                type: 'line',
                data: {
                  labels: data.labels,
                  datasets: [{
                    label: 'Balance',
                    data: data.values,
                    borderColor: '#0082c9',
                    backgroundColor: 'rgba(0, 130, 201, 0.1)',
                    fill: true,
                    tension: 0.4
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: {
                      display: false
                    }
                  },
                  scales: {
                    y: {
                      beginAtZero: true,
                      ticks: {
                        callback: function callback(value) {
                          return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrencyCompact(value, data.currency, _this3.settings);
                        }
                      }
                    }
                  }
                }
              });
              _context8.n = 5;
              break;
            case 4:
              _context8.p = 4;
              _t4 = _context8.v;
              console.error('Failed to load pension balance chart:', _t4);
            case 5:
              return _context8.a(2);
          }
        }, _callee8, this, [[0, 4]]);
      }));
      function loadPensionBalanceChart(_x3) {
        return _loadPensionBalanceChart.apply(this, arguments);
      }
      return loadPensionBalanceChart;
    }()
  }, {
    key: "loadPensionProjectionChart",
    value: function () {
      var _loadPensionProjectionChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(pensionId) {
        var _this4 = this;
        var response, data, canvas, ctx, _t5;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              _context9.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId, "/projection")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 2;
                break;
              }
              return _context9.a(2);
            case 2:
              _context9.n = 3;
              return response.json();
            case 3:
              data = _context9.v;
              canvas = document.getElementById('pension-projection-chart');
              ctx = canvas.getContext('2d'); // Destroy existing chart
              if (this.charts.pensionProjection) {
                this.charts.pensionProjection.destroy();
              }
              this.charts.pensionProjection = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
                type: 'line',
                data: {
                  labels: data.labels,
                  datasets: [{
                    label: 'Projected Value',
                    data: data.values,
                    borderColor: '#46ba61',
                    backgroundColor: 'rgba(70, 186, 97, 0.1)',
                    fill: true,
                    tension: 0.4
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: {
                      display: false
                    }
                  },
                  scales: {
                    y: {
                      beginAtZero: true,
                      ticks: {
                        callback: function callback(value) {
                          return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrencyCompact(value, data.currency, _this4.settings);
                        }
                      }
                    }
                  }
                }
              });
              _context9.n = 5;
              break;
            case 4:
              _context9.p = 4;
              _t5 = _context9.v;
              console.error('Failed to load pension projection chart:', _t5);
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 4]]);
      }));
      function loadPensionProjectionChart(_x4) {
        return _loadPensionProjectionChart.apply(this, arguments);
      }
      return loadPensionProjectionChart;
    }()
  }, {
    key: "loadPensionActivity",
    value: function () {
      var _loadPensionActivity = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(pensionId) {
        var _this5 = this;
        var response, data, container, currency, _t6;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              _context0.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId, "/activity")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context0.v;
              if (response.ok) {
                _context0.n = 2;
                break;
              }
              return _context0.a(2);
            case 2:
              _context0.n = 3;
              return response.json();
            case 3:
              data = _context0.v;
              container = document.getElementById('pension-activity-list');
              if (!(!data || data.length === 0)) {
                _context0.n = 4;
                break;
              }
              container.innerHTML = '<div class="empty-state-small">No activity yet</div>';
              return _context0.a(2);
            case 4:
              currency = this.currentPension.currency || 'GBP';
              container.innerHTML = data.map(function (activity) {
                var typeLabels = {
                  snapshot: 'Balance Update',
                  contribution: 'Contribution'
                };
                var typeLabel = typeLabels[activity.type] || activity.type;
                var icon = activity.type === 'contribution' ? 'icon-add' : 'icon-checkmark';
                return "\n                    <div class=\"pension-activity-item\">\n                        <div class=\"activity-icon ".concat(icon, "\"></div>\n                        <div class=\"activity-details\">\n                            <div class=\"activity-type\">").concat(typeLabel, "</div>\n                            <div class=\"activity-date\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(activity.date, _this5.settings), "</div>\n                            ").concat(activity.note ? "<div class=\"activity-note\">".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(activity.note), "</div>") : '', "\n                        </div>\n                        <div class=\"activity-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(activity.amount, currency, _this5.settings), "</div>\n                    </div>\n                ");
              }).join('');
              _context0.n = 6;
              break;
            case 5:
              _context0.p = 5;
              _t6 = _context0.v;
              console.error('Failed to load pension activity:', _t6);
            case 6:
              return _context0.a(2);
          }
        }, _callee0, this, [[0, 5]]);
      }));
      function loadPensionActivity(_x5) {
        return _loadPensionActivity.apply(this, arguments);
      }
      return loadPensionActivity;
    }()
  }, {
    key: "showBalanceModal",
    value: function showBalanceModal() {
      if (!this.currentPension) return;
      var modal = document.getElementById('pension-balance-modal');
      document.getElementById('pension-balance-form').reset();
      document.getElementById('snapshot-pension-id').value = this.currentPension.id;
      document.getElementById('snapshot-date').value = new Date().toISOString().split('T')[0];
      if (this.currentPension.currentBalance) {
        document.getElementById('snapshot-balance').value = this.currentPension.currentBalance;
      }
      modal.style.display = 'flex';
    }
  }, {
    key: "closeBalanceModal",
    value: function closeBalanceModal() {
      document.getElementById('pension-balance-modal').style.display = 'none';
    }
  }, {
    key: "saveSnapshot",
    value: function () {
      var _saveSnapshot = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
        var form, formData, pensionId, response, error, _t7;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              form = document.getElementById('pension-balance-form');
              formData = new FormData(form);
              pensionId = formData.get('pensionId');
              _context1.p = 1;
              _context1.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId, "/snapshots")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  balance: parseFloat(formData.get('balance')),
                  date: formData.get('date')
                })
              });
            case 2:
              response = _context1.v;
              if (response.ok) {
                _context1.n = 4;
                break;
              }
              _context1.n = 3;
              return response.json();
            case 3:
              error = _context1.v;
              throw new Error(error.error || 'Failed to update balance');
            case 4:
              this.closeBalanceModal();
              _context1.n = 5;
              return this.loadPensions();
            case 5:
              this.renderPensions();
              _context1.n = 6;
              return this.showPensionDetails(parseInt(pensionId));
            case 6:
              OC.Notification.showTemporary('Balance updated');
              _context1.n = 8;
              break;
            case 7:
              _context1.p = 7;
              _t7 = _context1.v;
              OC.Notification.showTemporary(_t7.message);
            case 8:
              return _context1.a(2);
          }
        }, _callee1, this, [[1, 7]]);
      }));
      function saveSnapshot() {
        return _saveSnapshot.apply(this, arguments);
      }
      return saveSnapshot;
    }()
  }, {
    key: "showContributionModal",
    value: function showContributionModal() {
      if (!this.currentPension) return;
      var modal = document.getElementById('pension-contribution-modal');
      document.getElementById('pension-contribution-form').reset();
      document.getElementById('contribution-pension-id').value = this.currentPension.id;
      document.getElementById('contribution-date').value = new Date().toISOString().split('T')[0];
      modal.style.display = 'flex';
    }
  }, {
    key: "closeContributionModal",
    value: function closeContributionModal() {
      document.getElementById('pension-contribution-modal').style.display = 'none';
    }
  }, {
    key: "saveContribution",
    value: function () {
      var _saveContribution = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {
        var form, formData, pensionId, response, error, _t8;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              form = document.getElementById('pension-contribution-form');
              formData = new FormData(form);
              pensionId = formData.get('pensionId');
              _context10.p = 1;
              _context10.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/pensions/".concat(pensionId, "/contributions")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  amount: parseFloat(formData.get('amount')),
                  date: formData.get('date'),
                  note: formData.get('note') || null
                })
              });
            case 2:
              response = _context10.v;
              if (response.ok) {
                _context10.n = 4;
                break;
              }
              _context10.n = 3;
              return response.json();
            case 3:
              error = _context10.v;
              throw new Error(error.error || 'Failed to log contribution');
            case 4:
              this.closeContributionModal();
              _context10.n = 5;
              return this.showPensionDetails(parseInt(pensionId));
            case 5:
              OC.Notification.showTemporary('Contribution logged');
              _context10.n = 7;
              break;
            case 6:
              _context10.p = 6;
              _t8 = _context10.v;
              OC.Notification.showTemporary(_t8.message);
            case 7:
              return _context10.a(2);
          }
        }, _callee10, this, [[1, 6]]);
      }));
      function saveContribution() {
        return _saveContribution.apply(this, arguments);
      }
      return saveContribution;
    }()
  }, {
    key: "loadDashboardPensionSummary",
    value: function () {
      var _loadDashboardPensionSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var summary, _t9;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              _context11.p = 0;
              _context11.n = 1;
              return this.loadPensionSummary();
            case 1:
              summary = _context11.v;
              this.updatePensionsSummary(summary);
              _context11.n = 3;
              break;
            case 2:
              _context11.p = 2;
              _t9 = _context11.v;
              console.error('Failed to load pension summary for dashboard:', _t9);
            case 3:
              return _context11.a(2);
          }
        }, _callee11, this, [[0, 2]]);
      }));
      function loadDashboardPensionSummary() {
        return _loadDashboardPensionSummary.apply(this, arguments);
      }
      return loadDashboardPensionSummary;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/reports/ReportsModule.js":
/*!**********************************************!*\
  !*** ./src/modules/reports/ReportsModule.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReportsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
/* harmony import */ var chart_js_auto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Reports Module - Financial reporting and analysis
 */



var ReportsModule = /*#__PURE__*/function () {
  function ReportsModule(app) {
    _classCallCheck(this, ReportsModule);
    this.app = app;
    this.reportCharts = {};
    this.reportEventListenersSetup = false;
    this.yoyControlsSetup = false;
  }

  // Getters for app state
  return _createClass(ReportsModule, [{
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "allTagSetsForReports",
    get: function get() {
      return this.app.allTagSetsForReports;
    },
    set: function set(value) {
      this.app.allTagSetsForReports = value;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }

    // Helper method delegations
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatCurrencyCompact",
    value: function formatCurrencyCompact(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrencyCompact(amount, currency, this.settings);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.getPrimaryCurrency(this.accounts, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "setupReportEventListeners",
    value: function setupReportEventListeners() {
      var _this = this,
        _document$getElementB,
        _document$getElementB2;
      // Period preset change
      var presetSelect = document.getElementById('report-period-preset');
      if (presetSelect) {
        presetSelect.addEventListener('change', function (e) {
          var customRange = document.getElementById('custom-date-range');
          if (customRange) {
            customRange.style.display = e.target.value === 'custom' ? 'flex' : 'none';
          }
          if (e.target.value !== 'custom') {
            _this.setReportDateRange(e.target.value);
          }
        });
      }

      // Generate report button
      var generateBtn = document.getElementById('generate-report-btn');
      if (generateBtn) {
        generateBtn.addEventListener('click', function () {
          return _this.generateReport();
        });
      }

      // Report type change
      var typeSelect = document.getElementById('report-type');
      if (typeSelect) {
        typeSelect.addEventListener('change', function () {
          return _this.generateReport();
        });
      }

      // Export buttons
      (_document$getElementB = document.getElementById('export-csv-btn')) === null || _document$getElementB === void 0 || _document$getElementB.addEventListener('click', function () {
        return _this.exportReport('csv');
      });
      (_document$getElementB2 = document.getElementById('export-pdf-btn')) === null || _document$getElementB2 === void 0 || _document$getElementB2.addEventListener('click', function () {
        return _this.exportReport('pdf');
      });

      // Initialize charts object for reports
      this.reportCharts = {};
    }
  }, {
    key: "setReportDateRange",
    value: function setReportDateRange(preset) {
      var now = new Date();
      var startDate, endDate;
      switch (preset) {
        case 'this-month':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
          break;
        case 'last-3-months':
          startDate = new Date(now.getFullYear(), now.getMonth() - 2, 1);
          endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
          break;
        case 'ytd':
          startDate = new Date(now.getFullYear(), 0, 1);
          endDate = now;
          break;
        case 'last-year':
          startDate = new Date(now.getFullYear() - 1, 0, 1);
          endDate = new Date(now.getFullYear() - 1, 11, 31);
          break;
        default:
          startDate = new Date(now.getFullYear(), now.getMonth() - 2, 1);
          endDate = now;
      }
      var startInput = document.getElementById('report-start-date');
      var endInput = document.getElementById('report-end-date');
      if (startInput) startInput.value = startDate.toISOString().split('T')[0];
      if (endInput) endInput.value = endDate.toISOString().split('T')[0];
    }
  }, {
    key: "loadReportsView",
    value: function () {
      var _loadReportsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              // Setup event listeners on first load
              if (!this.reportEventListenersSetup) {
                this.setupReportEventListeners();
                this.reportEventListenersSetup = true;
              }

              // Populate account dropdown
              this.populateReportAccountDropdown();

              // Load and populate tags dropdown
              _context.n = 1;
              return this.loadAllTagsForReports();
            case 1:
              // Set default date range
              this.setReportDateRange('last-3-months');

              // Generate initial report
              _context.n = 2;
              return this.generateReport();
            case 2:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function loadReportsView() {
        return _loadReportsView.apply(this, arguments);
      }
      return loadReportsView;
    }()
  }, {
    key: "populateReportAccountDropdown",
    value: function populateReportAccountDropdown() {
      var dropdown = document.getElementById('report-account');
      if (!dropdown) return;
      dropdown.innerHTML = '<option value="">All Accounts</option>';
      if (Array.isArray(this.accounts)) {
        this.accounts.forEach(function (account) {
          dropdown.innerHTML += "<option value=\"".concat(account.id, "\">").concat(account.name, "</option>");
        });
      }
    }
  }, {
    key: "loadAllTagsForReports",
    value: function () {
      var _loadAllTagsForReports = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response, _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/tag-sets'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (!response.ok) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return response.json();
            case 2:
              this.allTagSetsForReports = _context2.v;
              this.populateReportTagsDropdown();
            case 3:
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t = _context2.v;
              console.error('Failed to load tags for reports:', _t);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 4]]);
      }));
      function loadAllTagsForReports() {
        return _loadAllTagsForReports.apply(this, arguments);
      }
      return loadAllTagsForReports;
    }()
  }, {
    key: "populateReportTagsDropdown",
    value: function populateReportTagsDropdown() {
      var _this2 = this;
      var container = document.getElementById('report-tags-filter');
      if (!container) return;
      container.innerHTML = '';
      if (!this.allTagSetsForReports || this.allTagSetsForReports.length === 0) {
        container.innerHTML = '<div style="padding: 8px; color: var(--color-text-lighter); font-style: italic;">No tags available</div>';
        return;
      }

      // Track selected tags
      this.selectedReportTags = this.selectedReportTags || new Set();

      // Create input field
      var input = document.createElement('input');
      input.type = 'text';
      input.id = 'report-tags-input';
      input.className = 'tags-autocomplete-input';
      input.placeholder = 'Type to filter tags...';

      // Create dropdown
      var dropdown = document.createElement('div');
      dropdown.className = 'tags-autocomplete-dropdown';
      dropdown.style.display = 'none';
      container.appendChild(input);
      container.appendChild(dropdown);

      // Build flat list of all tags
      var allTags = [];
      this.allTagSetsForReports.forEach(function (tagSet) {
        if (tagSet.tags && tagSet.tags.length > 0) {
          tagSet.tags.forEach(function (tag) {
            allTags.push({
              id: tag.id,
              name: tag.name,
              color: tag.color,
              tagSetName: tagSet.name,
              tagSetId: tagSet.id
            });
          });
        }
      });

      // Render dropdown function
      var renderDropdown = function renderDropdown() {
        var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var filtered = filter ? allTags.filter(function (t) {
          return t.name.toLowerCase().includes(filter.toLowerCase()) || t.tagSetName.toLowerCase().includes(filter.toLowerCase());
        }) : allTags;

        // Group by tag set
        var grouped = {};
        filtered.forEach(function (tag) {
          if (!grouped[tag.tagSetId]) {
            grouped[tag.tagSetId] = {
              name: tag.tagSetName,
              tags: []
            };
          }
          grouped[tag.tagSetId].tags.push(tag);
        });
        var html = '';
        Object.values(grouped).forEach(function (group) {
          html += "<div class=\"tags-group-header\">".concat(_this2.escapeHtml(group.name), "</div>");
          group.tags.forEach(function (tag) {
            var isSelected = _this2.selectedReportTags.has(tag.id);
            html += "\n                        <div class=\"tags-autocomplete-item ".concat(isSelected ? 'selected' : '', "\"\n                             data-tag-id=\"").concat(tag.id, "\">\n                            <span class=\"tag-chip\"\n                                  style=\"display: inline-flex; align-items: center; background-color: ").concat(_this2.escapeHtml(tag.color || '#888'), "; color: white;\n                                         padding: 2px 6px; border-radius: 10px; font-size: 10px; line-height: 14px; margin-right: 4px;\">\n                                ").concat(_this2.escapeHtml(tag.name), "\n                            </span>\n                            <span class=\"tag-check\">").concat(isSelected ? '' : '', "</span>\n                        </div>\n                    ");
          });
        });
        dropdown.innerHTML = html || '<div class="tags-autocomplete-empty">No tags found</div>';
        dropdown.style.display = 'block';
      };

      // Event listeners
      input.addEventListener('focus', function () {
        return renderDropdown(input.value);
      });
      input.addEventListener('input', function () {
        return renderDropdown(input.value);
      });

      // Prevent dropdown from closing when clicking inside
      dropdown.addEventListener('mousedown', function (e) {
        e.preventDefault();
      });

      // Handle tag selection
      dropdown.addEventListener('click', function (e) {
        e.stopPropagation();
        var item = e.target.closest('.tags-autocomplete-item');
        if (item) {
          var tagId = parseInt(item.dataset.tagId);
          var clickedTag = allTags.find(function (t) {
            return t.id === tagId;
          });
          if (!clickedTag) return;

          // Remove other tags from same tag set (single selection per set)
          var tagsFromSameSet = allTags.filter(function (t) {
            return t.tagSetId === clickedTag.tagSetId;
          });
          tagsFromSameSet.forEach(function (t) {
            if (t.id !== tagId) {
              _this2.selectedReportTags["delete"](t.id);
            }
          });

          // Toggle selection
          if (_this2.selectedReportTags.has(tagId)) {
            _this2.selectedReportTags["delete"](tagId);
          } else {
            _this2.selectedReportTags.add(tagId);
          }
          renderDropdown(input.value);
        }
      });

      // Close dropdown when clicking outside
      var closeDropdown = function closeDropdown(e) {
        if (!container.contains(e.target)) {
          dropdown.style.display = 'none';
        }
      };
      document.addEventListener('click', closeDropdown);

      // Cleanup on module unload
      container.dataset.cleanupListener = 'true';
    }
  }, {
    key: "generateReport",
    value: function () {
      var _generateReport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var _document$getElementB3, _document$getElementB4, _document$getElementB5, _document$getElementB6;
        var reportType, startDate, endDate, accountId, selectedTags, includeUntaggedCheckbox, includeUntagged, loadingEl, params, _t2, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              reportType = ((_document$getElementB3 = document.getElementById('report-type')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.value) || 'summary';
              startDate = (_document$getElementB4 = document.getElementById('report-start-date')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value;
              endDate = (_document$getElementB5 = document.getElementById('report-end-date')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value;
              accountId = ((_document$getElementB6 = document.getElementById('report-account')) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.value) || ''; // Get selected tags from dropdown state
              selectedTags = this.selectedReportTags ? Array.from(this.selectedReportTags) : []; // Get include untagged checkbox
              includeUntaggedCheckbox = document.getElementById('report-include-untagged');
              includeUntagged = includeUntaggedCheckbox ? includeUntaggedCheckbox.checked : true; // Show loading
              loadingEl = document.getElementById('report-loading');
              if (loadingEl) loadingEl.style.display = 'flex';

              // Hide all report sections
              document.querySelectorAll('.report-section').forEach(function (el) {
                return el.style.display = 'none';
              });
              _context3.p = 1;
              params = new URLSearchParams(_objectSpread({
                startDate: startDate,
                endDate: endDate
              }, accountId && {
                accountId: accountId
              })); // Add tag filters if any tags are selected
              if (selectedTags.length > 0) {
                selectedTags.forEach(function (tagId) {
                  params.append('tagIds[]', tagId);
                });
                // Only add includeUntagged if tags are selected (otherwise it's irrelevant)
                params.append('includeUntagged', includeUntagged.toString());
              }
              _t2 = reportType;
              _context3.n = _t2 === 'summary' ? 2 : _t2 === 'spending' ? 4 : _t2 === 'cashflow' ? 6 : _t2 === 'yoy' ? 8 : 9;
              break;
            case 2:
              _context3.n = 3;
              return this.generateSummaryReport(params);
            case 3:
              return _context3.a(3, 9);
            case 4:
              _context3.n = 5;
              return this.generateSpendingReport(params);
            case 5:
              return _context3.a(3, 9);
            case 6:
              _context3.n = 7;
              return this.generateCashFlowReport(params);
            case 7:
              return _context3.a(3, 9);
            case 8:
              this.showYoYReport();
              return _context3.a(3, 9);
            case 9:
              _context3.n = 11;
              break;
            case 10:
              _context3.p = 10;
              _t3 = _context3.v;
              console.error('Failed to generate report:', _t3);
              OC.Notification.showTemporary('Failed to generate report');
            case 11:
              _context3.p = 11;
              if (loadingEl) loadingEl.style.display = 'none';
              return _context3.f(11);
            case 12:
              return _context3.a(2);
          }
        }, _callee3, this, [[1, 10, 11, 12]]);
      }));
      function generateReport() {
        return _generateReport.apply(this, arguments);
      }
      return generateReport;
    }()
  }, {
    key: "generateSummaryReport",
    value: function () {
      var _generateSummaryReport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(params) {
        var _data$comparison;
        var response, data, section, currency, totals, comparison, savingsRateEl, rate;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/reports/summary-comparison?".concat(params)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              throw new Error('Failed to fetch summary');
            case 2:
              _context4.n = 3;
              return response.json();
            case 3:
              data = _context4.v;
              section = document.getElementById('report-summary');
              if (section) section.style.display = 'block';
              currency = this.getPrimaryCurrency();
              totals = data.totals || {};
              comparison = ((_data$comparison = data.comparison) === null || _data$comparison === void 0 ? void 0 : _data$comparison.changes) || {}; // Update summary cards
              this.updateReportCard('report-total-income', totals.totalIncome, currency, 'report-income-change', comparison.income);
              this.updateReportCard('report-total-expenses', totals.totalExpenses, currency, 'report-expenses-change', comparison.expenses);
              this.updateReportCard('report-net-income', totals.netIncome, currency, 'report-net-change', comparison.netIncome);

              // Savings rate
              savingsRateEl = document.getElementById('report-savings-rate');
              if (savingsRateEl && totals.totalIncome > 0) {
                rate = (totals.netIncome / totals.totalIncome * 100).toFixed(1);
                savingsRateEl.textContent = "".concat(rate, "%");
              } else if (savingsRateEl) {
                savingsRateEl.textContent = '--';
              }

              // Render trend chart
              this.renderReportTrendChart(data.trends);

              // Render accounts table
              this.renderReportAccountsTable(data.accounts || [], currency);
            case 4:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function generateSummaryReport(_x) {
        return _generateSummaryReport.apply(this, arguments);
      }
      return generateSummaryReport;
    }()
  }, {
    key: "updateReportCard",
    value: function updateReportCard(valueId, value, currency, changeId, change) {
      var valueEl = document.getElementById(valueId);
      if (valueEl) {
        valueEl.textContent = this.formatCurrency(value || 0, currency);
      }
      var changeEl = document.getElementById(changeId);
      if (changeEl && change) {
        var arrow = change.direction === 'up' ? '' : change.direction === 'down' ? '' : '';
        var colorClass = change.direction === 'up' ? 'positive' : change.direction === 'down' ? 'negative' : '';
        changeEl.innerHTML = "".concat(arrow, " ").concat(change.percentage, "% vs prior period");
        changeEl.className = "summary-change ".concat(colorClass);
      } else if (changeEl) {
        changeEl.innerHTML = '';
      }
    }
  }, {
    key: "renderReportTrendChart",
    value: function renderReportTrendChart(trends) {
      var _this3 = this;
      var canvas = document.getElementById('report-trend-chart');
      if (!canvas || !trends) return;
      if (this.reportCharts.trend) {
        this.reportCharts.trend.destroy();
      }
      var ctx = canvas.getContext('2d');
      var currency = this.getPrimaryCurrency();
      this.reportCharts.trend = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'bar',
        data: {
          labels: trends.labels || [],
          datasets: [{
            label: 'Income',
            data: trends.income || [],
            backgroundColor: 'rgba(46, 125, 50, 0.7)',
            borderColor: 'rgba(46, 125, 50, 1)',
            borderWidth: 1
          }, {
            label: 'Expenses',
            data: trends.expenses || [],
            backgroundColor: 'rgba(198, 40, 40, 0.7)',
            borderColor: 'rgba(198, 40, 40, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this3.formatCurrency(context.raw, currency));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function callback(value) {
                  return _this3.formatCurrencyCompact(value, currency);
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "renderReportAccountsTable",
    value: function renderReportAccountsTable(accounts, currency) {
      var _this4 = this;
      var tbody = document.querySelector('#report-accounts-table tbody');
      if (!tbody) return;
      tbody.innerHTML = accounts.map(function (account) {
        return "\n            <tr>\n                <td>".concat(account.name, "</td>\n                <td class=\"text-right positive\">").concat(_this4.formatCurrency(account.income || 0, currency), "</td>\n                <td class=\"text-right negative\">").concat(_this4.formatCurrency(account.expenses || 0, currency), "</td>\n                <td class=\"text-right ").concat((account.net || 0) >= 0 ? 'positive' : 'negative', "\">").concat(_this4.formatCurrency(account.net || 0, currency), "</td>\n                <td class=\"text-right\">").concat(_this4.formatCurrency(account.balance || 0, currency), "</td>\n            </tr>\n        ");
      }).join('');
    }
  }, {
    key: "generateSpendingReport",
    value: function () {
      var _generateSpendingReport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(params) {
        var _categoryData$totals;
        var _yield$Promise$all, _yield$Promise$all2, categoryResponse, vendorResponse, categoryData, vendorData, section, currency, totalSpending;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return Promise.all([fetch(OC.generateUrl("/apps/budget/api/reports/spending?".concat(params, "&groupBy=category")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              }), fetch(OC.generateUrl("/apps/budget/api/reports/spending?".concat(params, "&groupBy=vendor")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              })]);
            case 1:
              _yield$Promise$all = _context5.v;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              categoryResponse = _yield$Promise$all2[0];
              vendorResponse = _yield$Promise$all2[1];
              _context5.n = 2;
              return categoryResponse.json();
            case 2:
              categoryData = _context5.v;
              _context5.n = 3;
              return vendorResponse.json();
            case 3:
              vendorData = _context5.v;
              section = document.getElementById('report-spending');
              if (section) section.style.display = 'block';
              currency = this.getPrimaryCurrency();
              totalSpending = ((_categoryData$totals = categoryData.totals) === null || _categoryData$totals === void 0 ? void 0 : _categoryData$totals.amount) || 0; // Render category chart
              this.renderReportSpendingChart(categoryData.data || [], totalSpending);

              // Render category table
              this.renderReportCategoryTable(categoryData.data || [], totalSpending, currency);

              // Render vendor table
              this.renderReportVendorTable(vendorData.data || [], currency);
            case 4:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function generateSpendingReport(_x2) {
        return _generateSpendingReport.apply(this, arguments);
      }
      return generateSpendingReport;
    }()
  }, {
    key: "renderReportSpendingChart",
    value: function renderReportSpendingChart(data, totalSpending) {
      var _this5 = this;
      var canvas = document.getElementById('report-spending-chart');
      if (!canvas) return;
      if (this.reportCharts.spending) {
        this.reportCharts.spending.destroy();
      }
      var ctx = canvas.getContext('2d');
      var sortedData = _toConsumableArray(data).sort(function (a, b) {
        return b.total - a.total;
      }).slice(0, 10);
      var defaultColors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B', '#795548', '#607D8B', '#E91E63'];
      var colors = sortedData.map(function (d, i) {
        return d.color || defaultColors[i % defaultColors.length];
      });
      this.reportCharts.spending = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'doughnut',
        data: {
          labels: sortedData.map(function (d) {
            return d.name;
          }),
          datasets: [{
            data: sortedData.map(function (d) {
              return d.total;
            }),
            backgroundColor: colors,
            borderWidth: 2,
            borderColor: '#fff'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '60%',
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  var value = context.raw;
                  var pct = totalSpending > 0 ? (value / totalSpending * 100).toFixed(1) : 0;
                  return "".concat(context.label, ": ").concat(_this5.formatCurrency(value), " (").concat(pct, "%)");
                }
              }
            }
          }
        }
      });

      // Render custom legend
      this.renderSpendingLegend(sortedData, totalSpending, 'report-spending-legend');
    }
  }, {
    key: "renderSpendingLegend",
    value: function renderSpendingLegend(data, totalSpending, containerId) {
      var _this6 = this;
      var container = document.getElementById(containerId);
      if (!container) return;
      var defaultColors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B', '#795548', '#607D8B', '#E91E63'];
      container.innerHTML = data.slice(0, 8).map(function (item, i) {
        var pct = totalSpending > 0 ? (item.total / totalSpending * 100).toFixed(1) : 0;
        var color = item.color || defaultColors[i % defaultColors.length];
        return "\n                <div class=\"spending-legend-item\">\n                    <span class=\"spending-legend-color\" style=\"background: ".concat(color, "\"></span>\n                    <span class=\"spending-legend-name\">").concat(item.name, "</span>\n                    <span class=\"spending-legend-value\">").concat(_this6.formatCurrency(item.total), "</span>\n                    <span class=\"spending-legend-pct\">").concat(pct, "%</span>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "renderReportCategoryTable",
    value: function renderReportCategoryTable(data, totalSpending, currency) {
      var _this7 = this;
      var tbody = document.querySelector('#report-categories-table tbody');
      if (!tbody) return;
      var sortedData = _toConsumableArray(data).sort(function (a, b) {
        return b.total - a.total;
      });
      tbody.innerHTML = sortedData.map(function (cat) {
        var pct = totalSpending > 0 ? (cat.total / totalSpending * 100).toFixed(1) : 0;
        return "\n                <tr>\n                    <td>\n                        <span class=\"category-color\" style=\"background: ".concat(cat.color || '#888', "\"></span>\n                        ").concat(cat.name, "\n                    </td>\n                    <td class=\"text-right\">").concat(_this7.formatCurrency(cat.total, currency), "</td>\n                    <td class=\"text-right\">").concat(pct, "%</td>\n                    <td class=\"text-right\">").concat(cat.count, "</td>\n                </tr>\n            ");
      }).join('');
    }
  }, {
    key: "renderReportVendorTable",
    value: function renderReportVendorTable(data, currency) {
      var _this8 = this;
      var tbody = document.querySelector('#report-vendors-table tbody');
      if (!tbody) return;
      tbody.innerHTML = data.map(function (vendor) {
        return "\n            <tr>\n                <td>".concat(vendor.name, "</td>\n                <td class=\"text-right\">").concat(_this8.formatCurrency(vendor.total, currency), "</td>\n                <td class=\"text-right\">").concat(vendor.count, "</td>\n            </tr>\n        ");
      }).join('');
    }
  }, {
    key: "generateCashFlowReport",
    value: function () {
      var _generateCashFlowReport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(params) {
        var response, data, section, currency, averages, avgIncomeEl, avgExpensesEl, avgNetEl;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/reports/cashflow?".concat(params)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 2;
                break;
              }
              throw new Error('Failed to fetch cash flow');
            case 2:
              _context6.n = 3;
              return response.json();
            case 3:
              data = _context6.v;
              section = document.getElementById('report-cashflow');
              if (section) section.style.display = 'block';
              currency = this.getPrimaryCurrency();
              averages = data.averageMonthly || {}; // Update average cards
              avgIncomeEl = document.getElementById('report-avg-income');
              avgExpensesEl = document.getElementById('report-avg-expenses');
              avgNetEl = document.getElementById('report-avg-net');
              if (avgIncomeEl) avgIncomeEl.textContent = this.formatCurrency(averages.income || 0, currency);
              if (avgExpensesEl) avgExpensesEl.textContent = this.formatCurrency(averages.expenses || 0, currency);
              if (avgNetEl) avgNetEl.textContent = this.formatCurrency(averages.net || 0, currency);

              // Render chart
              this.renderCashFlowChart(data.data || []);

              // Render table
              this.renderCashFlowTable(data.data || [], currency);
            case 4:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function generateCashFlowReport(_x3) {
        return _generateCashFlowReport.apply(this, arguments);
      }
      return generateCashFlowReport;
    }()
  }, {
    key: "renderCashFlowChart",
    value: function renderCashFlowChart(data) {
      var _this9 = this;
      var canvas = document.getElementById('report-cashflow-chart');
      if (!canvas) return;
      if (this.reportCharts.cashflow) {
        this.reportCharts.cashflow.destroy();
      }
      var ctx = canvas.getContext('2d');
      var currency = this.getPrimaryCurrency();
      this.reportCharts.cashflow = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'bar',
        data: {
          labels: data.map(function (d) {
            return _this9.formatReportMonthLabel(d.month);
          }),
          datasets: [{
            label: 'Income',
            data: data.map(function (d) {
              return d.income;
            }),
            backgroundColor: 'rgba(46, 125, 50, 0.7)',
            borderColor: 'rgba(46, 125, 50, 1)',
            borderWidth: 1,
            order: 2
          }, {
            label: 'Expenses',
            data: data.map(function (d) {
              return d.expenses;
            }),
            backgroundColor: 'rgba(198, 40, 40, 0.7)',
            borderColor: 'rgba(198, 40, 40, 1)',
            borderWidth: 1,
            order: 2
          }, {
            label: 'Net Cash Flow',
            data: data.map(function (d) {
              return d.net;
            }),
            borderColor: 'rgba(33, 150, 243, 1)',
            backgroundColor: 'rgba(33, 150, 243, 0.1)',
            borderWidth: 2,
            type: 'line',
            tension: 0.3,
            pointRadius: 4,
            fill: true,
            order: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this9.formatCurrency(context.raw, currency));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function callback(value) {
                  return _this9.formatCurrencyCompact(value, currency);
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "renderCashFlowTable",
    value: function renderCashFlowTable(data, currency) {
      var _this0 = this;
      var tbody = document.querySelector('#report-cashflow-table tbody');
      if (!tbody) return;
      var cumulative = 0;
      tbody.innerHTML = data.map(function (row) {
        cumulative += row.net;
        return "\n                <tr>\n                    <td>".concat(_this0.formatReportMonthLabel(row.month), "</td>\n                    <td class=\"text-right positive\">").concat(_this0.formatCurrency(row.income, currency), "</td>\n                    <td class=\"text-right negative\">").concat(_this0.formatCurrency(row.expenses, currency), "</td>\n                    <td class=\"text-right ").concat(row.net >= 0 ? 'positive' : 'negative', "\">").concat(_this0.formatCurrency(row.net, currency), "</td>\n                    <td class=\"text-right ").concat(cumulative >= 0 ? 'positive' : 'negative', "\">").concat(_this0.formatCurrency(cumulative, currency), "</td>\n                </tr>\n            ");
      }).join('');
    }
  }, {
    key: "formatReportMonthLabel",
    value: function formatReportMonthLabel(yearMonth) {
      if (!yearMonth) return '';
      var _yearMonth$split = yearMonth.split('-'),
        _yearMonth$split2 = _slicedToArray(_yearMonth$split, 2),
        year = _yearMonth$split2[0],
        month = _yearMonth$split2[1];
      var date = new Date(year, month - 1);
      return date.toLocaleDateString('en-US', {
        month: 'short',
        year: 'numeric'
      });
    }

    // ==========================================
    // Year over Year Report Functions
    // ==========================================
  }, {
    key: "showYoYReport",
    value: function showYoYReport() {
      var section = document.getElementById('report-yoy');
      if (section) section.style.display = 'block';

      // Setup YoY controls if not already done
      if (!this.yoyControlsSetup) {
        this.setupYoYControls();
        this.yoyControlsSetup = true;
      }

      // Set default month to current month
      var monthSelect = document.getElementById('yoy-month');
      if (monthSelect) {
        monthSelect.value = new Date().getMonth() + 1;
      }
    }
  }, {
    key: "setupYoYControls",
    value: function setupYoYControls() {
      var _this1 = this;
      var comparisonType = document.getElementById('yoy-comparison-type');
      var generateBtn = document.getElementById('generate-yoy-btn');
      var monthSelect = document.querySelector('.yoy-month-select');
      if (comparisonType) {
        comparisonType.addEventListener('change', function (e) {
          if (monthSelect) {
            monthSelect.style.display = e.target.value === 'month' ? '' : 'none';
          }
        });
      }
      if (generateBtn) {
        generateBtn.addEventListener('click', function () {
          return _this1.generateYoYComparison();
        });
      }
    }
  }, {
    key: "generateYoYComparison",
    value: function () {
      var _generateYoYComparison = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var _document$getElementB7, _document$getElementB8, _document$getElementB9, _document$getElementB0, _document$getElementB1, _document$getElementB10;
        var comparisonType, years, month, loadingEl, endpoint, response, data, _t4, _t5;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              comparisonType = ((_document$getElementB7 = document.getElementById('yoy-comparison-type')) === null || _document$getElementB7 === void 0 ? void 0 : _document$getElementB7.value) || 'years';
              years = ((_document$getElementB8 = document.getElementById('yoy-years')) === null || _document$getElementB8 === void 0 ? void 0 : _document$getElementB8.value) || 3;
              month = ((_document$getElementB9 = document.getElementById('yoy-month')) === null || _document$getElementB9 === void 0 ? void 0 : _document$getElementB9.value) || new Date().getMonth() + 1; // Show loading
              loadingEl = document.getElementById('report-loading');
              if (loadingEl) loadingEl.style.display = 'flex';

              // Hide all YoY sections
              (_document$getElementB0 = document.getElementById('yoy-summary')) === null || _document$getElementB0 === void 0 || _document$getElementB0.style.setProperty('display', 'none');
              (_document$getElementB1 = document.getElementById('yoy-chart-container')) === null || _document$getElementB1 === void 0 || _document$getElementB1.style.setProperty('display', 'none');
              (_document$getElementB10 = document.getElementById('yoy-category-table-container')) === null || _document$getElementB10 === void 0 || _document$getElementB10.style.setProperty('display', 'none');
              _context7.p = 1;
              _t4 = comparisonType;
              _context7.n = _t4 === 'month' ? 2 : _t4 === 'categories' ? 3 : 4;
              break;
            case 2:
              endpoint = "/apps/budget/api/yoy/month?month=".concat(month, "&years=").concat(years);
              return _context7.a(3, 5);
            case 3:
              endpoint = "/apps/budget/api/yoy/categories?years=".concat(years);
              return _context7.a(3, 5);
            case 4:
              endpoint = "/apps/budget/api/yoy/years?years=".concat(years);
            case 5:
              _context7.n = 6;
              return fetch(OC.generateUrl(endpoint), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 6:
              response = _context7.v;
              if (response.ok) {
                _context7.n = 7;
                break;
              }
              throw new Error('Failed to fetch YoY data');
            case 7:
              _context7.n = 8;
              return response.json();
            case 8:
              data = _context7.v;
              if (comparisonType === 'categories') {
                this.displayYoYCategories(data);
              } else {
                this.displayYoYComparison(data);
              }
              _context7.n = 10;
              break;
            case 9:
              _context7.p = 9;
              _t5 = _context7.v;
              console.error('Failed to generate YoY comparison:', _t5);
              OC.Notification.showTemporary('Failed to generate comparison');
            case 10:
              _context7.p = 10;
              if (loadingEl) loadingEl.style.display = 'none';
              return _context7.f(10);
            case 11:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 9, 10, 11]]);
      }));
      function generateYoYComparison() {
        return _generateYoYComparison.apply(this, arguments);
      }
      return generateYoYComparison;
    }()
  }, {
    key: "displayYoYComparison",
    value: function displayYoYComparison(data) {
      var _this10 = this;
      var currency = this.getPrimaryCurrency();
      var summaryEl = document.getElementById('yoy-summary');
      var cardsEl = document.getElementById('yoy-year-cards');
      var chartContainer = document.getElementById('yoy-chart-container');
      var chartTitle = document.getElementById('yoy-chart-title');
      if (!summaryEl || !cardsEl) return;
      summaryEl.style.display = '';
      if (chartContainer) chartContainer.style.display = '';

      // Build year cards
      cardsEl.innerHTML = data.years.map(function (year) {
        var _year$incomeChange, _year$expenseChange;
        var changeHtml = year.incomeChange !== undefined ? "\n                <div class=\"yoy-change-indicators\">\n                    <span class=\"yoy-change ".concat(year.incomeChange >= 0 ? 'positive' : 'negative', "\">\n                        Income: ").concat(year.incomeChange >= 0 ? '+' : '').concat(((_year$incomeChange = year.incomeChange) === null || _year$incomeChange === void 0 ? void 0 : _year$incomeChange.toFixed(1)) || '0', "%\n                    </span>\n                    <span class=\"yoy-change ").concat(year.expenseChange <= 0 ? 'positive' : 'negative', "\">\n                        Expenses: ").concat(year.expenseChange >= 0 ? '+' : '').concat(((_year$expenseChange = year.expenseChange) === null || _year$expenseChange === void 0 ? void 0 : _year$expenseChange.toFixed(1)) || '0', "%\n                    </span>\n                </div>\n            ") : '';
        return "\n                <div class=\"yoy-year-card ".concat(year.isCurrent ? 'current-year' : '', "\">\n                    <div class=\"yoy-year-header\">\n                        <span class=\"yoy-year-label\">").concat(year.year).concat(year.isCurrent ? ' (YTD)' : '', "</span>\n                        ").concat(year.monthName ? "<span class=\"yoy-month-label\">".concat(year.monthName, "</span>") : '', "\n                    </div>\n                    <div class=\"yoy-year-stats\">\n                        <div class=\"yoy-stat\">\n                            <span class=\"yoy-stat-label\">Income</span>\n                            <span class=\"yoy-stat-value positive\">").concat(_this10.formatCurrency(year.income, currency), "</span>\n                        </div>\n                        <div class=\"yoy-stat\">\n                            <span class=\"yoy-stat-label\">Expenses</span>\n                            <span class=\"yoy-stat-value negative\">").concat(_this10.formatCurrency(year.expenses, currency), "</span>\n                        </div>\n                        <div class=\"yoy-stat\">\n                            <span class=\"yoy-stat-label\">Savings</span>\n                            <span class=\"yoy-stat-value ").concat(year.savings >= 0 ? 'positive' : 'negative', "\">").concat(_this10.formatCurrency(year.savings, currency), "</span>\n                        </div>\n                    </div>\n                    ").concat(changeHtml, "\n                </div>\n            ");
      }).join('');

      // Update chart title
      if (chartTitle) {
        chartTitle.textContent = data.type === 'month' ? "".concat(data.monthName, " - Year over Year Comparison") : 'Annual Income & Expenses';
      }

      // Render chart
      this.renderYoYChart(data.years);
    }
  }, {
    key: "renderYoYChart",
    value: function renderYoYChart(years) {
      var _this11 = this;
      var canvas = document.getElementById('yoy-chart');
      if (!canvas) return;
      if (this.reportCharts.yoy) {
        this.reportCharts.yoy.destroy();
      }
      var ctx = canvas.getContext('2d');
      var currency = this.getPrimaryCurrency();
      this.reportCharts.yoy = new chart_js_auto__WEBPACK_IMPORTED_MODULE_2__["default"](ctx, {
        type: 'bar',
        data: {
          labels: years.map(function (y) {
            return y.year.toString();
          }),
          datasets: [{
            label: 'Income',
            data: years.map(function (y) {
              return y.income;
            }),
            backgroundColor: 'rgba(46, 125, 50, 0.7)',
            borderColor: 'rgba(46, 125, 50, 1)',
            borderWidth: 1
          }, {
            label: 'Expenses',
            data: years.map(function (y) {
              return y.expenses;
            }),
            backgroundColor: 'rgba(198, 40, 40, 0.7)',
            borderColor: 'rgba(198, 40, 40, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                label: function label(context) {
                  return "".concat(context.dataset.label, ": ").concat(_this11.formatCurrency(context.raw, currency));
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function callback(value) {
                  return _this11.formatCurrencyCompact(value, currency);
                }
              }
            }
          }
        }
      });
    }
  }, {
    key: "displayYoYCategories",
    value: function displayYoYCategories(data) {
      var _data$categories$,
        _this12 = this;
      var tableContainer = document.getElementById('yoy-category-table-container');
      var headerRow = document.getElementById('yoy-category-header');
      var tbody = document.getElementById('yoy-category-body');
      if (!tableContainer || !headerRow || !tbody) return;
      tableContainer.style.display = '';
      var currency = this.getPrimaryCurrency();

      // Build header with year columns
      var years = ((_data$categories$ = data.categories[0]) === null || _data$categories$ === void 0 ? void 0 : _data$categories$.years) || [];
      headerRow.innerHTML = '<th>Category</th>' + years.map(function (y) {
        return "<th class=\"text-right\">".concat(y.year, "</th>");
      }).join('') + '<th class="text-right">Change</th>';

      // Build table rows
      tbody.innerHTML = data.categories.map(function (cat) {
        var changeHtml = cat.change !== null ? "<span class=\"".concat(cat.change <= 0 ? 'positive' : 'negative', "\">").concat(cat.change >= 0 ? '+' : '').concat(cat.change.toFixed(1), "%</span>") : 'N/A';
        return "\n                <tr>\n                    <td>".concat(_this12.escapeHtml(cat.name), "</td>\n                    ").concat(cat.years.map(function (y) {
          return "<td class=\"text-right\">".concat(_this12.formatCurrency(y.spending, currency), "</td>");
        }).join(''), "\n                    <td class=\"text-right\">").concat(changeHtml, "</td>\n                </tr>\n            ");
      }).join('');
    }
  }, {
    key: "exportReport",
    value: function () {
      var _exportReport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(format) {
        var _document$getElementB11, _document$getElementB12, _document$getElementB13, _document$getElementB14;
        var reportType, startDate, endDate, accountId, response, blob, filename, url, a, _t6;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              reportType = ((_document$getElementB11 = document.getElementById('report-type')) === null || _document$getElementB11 === void 0 ? void 0 : _document$getElementB11.value) || 'summary';
              startDate = (_document$getElementB12 = document.getElementById('report-start-date')) === null || _document$getElementB12 === void 0 ? void 0 : _document$getElementB12.value;
              endDate = (_document$getElementB13 = document.getElementById('report-end-date')) === null || _document$getElementB13 === void 0 ? void 0 : _document$getElementB13.value;
              accountId = ((_document$getElementB14 = document.getElementById('report-account')) === null || _document$getElementB14 === void 0 ? void 0 : _document$getElementB14.value) || '';
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/reports/export'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  type: reportType,
                  format: format,
                  startDate: startDate,
                  endDate: endDate,
                  accountId: accountId || null
                })
              });
            case 2:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 3;
                break;
              }
              throw new Error('Export failed');
            case 3:
              _context8.n = 4;
              return response.blob();
            case 4:
              blob = _context8.v;
              filename = "".concat(reportType, "_report_").concat(new Date().toISOString().split('T')[0], ".").concat(format); // Trigger download
              url = window.URL.createObjectURL(blob);
              a = document.createElement('a');
              a.href = url;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);
              OC.Notification.showTemporary("Report exported as ".concat(format.toUpperCase()));
              _context8.n = 6;
              break;
            case 5:
              _context8.p = 5;
              _t6 = _context8.v;
              console.error('Export failed:', _t6);
              OC.Notification.showTemporary('Failed to export report');
            case 6:
              return _context8.a(2);
          }
        }, _callee8, null, [[1, 5]]);
      }));
      function exportReport(_x4) {
        return _exportReport.apply(this, arguments);
      }
      return exportReport;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/rules/RulesModule.js":
/*!******************************************!*\
  !*** ./src/modules/rules/RulesModule.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RulesModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Rules Module - Transaction auto-categorization rules
 */


var RulesModule = /*#__PURE__*/function () {
  function RulesModule(app) {
    _classCallCheck(this, RulesModule);
    this.app = app;
  }

  // Getters for app state
  return _createClass(RulesModule, [{
    key: "rules",
    get: function get() {
      return this.app.rules;
    },
    set: function set(value) {
      this.app.rules = value;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "currentView",
    get: function get() {
      return this.app.currentView;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }

    // Helper method delegations
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(dateStr) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(dateStr, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "hideModals",
    value: function hideModals() {
      return this.app.hideModals();
    }
  }, {
    key: "loadTransactions",
    value: function () {
      var _loadTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              return _context.a(2, this.app.loadTransactions());
          }
        }, _callee, this);
      }));
      function loadTransactions() {
        return _loadTransactions.apply(this, arguments);
      }
      return loadTransactions;
    }()
  }, {
    key: "loadRulesView",
    value: function () {
      var _loadRulesView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              // Always setup event listeners first, even if data load fails
              this.setupRulesEventListeners();
              _context2.p = 1;
              _context2.n = 2;
              return this.loadRules();
            case 2:
              _context2.n = 4;
              break;
            case 3:
              _context2.p = 3;
              _t = _context2.v;
              console.error('Failed to load rules view:', _t);
              OC.Notification.showTemporary('Failed to load rules');
            case 4:
              return _context2.a(2);
          }
        }, _callee2, this, [[1, 3]]);
      }));
      function loadRulesView() {
        return _loadRulesView.apply(this, arguments);
      }
      return loadRulesView;
    }()
  }, {
    key: "loadRules",
    value: function () {
      var _loadRules = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var response, _t2;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/import-rules'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context3.n = 3;
              return response.json();
            case 3:
              this.rules = _context3.v;
              this.renderRules(this.rules);
              this.updateRulesSummary();
              _context3.n = 5;
              break;
            case 4:
              _context3.p = 4;
              _t2 = _context3.v;
              console.error('Failed to load rules:', _t2);
              throw _t2;
            case 5:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 4]]);
      }));
      function loadRules() {
        return _loadRules.apply(this, arguments);
      }
      return loadRules;
    }()
  }, {
    key: "renderRules",
    value: function renderRules(rules) {
      var _this = this;
      var rulesList = document.getElementById('rules-list');
      var emptyRules = document.getElementById('empty-rules');
      if (!rulesList) return;
      if (!rules || rules.length === 0) {
        rulesList.innerHTML = '';
        if (emptyRules) emptyRules.style.display = 'flex';
        return;
      }
      if (emptyRules) emptyRules.style.display = 'none';
      rulesList.innerHTML = rules.map(function (rule) {
        var actions = rule.actions || {};
        var actionBadges = _this.getRuleActionBadges(rule, actions);
        var matchTypeLabels = {
          'contains': 'contains',
          'exact': 'equals',
          'starts_with': 'starts with',
          'ends_with': 'ends with',
          'regex': 'matches'
        };
        var criteriaText = "".concat(rule.field, " ").concat(matchTypeLabels[rule.matchType] || rule.matchType, " \"").concat(_this.escapeHtml(rule.pattern), "\"");
        return "\n                <tr class=\"rule-row ".concat(rule.active ? '' : 'inactive', "\" data-rule-id=\"").concat(rule.id, "\">\n                    <td class=\"rules-col-priority\">").concat(rule.priority, "</td>\n                    <td class=\"rules-col-name\">").concat(_this.escapeHtml(rule.name), "</td>\n                    <td class=\"rules-col-status\">\n                        <label class=\"rule-toggle\" title=\"").concat(rule.active ? 'Click to disable' : 'Click to enable', "\">\n                            <input type=\"checkbox\" class=\"rule-active-toggle\" data-rule-id=\"").concat(rule.id, "\" ").concat(rule.active ? 'checked' : '', ">\n                            <span class=\"rule-toggle-slider\"></span>\n                        </label>\n                        ").concat(rule.applyOnImport ? '<span class="status-badge import">Import</span>' : '', "\n                    </td>\n                    <td class=\"rules-col-criteria\"><code>").concat(criteriaText, "</code></td>\n                    <td class=\"rules-col-actions\">").concat(actionBadges, "</td>\n                    <td class=\"rules-col-buttons\">\n                        <button class=\"icon-rename rule-edit-btn\" data-rule-id=\"").concat(rule.id, "\" title=\"Edit rule\"></button>\n                        <button class=\"icon-delete rule-delete-btn\" data-rule-id=\"").concat(rule.id, "\" title=\"Delete rule\"></button>\n                    </td>\n                </tr>\n            ");
      }).join('');
    }
  }, {
    key: "getRuleActionBadges",
    value: function getRuleActionBadges(rule, actions) {
      var badges = [];

      // Check for category action
      var categoryId = actions.categoryId || rule.categoryId;
      if (categoryId) {
        var _this$categories;
        var category = (_this$categories = this.categories) === null || _this$categories === void 0 ? void 0 : _this$categories.find(function (c) {
          return c.id === categoryId;
        });
        var categoryName = (category === null || category === void 0 ? void 0 : category.name) || "Category #".concat(categoryId);
        badges.push("<span class=\"action-badge category\">\u2192 ".concat(this.escapeHtml(categoryName), "</span>"));
      }

      // Check for vendor action
      var vendor = actions.vendor || rule.vendorName;
      if (vendor) {
        badges.push("<span class=\"action-badge vendor\">Vendor: ".concat(this.escapeHtml(vendor), "</span>"));
      }

      // Check for notes action
      if (actions.notes) {
        badges.push("<span class=\"action-badge notes\">Set notes</span>");
      }
      return badges.length > 0 ? badges.join('') : '<span class="action-badge none">No actions</span>';
    }
  }, {
    key: "updateRulesSummary",
    value: function updateRulesSummary() {
      var totalCount = document.getElementById('rules-total-count');
      var activeCount = document.getElementById('rules-active-count');
      if (totalCount && this.rules) {
        totalCount.textContent = this.rules.length;
      }
      if (activeCount && this.rules) {
        activeCount.textContent = this.rules.filter(function (r) {
          return r.active;
        }).length;
      }
    }
  }, {
    key: "setupRulesEventListeners",
    value: function setupRulesEventListeners() {
      var _this2 = this;
      console.log('setupRulesEventListeners called');

      // Add Rule button in view header
      var addRuleBtn = document.getElementById('rules-add-btn');
      console.log('rules-add-btn found:', addRuleBtn);
      if (addRuleBtn && !addRuleBtn.dataset.listenerAttached) {
        addRuleBtn.addEventListener('click', function () {
          console.log('Add Rule button clicked');
          _this2.showRuleModal();
        });
        addRuleBtn.dataset.listenerAttached = 'true';
      }

      // Empty state add button
      var emptyAddBtn = document.getElementById('empty-rules-add-btn');
      if (emptyAddBtn && !emptyAddBtn.dataset.listenerAttached) {
        emptyAddBtn.addEventListener('click', function () {
          return _this2.showRuleModal();
        });
        emptyAddBtn.dataset.listenerAttached = 'true';
      }

      // Apply Rules button
      var applyRulesBtn = document.getElementById('apply-rules-btn');
      if (applyRulesBtn && !applyRulesBtn.dataset.listenerAttached) {
        applyRulesBtn.addEventListener('click', function () {
          return _this2.showApplyRulesModal();
        });
        applyRulesBtn.dataset.listenerAttached = 'true';
      }

      // Rule form submit
      var ruleForm = document.getElementById('rule-form');
      if (ruleForm && !ruleForm.dataset.listenerAttached) {
        ruleForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveRule();
        });
        ruleForm.dataset.listenerAttached = 'true';
      }

      // Preview button in apply modal
      var previewBtn = document.getElementById('preview-rules-btn');
      if (previewBtn && !previewBtn.dataset.listenerAttached) {
        previewBtn.addEventListener('click', function () {
          return _this2.previewRuleApplication();
        });
        previewBtn.dataset.listenerAttached = 'true';
      }

      // Execute apply button
      var executeBtn = document.getElementById('execute-apply-rules-btn');
      if (executeBtn && !executeBtn.dataset.listenerAttached) {
        executeBtn.addEventListener('click', function () {
          return _this2.executeApplyRules();
        });
        executeBtn.dataset.listenerAttached = 'true';
      }

      // Select/Deselect all rules
      var selectAllBtn = document.getElementById('select-all-rules');
      var deselectAllBtn = document.getElementById('deselect-all-rules');
      if (selectAllBtn && !selectAllBtn.dataset.listenerAttached) {
        selectAllBtn.addEventListener('click', function () {
          return _this2.toggleAllRuleSelections(true);
        });
        selectAllBtn.dataset.listenerAttached = 'true';
      }
      if (deselectAllBtn && !deselectAllBtn.dataset.listenerAttached) {
        deselectAllBtn.addEventListener('click', function () {
          return _this2.toggleAllRuleSelections(false);
        });
        deselectAllBtn.dataset.listenerAttached = 'true';
      }

      // Delegate click events for rule cards
      var rulesList = document.getElementById('rules-list');
      if (rulesList && !rulesList.dataset.listenerAttached) {
        rulesList.addEventListener('click', function (e) {
          var editBtn = e.target.closest('.rule-edit-btn');
          var deleteBtn = e.target.closest('.rule-delete-btn');
          if (editBtn) {
            var ruleId = parseInt(editBtn.dataset.ruleId);
            _this2.editRule(ruleId);
          } else if (deleteBtn) {
            var _ruleId = parseInt(deleteBtn.dataset.ruleId);
            _this2.deleteRule(_ruleId);
          }
        });

        // Toggle active state
        rulesList.addEventListener('change', function (e) {
          if (e.target.classList.contains('rule-active-toggle')) {
            var ruleId = parseInt(e.target.dataset.ruleId);
            var active = e.target.checked;
            _this2.toggleRuleActive(ruleId, active);
          }
        });
        rulesList.dataset.listenerAttached = 'true';
      }
    }
  }, {
    key: "showRuleModal",
    value: function () {
      var _showRuleModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var rule,
          modal,
          title,
          form,
          actions,
          nameField,
          _args4 = arguments;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              rule = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : null;
              console.log('showRuleModal called', rule);
              modal = document.getElementById('rule-modal');
              title = document.getElementById('rule-modal-title');
              form = document.getElementById('rule-form');
              console.log('modal:', modal, 'form:', form);
              if (!(!modal || !form)) {
                _context4.n = 1;
                break;
              }
              console.error('Modal or form not found!');
              return _context4.a(2);
            case 1:
              form.reset();
              document.getElementById('rule-id').value = '';

              // Populate category dropdown
              _context4.n = 2;
              return this.populateRuleCategoryDropdown();
            case 2:
              if (rule) {
                title.textContent = 'Edit Rule';
                document.getElementById('rule-id').value = rule.id;
                document.getElementById('rule-name').value = rule.name || '';
                document.getElementById('rule-field').value = rule.field || 'description';
                document.getElementById('rule-match-type').value = rule.matchType || 'contains';
                document.getElementById('rule-pattern').value = rule.pattern || '';
                document.getElementById('rule-priority').value = rule.priority || 0;
                document.getElementById('rule-active').checked = rule.active !== false;
                document.getElementById('rule-apply-on-import').checked = rule.applyOnImport !== false;

                // Parse actions
                actions = rule.actions || {};
                document.getElementById('rule-action-category').value = actions.categoryId || rule.categoryId || '';
                document.getElementById('rule-action-vendor').value = actions.vendor || rule.vendorName || '';
                document.getElementById('rule-action-notes').value = actions.notes || '';
              } else {
                title.textContent = 'Add Rule';
              }
              modal.style.display = 'flex';
              modal.setAttribute('aria-hidden', 'false');

              // Focus on name field
              nameField = document.getElementById('rule-name');
              if (nameField) nameField.focus();
            case 3:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function showRuleModal() {
        return _showRuleModal.apply(this, arguments);
      }
      return showRuleModal;
    }()
  }, {
    key: "populateRuleCategoryDropdown",
    value: function () {
      var _populateRuleCategoryDropdown = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var select, firstOption;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              select = document.getElementById('rule-action-category');
              if (select) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              // Keep first option (-- Don't change --)
              firstOption = select.options[0];
              select.innerHTML = '';
              select.appendChild(firstOption);

              // Add categories
              if (this.categories) {
                this.categories.forEach(function (cat) {
                  var option = document.createElement('option');
                  option.value = cat.id;
                  option.textContent = cat.name;
                  select.appendChild(option);
                });
              }
            case 2:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function populateRuleCategoryDropdown() {
        return _populateRuleCategoryDropdown.apply(this, arguments);
      }
      return populateRuleCategoryDropdown;
    }()
  }, {
    key: "saveRule",
    value: function () {
      var _saveRule = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var ruleId, isEdit, name, field, matchType, pattern, priority, active, applyOnImport, categoryId, vendor, notes, actions, url, response, error, _t3;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              ruleId = document.getElementById('rule-id').value;
              isEdit = !!ruleId; // Collect form data
              name = document.getElementById('rule-name').value.trim();
              field = document.getElementById('rule-field').value;
              matchType = document.getElementById('rule-match-type').value;
              pattern = document.getElementById('rule-pattern').value.trim();
              priority = parseInt(document.getElementById('rule-priority').value) || 0;
              active = document.getElementById('rule-active').checked;
              applyOnImport = document.getElementById('rule-apply-on-import').checked; // Collect actions
              categoryId = document.getElementById('rule-action-category').value;
              vendor = document.getElementById('rule-action-vendor').value.trim();
              notes = document.getElementById('rule-action-notes').value.trim();
              actions = {};
              if (categoryId) actions.categoryId = parseInt(categoryId);
              if (vendor) actions.vendor = vendor;
              if (notes) actions.notes = notes;
              _context6.p = 1;
              url = isEdit ? OC.generateUrl("/apps/budget/api/import-rules/".concat(ruleId)) : OC.generateUrl('/apps/budget/api/import-rules');
              _context6.n = 2;
              return fetch(url, {
                method: isEdit ? 'PUT' : 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  name: name,
                  pattern: pattern,
                  field: field,
                  matchType: matchType,
                  priority: priority,
                  active: active,
                  applyOnImport: applyOnImport,
                  actions: Object.keys(actions).length > 0 ? actions : null
                })
              });
            case 2:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 4;
                break;
              }
              _context6.n = 3;
              return response.json();
            case 3:
              error = _context6.v;
              throw new Error(error.error || 'Failed to save rule');
            case 4:
              OC.Notification.showTemporary(isEdit ? 'Rule updated successfully' : 'Rule created successfully');
              this.hideModals();
              _context6.n = 5;
              return this.loadRules();
            case 5:
              _context6.n = 7;
              break;
            case 6:
              _context6.p = 6;
              _t3 = _context6.v;
              console.error('Failed to save rule:', _t3);
              OC.Notification.showTemporary('Failed to save rule: ' + _t3.message);
            case 7:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 6]]);
      }));
      function saveRule() {
        return _saveRule.apply(this, arguments);
      }
      return saveRule;
    }()
  }, {
    key: "editRule",
    value: function () {
      var _editRule = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(ruleId) {
        var response, rule, _t4;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              _context7.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/import-rules/".concat(ruleId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context7.v;
              if (response.ok) {
                _context7.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context7.n = 3;
              return response.json();
            case 3:
              rule = _context7.v;
              this.showRuleModal(rule);
              _context7.n = 5;
              break;
            case 4:
              _context7.p = 4;
              _t4 = _context7.v;
              console.error('Failed to load rule:', _t4);
              OC.Notification.showTemporary('Failed to load rule');
            case 5:
              return _context7.a(2);
          }
        }, _callee7, this, [[0, 4]]);
      }));
      function editRule(_x) {
        return _editRule.apply(this, arguments);
      }
      return editRule;
    }()
  }, {
    key: "deleteRule",
    value: function () {
      var _deleteRule = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(ruleId) {
        var response, _t5;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              if (confirm('Are you sure you want to delete this rule?')) {
                _context8.n = 1;
                break;
              }
              return _context8.a(2);
            case 1:
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/import-rules/".concat(ruleId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              OC.Notification.showTemporary('Rule deleted successfully');
              _context8.n = 4;
              return this.loadRules();
            case 4:
              _context8.n = 6;
              break;
            case 5:
              _context8.p = 5;
              _t5 = _context8.v;
              console.error('Failed to delete rule:', _t5);
              OC.Notification.showTemporary('Failed to delete rule');
            case 6:
              return _context8.a(2);
          }
        }, _callee8, this, [[1, 5]]);
      }));
      function deleteRule(_x2) {
        return _deleteRule.apply(this, arguments);
      }
      return deleteRule;
    }()
  }, {
    key: "toggleRuleActive",
    value: function () {
      var _toggleRuleActive = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(ruleId, active) {
        var rule, response, error, row, _t6;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              // Find the rule data
              rule = this.rules.find(function (r) {
                return r.id === ruleId;
              });
              if (rule) {
                _context9.n = 1;
                break;
              }
              throw new Error('Rule not found');
            case 1:
              _context9.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/import-rules/".concat(ruleId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(_objectSpread(_objectSpread({}, rule), {}, {
                  active: active
                }))
              });
            case 2:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 4;
                break;
              }
              _context9.n = 3;
              return response.json();
            case 3:
              error = _context9.v;
              throw new Error(error.error || 'Failed to update rule');
            case 4:
              // Update local state
              rule.active = active;

              // Update the row styling
              row = document.querySelector(".rule-row[data-rule-id=\"".concat(ruleId, "\"]"));
              if (row) {
                row.classList.toggle('inactive', !active);
              }
              OC.Notification.showTemporary(active ? 'Rule enabled' : 'Rule disabled');
              _context9.n = 6;
              break;
            case 5:
              _context9.p = 5;
              _t6 = _context9.v;
              console.error('Failed to toggle rule:', _t6);
              OC.Notification.showTemporary('Failed to update rule: ' + _t6.message);
              // Revert the checkbox
              _context9.n = 6;
              return this.loadRules();
            case 6:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 5]]);
      }));
      function toggleRuleActive(_x3, _x4) {
        return _toggleRuleActive.apply(this, arguments);
      }
      return toggleRuleActive;
    }()
  }, {
    key: "showApplyRulesModal",
    value: function () {
      var _showApplyRulesModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        var modal;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              modal = document.getElementById('apply-rules-modal');
              if (modal) {
                _context0.n = 1;
                break;
              }
              return _context0.a(2);
            case 1:
              // Reset state
              document.getElementById('apply-rules-preview').style.display = 'none';
              document.getElementById('apply-rules-results').style.display = 'none';
              document.getElementById('execute-apply-rules-btn').disabled = true;

              // Populate account filter
              _context0.n = 2;
              return this.populateApplyRulesFilters();
            case 2:
              _context0.n = 3;
              return this.populateRulesSelectionList();
            case 3:
              modal.style.display = 'flex';
              modal.setAttribute('aria-hidden', 'false');
            case 4:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function showApplyRulesModal() {
        return _showApplyRulesModal.apply(this, arguments);
      }
      return showApplyRulesModal;
    }()
  }, {
    key: "populateApplyRulesFilters",
    value: function () {
      var _populateApplyRulesFilters = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
        var accountSelect, firstOption;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              accountSelect = document.getElementById('apply-account-filter');
              if (accountSelect) {
                _context1.n = 1;
                break;
              }
              return _context1.a(2);
            case 1:
              // Keep first option (All Accounts)
              firstOption = accountSelect.options[0];
              accountSelect.innerHTML = '';
              accountSelect.appendChild(firstOption);

              // Add accounts
              if (this.accounts) {
                this.accounts.forEach(function (account) {
                  var option = document.createElement('option');
                  option.value = account.id;
                  option.textContent = account.name;
                  accountSelect.appendChild(option);
                });
              }
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
      function populateApplyRulesFilters() {
        return _populateApplyRulesFilters.apply(this, arguments);
      }
      return populateApplyRulesFilters;
    }()
  }, {
    key: "populateRulesSelectionList",
    value: function () {
      var _populateRulesSelectionList = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {
        var _this$rules,
          _this3 = this;
        var container, activeRules;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              container = document.getElementById('rules-selection-list');
              if (container) {
                _context10.n = 1;
                break;
              }
              return _context10.a(2);
            case 1:
              if (this.rules) {
                _context10.n = 2;
                break;
              }
              _context10.n = 2;
              return this.loadRules();
            case 2:
              activeRules = ((_this$rules = this.rules) === null || _this$rules === void 0 ? void 0 : _this$rules.filter(function (r) {
                return r.active;
              })) || [];
              if (!(activeRules.length === 0)) {
                _context10.n = 3;
                break;
              }
              container.innerHTML = '<p class="no-rules-message">No active rules available. Create and activate rules first.</p>';
              return _context10.a(2);
            case 3:
              container.innerHTML = activeRules.map(function (rule) {
                return "\n            <label class=\"rule-selection-item\">\n                <input type=\"checkbox\" name=\"rule-select\" value=\"".concat(rule.id, "\" checked>\n                <span class=\"rule-select-name\">").concat(_this3.escapeHtml(rule.name), "</span>\n                <span class=\"rule-select-pattern\">").concat(_this3.escapeHtml(rule.pattern), "</span>\n            </label>\n        ");
              }).join('');
            case 4:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
      function populateRulesSelectionList() {
        return _populateRulesSelectionList.apply(this, arguments);
      }
      return populateRulesSelectionList;
    }()
  }, {
    key: "toggleAllRuleSelections",
    value: function toggleAllRuleSelections(checked) {
      var checkboxes = document.querySelectorAll('#rules-selection-list input[type="checkbox"]');
      checkboxes.forEach(function (cb) {
        return cb.checked = checked;
      });
    }
  }, {
    key: "previewRuleApplication",
    value: function () {
      var _previewRuleApplication = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
        var previewDiv, resultsDiv, executeBtn, previewBtn, filters, ruleIds, response, result, _t7;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              previewDiv = document.getElementById('apply-rules-preview');
              resultsDiv = document.getElementById('apply-rules-results');
              executeBtn = document.getElementById('execute-apply-rules-btn');
              previewBtn = document.getElementById('preview-rules-btn');
              if (previewDiv) {
                _context11.n = 1;
                break;
              }
              return _context11.a(2);
            case 1:
              // Collect filters
              filters = this.collectApplyRulesFilters();
              ruleIds = this.collectSelectedRuleIds();
              if (!(ruleIds.length === 0)) {
                _context11.n = 2;
                break;
              }
              OC.Notification.showTemporary('Please select at least one rule');
              return _context11.a(2);
            case 2:
              previewBtn.disabled = true;
              previewBtn.textContent = 'Loading...';
              _context11.p = 3;
              _context11.n = 4;
              return fetch(OC.generateUrl('/apps/budget/api/import-rules/preview'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(_objectSpread({
                  ruleIds: ruleIds
                }, filters))
              });
            case 4:
              response = _context11.v;
              if (response.ok) {
                _context11.n = 5;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 5:
              _context11.n = 6;
              return response.json();
            case 6:
              result = _context11.v;
              this.renderPreviewResults(result);
              previewDiv.style.display = 'block';
              resultsDiv.style.display = 'none';
              executeBtn.disabled = result.matchCount === 0;
              _context11.n = 8;
              break;
            case 7:
              _context11.p = 7;
              _t7 = _context11.v;
              console.error('Failed to preview rules:', _t7);
              OC.Notification.showTemporary('Failed to preview rule application');
            case 8:
              _context11.p = 8;
              previewBtn.disabled = false;
              previewBtn.textContent = 'Preview Changes';
              return _context11.f(8);
            case 9:
              return _context11.a(2);
          }
        }, _callee11, this, [[3, 7, 8, 9]]);
      }));
      function previewRuleApplication() {
        return _previewRuleApplication.apply(this, arguments);
      }
      return previewRuleApplication;
    }()
  }, {
    key: "collectApplyRulesFilters",
    value: function collectApplyRulesFilters() {
      var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4;
      var accountId = ((_document$getElementB = document.getElementById('apply-account-filter')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || null;
      var startDate = ((_document$getElementB2 = document.getElementById('apply-date-start')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value) || null;
      var endDate = ((_document$getElementB3 = document.getElementById('apply-date-end')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.value) || null;
      var uncategorizedOnly = ((_document$getElementB4 = document.getElementById('apply-uncategorized-only')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.checked) || false;
      return {
        accountId: accountId ? parseInt(accountId) : null,
        startDate: startDate,
        endDate: endDate,
        uncategorizedOnly: uncategorizedOnly
      };
    }
  }, {
    key: "collectSelectedRuleIds",
    value: function collectSelectedRuleIds() {
      var checkboxes = document.querySelectorAll('#rules-selection-list input[type="checkbox"]:checked');
      return Array.from(checkboxes).map(function (cb) {
        return parseInt(cb.value);
      });
    }
  }, {
    key: "renderPreviewResults",
    value: function renderPreviewResults(result) {
      var _this4 = this;
      var countSpan = document.getElementById('preview-match-count');
      var tbody = document.querySelector('#apply-rules-preview-table tbody');
      if (countSpan) countSpan.textContent = result.matchCount;
      if (tbody) {
        tbody.innerHTML = result.preview.slice(0, 50).map(function (item) {
          var changesHtml = Object.entries(item.changes).map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              field = _ref2[0],
              change = _ref2[1];
            var fromVal = change.from || '(empty)';
            var toVal = change.to || '(empty)';
            if (field === 'categoryId') {
              var _this4$categories, _this4$categories2;
              var fromCat = ((_this4$categories = _this4.categories) === null || _this4$categories === void 0 || (_this4$categories = _this4$categories.find(function (c) {
                return c.id === change.from;
              })) === null || _this4$categories === void 0 ? void 0 : _this4$categories.name) || fromVal;
              var toCat = ((_this4$categories2 = _this4.categories) === null || _this4$categories2 === void 0 || (_this4$categories2 = _this4$categories2.find(function (c) {
                return c.id === change.to;
              })) === null || _this4$categories2 === void 0 ? void 0 : _this4$categories2.name) || toVal;
              return "<span class=\"change-item\">Category: ".concat(_this4.escapeHtml(fromCat), " \u2192 ").concat(_this4.escapeHtml(toCat), "</span>");
            }
            return "<span class=\"change-item\">".concat(field, ": ").concat(_this4.escapeHtml(String(fromVal)), " \u2192 ").concat(_this4.escapeHtml(String(toVal)), "</span>");
          }).join('');
          return "\n                    <tr>\n                        <td>".concat(_this4.formatDate(item.transactionDate), "</td>\n                        <td>").concat(_this4.escapeHtml(item.transactionDescription), "</td>\n                        <td>").concat(_this4.formatCurrency(item.transactionAmount), "</td>\n                        <td>").concat(_this4.escapeHtml(item.ruleName), "</td>\n                        <td>").concat(changesHtml, "</td>\n                    </tr>\n                ");
        }).join('');
        if (result.matchCount > 50) {
          tbody.innerHTML += "<tr><td colspan=\"5\" class=\"preview-truncated\">... and ".concat(result.matchCount - 50, " more transactions</td></tr>");
        }
      }
    }
  }, {
    key: "executeApplyRules",
    value: function () {
      var _executeApplyRules = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
        var previewDiv, resultsDiv, executeBtn, filters, ruleIds, response, result, _t8;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.p = _context12.n) {
            case 0:
              previewDiv = document.getElementById('apply-rules-preview');
              resultsDiv = document.getElementById('apply-rules-results');
              executeBtn = document.getElementById('execute-apply-rules-btn');
              if (confirm('Apply rules to the previewed transactions? This will modify the selected transactions.')) {
                _context12.n = 1;
                break;
              }
              return _context12.a(2);
            case 1:
              // Collect filters and rules
              filters = this.collectApplyRulesFilters();
              ruleIds = this.collectSelectedRuleIds();
              executeBtn.disabled = true;
              executeBtn.textContent = 'Applying...';
              _context12.p = 2;
              _context12.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/import-rules/apply'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(_objectSpread({
                  ruleIds: ruleIds
                }, filters))
              });
            case 3:
              response = _context12.v;
              if (response.ok) {
                _context12.n = 4;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 4:
              _context12.n = 5;
              return response.json();
            case 5:
              result = _context12.v;
              // Show results
              document.getElementById('result-success-count').textContent = result.success;
              document.getElementById('result-skipped-count').textContent = result.skipped;
              document.getElementById('result-failed-count').textContent = result.failed;
              previewDiv.style.display = 'none';
              resultsDiv.style.display = 'block';
              OC.Notification.showTemporary("Rules applied: ".concat(result.success, " updated, ").concat(result.skipped, " skipped, ").concat(result.failed, " failed"));

              // Refresh transactions if we're on that view
              if (!(this.currentView === 'transactions')) {
                _context12.n = 6;
                break;
              }
              _context12.n = 6;
              return this.loadTransactions();
            case 6:
              _context12.n = 8;
              break;
            case 7:
              _context12.p = 7;
              _t8 = _context12.v;
              console.error('Failed to apply rules:', _t8);
              OC.Notification.showTemporary('Failed to apply rules');
            case 8:
              _context12.p = 8;
              executeBtn.disabled = false;
              executeBtn.textContent = 'Apply Rules';
              return _context12.f(8);
            case 9:
              return _context12.a(2);
          }
        }, _callee12, this, [[2, 7, 8, 9]]);
      }));
      function executeApplyRules() {
        return _executeApplyRules.apply(this, arguments);
      }
      return executeApplyRules;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/savings/SavingsModule.js":
/*!**********************************************!*\
  !*** ./src/modules/savings/SavingsModule.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SavingsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Savings Module - Savings goals tracking and management
 */


var SavingsModule = /*#__PURE__*/function () {
  function SavingsModule(app) {
    _classCallCheck(this, SavingsModule);
    this.app = app;
    this._eventsSetup = false;
  }

  // Getters for app state
  return _createClass(SavingsModule, [{
    key: "savingsGoals",
    get: function get() {
      return this.app.savingsGoals;
    },
    set: function set(value) {
      this.app.savingsGoals = value;
    }
  }, {
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "loadSavingsGoalsView",
    value: function () {
      var _loadSavingsGoalsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/savings-goals'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context.v;
              if (response.ok) {
                _context.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context.n = 3;
              return response.json();
            case 3:
              this.savingsGoals = _context.v;
              this.updateGoalsSummary();
              this.renderGoals(this.savingsGoals);

              // Setup event listeners (only once)
              if (!this._eventsSetup) {
                this.setupGoalsEventListeners();
                this._eventsSetup = true;
              }

              // Populate account dropdown in modal
              this.populateGoalAccountDropdown();
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
              console.error('Failed to load savings goals:', _t);
              OC.Notification.showTemporary('Failed to load savings goals');
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[0, 4]]);
      }));
      function loadSavingsGoalsView() {
        return _loadSavingsGoalsView.apply(this, arguments);
      }
      return loadSavingsGoalsView;
    }()
  }, {
    key: "updateGoalsSummary",
    value: function updateGoalsSummary() {
      var goals = this.savingsGoals || [];
      var activeGoals = goals.filter(function (g) {
        return !g.completed;
      });
      var completedGoals = goals.filter(function (g) {
        return g.completed;
      });
      var totalSaved = goals.reduce(function (sum, g) {
        return sum + (parseFloat(g.currentAmount || g.current_amount) || 0);
      }, 0);
      var totalTarget = goals.reduce(function (sum, g) {
        return sum + (parseFloat(g.targetAmount || g.target_amount) || 0);
      }, 0);
      document.getElementById('goals-total-count').textContent = activeGoals.length;
      document.getElementById('goals-total-saved').textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(totalSaved, null, this.settings);
      document.getElementById('goals-total-target').textContent = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(totalTarget, null, this.settings);
      document.getElementById('goals-completed-count').textContent = completedGoals.length;
    }
  }, {
    key: "renderGoals",
    value: function renderGoals(goals) {
      var _this = this;
      var goalsList = document.getElementById('goals-list');
      var emptyGoals = document.getElementById('empty-goals');
      if (!goals || goals.length === 0) {
        goalsList.innerHTML = '';
        emptyGoals.style.display = 'block';
        return;
      }
      emptyGoals.style.display = 'none';
      goalsList.innerHTML = goals.map(function (goal) {
        var current = parseFloat(goal.currentAmount || goal.current_amount) || 0;
        var target = parseFloat(goal.targetAmount || goal.target_amount) || 0;
        var percentage = target > 0 ? Math.min(current / target * 100, 100) : 0;
        var isCompleted = current >= target;
        var color = goal.color || '#0082c9';
        var targetDate = goal.targetDate || goal.target_date;
        var targetDateText = '';
        if (targetDate) {
          var date = new Date(targetDate);
          var today = new Date();
          var daysLeft = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
          if (daysLeft < 0) {
            targetDateText = "Target date passed";
          } else if (daysLeft === 0) {
            targetDateText = 'Target date: Today';
          } else if (daysLeft <= 30) {
            targetDateText = "".concat(daysLeft, " days left");
          } else {
            targetDateText = "Target: ".concat(date.toLocaleDateString('en-US', {
              month: 'short',
              day: 'numeric',
              year: 'numeric'
            }));
          }
        }
        return "\n                <div class=\"goal-card ".concat(isCompleted ? 'completed' : '', "\" data-goal-id=\"").concat(goal.id, "\">\n                    <div class=\"goal-card-header\">\n                        <div class=\"goal-card-title\">\n                            <span class=\"goal-color-indicator\" style=\"background: ").concat(color, "\"></span>\n                            <h3 class=\"goal-name\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(goal.name), "</h3>\n                        </div>\n                        <div class=\"goal-card-actions\">\n                            <button class=\"edit-goal-btn\" title=\"Edit\" data-goal-id=\"").concat(goal.id, "\">\n                                <span class=\"icon-rename\"></span>\n                            </button>\n                            <button class=\"delete-goal-btn delete-btn\" title=\"Delete\" data-goal-id=\"").concat(goal.id, "\">\n                                <span class=\"icon-delete\"></span>\n                            </button>\n                        </div>\n                    </div>\n\n                    <div class=\"goal-progress-section\">\n                        <div class=\"goal-progress-bar\">\n                            <div class=\"goal-progress-fill\" style=\"width: ").concat(percentage, "%; background: ").concat(isCompleted ? 'linear-gradient(90deg, #2e7d32, #43a047)' : "linear-gradient(90deg, ".concat(color, ", ").concat(color, "dd)"), "\"></div>\n                        </div>\n                        <div class=\"goal-amounts\">\n                            <span class=\"goal-current-amount\">").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(current, null, _this.settings), "</span>\n                            <span class=\"goal-percentage\">").concat(percentage.toFixed(0), "%</span>\n                            <span class=\"goal-target-amount\">of ").concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(target, null, _this.settings), "</span>\n                        </div>\n                    </div>\n\n                    <div class=\"goal-footer\">\n                        ").concat(targetDateText ? "<span class=\"goal-target-date\"><span class=\"icon-calendar\"></span> ".concat(targetDateText, "</span>") : '<span></span>', "\n                        ").concat(isCompleted ? '<span class="goal-completed-badge"><span class="icon-checkmark"></span> Goal reached!</span>' : "<button class=\"goal-add-money-btn\" data-goal-id=\"".concat(goal.id, "\">+ Add money</button>"), "\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "setupGoalsEventListeners",
    value: function setupGoalsEventListeners() {
      var _document$getElementB,
        _this2 = this,
        _document$getElementB2,
        _document$getElementB3,
        _document$getElementB4,
        _document$getElementB5,
        _document$getElementB6;
      // Add goal button
      (_document$getElementB = document.getElementById('add-goal-btn')) === null || _document$getElementB === void 0 || _document$getElementB.addEventListener('click', function () {
        _this2.showGoalModal();
      });

      // Empty state add button
      (_document$getElementB2 = document.getElementById('empty-goals-add-btn')) === null || _document$getElementB2 === void 0 || _document$getElementB2.addEventListener('click', function () {
        _this2.showGoalModal();
      });

      // Goal form submission
      (_document$getElementB3 = document.getElementById('goal-form')) === null || _document$getElementB3 === void 0 || _document$getElementB3.addEventListener('submit', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(e) {
          return _regenerator().w(function (_context2) {
            while (1) switch (_context2.n) {
              case 0:
                e.preventDefault();
                _context2.n = 1;
                return _this2.saveGoal();
              case 1:
                return _context2.a(2);
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      // Add money form
      (_document$getElementB4 = document.getElementById('add-to-goal-form')) === null || _document$getElementB4 === void 0 || _document$getElementB4.addEventListener('submit', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(e) {
          return _regenerator().w(function (_context3) {
            while (1) switch (_context3.n) {
              case 0:
                e.preventDefault();
                _context3.n = 1;
                return _this2.addMoneyToGoal();
              case 1:
                return _context3.a(2);
            }
          }, _callee3);
        }));
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());

      // Event delegation for goal cards
      (_document$getElementB5 = document.getElementById('goals-list')) === null || _document$getElementB5 === void 0 || _document$getElementB5.addEventListener('click', function (e) {
        var editBtn = e.target.closest('.edit-goal-btn');
        var deleteBtn = e.target.closest('.delete-goal-btn');
        var addMoneyBtn = e.target.closest('.goal-add-money-btn');
        if (editBtn) {
          var goalId = parseInt(editBtn.dataset.goalId);
          _this2.editGoal(goalId);
        } else if (deleteBtn) {
          var _goalId = parseInt(deleteBtn.dataset.goalId);
          _this2.deleteGoal(_goalId);
        } else if (addMoneyBtn) {
          var _goalId2 = parseInt(addMoneyBtn.dataset.goalId);
          _this2.showAddMoneyModal(_goalId2);
        }
      });

      // Color preview
      (_document$getElementB6 = document.getElementById('goal-color')) === null || _document$getElementB6 === void 0 || _document$getElementB6.addEventListener('input', function (e) {
        var preview = document.getElementById('goal-color-preview');
        if (preview) {
          preview.style.backgroundColor = e.target.value;
        }
      });
    }
  }, {
    key: "populateGoalAccountDropdown",
    value: function populateGoalAccountDropdown() {
      var dropdown = document.getElementById('goal-account');
      if (!dropdown) return;
      dropdown.innerHTML = '<option value="">No linked account</option>' + (Array.isArray(this.accounts) ? this.accounts.map(function (a) {
        return "<option value=\"".concat(a.id, "\">").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(a.name), "</option>");
      }).join('') : '');
    }
  }, {
    key: "showGoalModal",
    value: function showGoalModal() {
      var goal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('goal-modal');
      var title = document.getElementById('goal-modal-title');
      var form = document.getElementById('goal-form');
      if (!modal || !form) return;
      title.textContent = goal ? 'Edit Savings Goal' : 'Add Savings Goal';

      // Reset form
      form.reset();
      document.getElementById('goal-id').value = '';
      document.getElementById('goal-color').value = '#0082c9';

      // Populate if editing
      if (goal) {
        document.getElementById('goal-id').value = goal.id;
        document.getElementById('goal-name').value = goal.name;
        document.getElementById('goal-target').value = goal.targetAmount || goal.target_amount || '';
        document.getElementById('goal-current').value = goal.currentAmount || goal.current_amount || 0;
        document.getElementById('goal-target-date').value = goal.targetDate || goal.target_date || '';
        document.getElementById('goal-notes').value = goal.description || '';
      }
      modal.style.display = 'flex';
    }
  }, {
    key: "saveGoal",
    value: function () {
      var _saveGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var form, goalId, targetDateValue, descriptionValue, data, url, response, _t2;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              form = document.getElementById('goal-form');
              goalId = document.getElementById('goal-id').value;
              targetDateValue = document.getElementById('goal-target-date').value;
              descriptionValue = document.getElementById('goal-notes').value;
              data = {
                name: document.getElementById('goal-name').value,
                targetAmount: parseFloat(document.getElementById('goal-target').value) || 0,
                currentAmount: parseFloat(document.getElementById('goal-current').value) || 0,
                targetDate: targetDateValue || null,
                description: descriptionValue || null
              };
              _context4.p = 1;
              url = goalId ? OC.generateUrl("/apps/budget/api/savings-goals/".concat(goalId)) : OC.generateUrl('/apps/budget/api/savings-goals');
              _context4.n = 2;
              return fetch(url, {
                method: goalId ? 'PUT' : 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(data)
              });
            case 2:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              document.getElementById('goal-modal').style.display = 'none';
              OC.Notification.showTemporary(goalId ? 'Goal updated' : 'Goal created');
              _context4.n = 4;
              return this.loadSavingsGoalsView();
            case 4:
              _context4.n = 6;
              break;
            case 5:
              _context4.p = 5;
              _t2 = _context4.v;
              console.error('Failed to save goal:', _t2);
              OC.Notification.showTemporary('Failed to save goal');
            case 6:
              return _context4.a(2);
          }
        }, _callee4, this, [[1, 5]]);
      }));
      function saveGoal() {
        return _saveGoal.apply(this, arguments);
      }
      return saveGoal;
    }()
  }, {
    key: "editGoal",
    value: function editGoal(goalId) {
      var _this$savingsGoals;
      var goal = (_this$savingsGoals = this.savingsGoals) === null || _this$savingsGoals === void 0 ? void 0 : _this$savingsGoals.find(function (g) {
        return g.id === goalId;
      });
      if (goal) {
        this.showGoalModal(goal);
      }
    }
  }, {
    key: "deleteGoal",
    value: function () {
      var _deleteGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(goalId) {
        var response, _t3;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              if (confirm('Are you sure you want to delete this savings goal?')) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              _context5.p = 1;
              _context5.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/savings-goals/".concat(goalId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 3:
              OC.Notification.showTemporary('Goal deleted');
              _context5.n = 4;
              return this.loadSavingsGoalsView();
            case 4:
              _context5.n = 6;
              break;
            case 5:
              _context5.p = 5;
              _t3 = _context5.v;
              console.error('Failed to delete goal:', _t3);
              OC.Notification.showTemporary('Failed to delete goal');
            case 6:
              return _context5.a(2);
          }
        }, _callee5, this, [[1, 5]]);
      }));
      function deleteGoal(_x3) {
        return _deleteGoal.apply(this, arguments);
      }
      return deleteGoal;
    }()
  }, {
    key: "showAddMoneyModal",
    value: function showAddMoneyModal(goalId) {
      var _this$savingsGoals2;
      var goal = (_this$savingsGoals2 = this.savingsGoals) === null || _this$savingsGoals2 === void 0 ? void 0 : _this$savingsGoals2.find(function (g) {
        return g.id === goalId;
      });
      if (!goal) return;
      var modal = document.getElementById('add-to-goal-modal');
      document.getElementById('add-to-goal-name').textContent = goal.name;
      document.getElementById('add-to-goal-id').value = goalId;
      document.getElementById('add-amount').value = '';
      modal.style.display = 'flex';
    }
  }, {
    key: "addMoneyToGoal",
    value: function () {
      var _addMoneyToGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var _this$savingsGoals3;
        var goalId, amount, goal, currentAmount, newAmount, response, _t4;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              goalId = document.getElementById('add-to-goal-id').value;
              amount = parseFloat(document.getElementById('add-amount').value) || 0;
              if (!(amount <= 0)) {
                _context6.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please enter a valid amount');
              return _context6.a(2);
            case 1:
              goal = (_this$savingsGoals3 = this.savingsGoals) === null || _this$savingsGoals3 === void 0 ? void 0 : _this$savingsGoals3.find(function (g) {
                return g.id === parseInt(goalId);
              });
              if (goal) {
                _context6.n = 2;
                break;
              }
              return _context6.a(2);
            case 2:
              currentAmount = parseFloat(goal.currentAmount || goal.current_amount) || 0;
              newAmount = currentAmount + amount;
              _context6.p = 3;
              _context6.n = 4;
              return fetch(OC.generateUrl("/apps/budget/api/savings-goals/".concat(goalId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  currentAmount: newAmount
                })
              });
            case 4:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 5;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 5:
              document.getElementById('add-to-goal-modal').style.display = 'none';
              OC.Notification.showTemporary("Added ".concat(_utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, null, this.settings), " to goal"));
              _context6.n = 6;
              return this.loadSavingsGoalsView();
            case 6:
              _context6.n = 8;
              break;
            case 7:
              _context6.p = 7;
              _t4 = _context6.v;
              console.error('Failed to add money to goal:', _t4);
              OC.Notification.showTemporary('Failed to add money to goal');
            case 8:
              return _context6.a(2);
          }
        }, _callee6, this, [[3, 7]]);
      }));
      function addMoneyToGoal() {
        return _addMoneyToGoal.apply(this, arguments);
      }
      return addMoneyToGoal;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/settings/SettingsModule.js":
/*!************************************************!*\
  !*** ./src/modules/settings/SettingsModule.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SettingsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Settings Module - User preferences and configuration
 */


var SettingsModule = /*#__PURE__*/function () {
  function SettingsModule(app) {
    _classCallCheck(this, SettingsModule);
    this.app = app;
  }

  // Getters for app state
  return _createClass(SettingsModule, [{
    key: "settings",
    get: function get() {
      return this.app.settings;
    },
    set: function set(value) {
      this.app.settings = value;
    }
  }, {
    key: "loadSettingsView",
    value: function () {
      var _loadSettingsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, settings, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context.v;
              if (response.ok) {
                _context.n = 2;
                break;
              }
              throw new Error('Failed to load settings');
            case 2:
              _context.n = 3;
              return response.json();
            case 3:
              settings = _context.v;
              _context.n = 4;
              return this.populateSettings(settings);
            case 4:
              this.updateNumberFormatPreview();
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              console.error('Error loading settings:', _t);
              OC.Notification.showTemporary('Failed to load settings');
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[0, 5]]);
      }));
      function loadSettingsView() {
        return _loadSettingsView.apply(this, arguments);
      }
      return loadSettingsView;
    }()
  }, {
    key: "populateSettings",
    value: function () {
      var _populateSettings = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(settings) {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              // Populate each setting input
              Object.keys(settings).forEach(function (key) {
                var element = document.getElementById("setting-".concat(key.replace(/_/g, '-')));
                if (!element) return;
                var value = settings[key];
                if (element.type === 'checkbox') {
                  element.checked = value === 'true' || value === true;
                } else {
                  element.value = value;
                }
              });

              // Check password protection status and update UI
              _context2.n = 1;
              return this.updatePasswordProtectionUI();
            case 1:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
      function populateSettings(_x) {
        return _populateSettings.apply(this, arguments);
      }
      return populateSettings;
    }()
  }, {
    key: "updatePasswordProtectionUI",
    value: function () {
      var _updatePasswordProtectionUI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var response, status, passwordToggle, passwordConfig, _t2;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/auth/status'), {
                headers: this.app.getAuthHeaders()
              });
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 2;
                break;
              }
              return _context3.a(2);
            case 2:
              _context3.n = 3;
              return response.json();
            case 3:
              status = _context3.v;
              passwordToggle = document.getElementById('setting-password-protection-enabled');
              passwordConfig = document.getElementById('password-protection-config');
              if (passwordToggle) {
                passwordToggle.checked = status.enabled;
                if (status.enabled && passwordConfig) {
                  passwordConfig.style.display = 'block';
                  this.updatePasswordButtons(status.hasPassword);
                } else if (passwordConfig) {
                  passwordConfig.style.display = 'none';
                }
              }
              _context3.n = 5;
              break;
            case 4:
              _context3.p = 4;
              _t2 = _context3.v;
              console.error('Failed to check password protection status:', _t2);
            case 5:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 4]]);
      }));
      function updatePasswordProtectionUI() {
        return _updatePasswordProtectionUI.apply(this, arguments);
      }
      return updatePasswordProtectionUI;
    }()
  }, {
    key: "updatePasswordButtons",
    value: function updatePasswordButtons(hasPassword) {
      var setupBtn = document.getElementById('setup-password-btn');
      var changeBtn = document.getElementById('change-password-btn');
      var disableBtn = document.getElementById('disable-password-btn');
      if (setupBtn) setupBtn.style.display = hasPassword ? 'none' : 'inline-block';
      if (changeBtn) changeBtn.style.display = hasPassword ? 'inline-block' : 'none';
      if (disableBtn) disableBtn.style.display = hasPassword ? 'inline-block' : 'none';
    }
  }, {
    key: "saveSettings",
    value: function () {
      var _saveSettings = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var settings, response, result, _t3;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              settings = this.gatherSettings();
              _context4.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
              });
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              throw new Error('Failed to save settings');
            case 2:
              _context4.n = 3;
              return response.json();
            case 3:
              result = _context4.v;
              OC.Notification.showTemporary('Settings saved successfully');

              // Update stored settings to apply immediately
              Object.assign(this.settings, settings);

              // Apply theme if changed
              if (settings.theme_preference && this.app.applyTheme) {
                this.app.applyTheme(settings.theme_preference);
              }

              // Update account form currency default if needed
              this.updateAccountFormDefaults(settings);

              // Reload current view to apply setting changes (e.g., date format)
              if (this.app.reloadCurrentView) {
                this.app.reloadCurrentView();
              }
              _context4.n = 5;
              break;
            case 4:
              _context4.p = 4;
              _t3 = _context4.v;
              console.error('Error saving settings:', _t3);
              OC.Notification.showTemporary('Failed to save settings');
            case 5:
              return _context4.a(2);
          }
        }, _callee4, this, [[0, 4]]);
      }));
      function saveSettings() {
        return _saveSettings.apply(this, arguments);
      }
      return saveSettings;
    }()
  }, {
    key: "gatherSettings",
    value: function gatherSettings() {
      var settingElements = document.querySelectorAll('.setting-input');
      var settings = {};
      settingElements.forEach(function (element) {
        var key = element.id.replace('setting-', '').replace(/-/g, '_');
        if (element.type === 'checkbox') {
          settings[key] = element.checked ? 'true' : 'false';
        } else {
          settings[key] = element.value;
        }
      });
      return settings;
    }
  }, {
    key: "resetSettings",
    value: function () {
      var _resetSettings = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var response, result, _t4;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              if (confirm('Are you sure you want to reset all settings to defaults? This action cannot be undone.')) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2);
            case 1:
              _context5.p = 1;
              _context5.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/settings/reset'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 3;
                break;
              }
              throw new Error('Failed to reset settings');
            case 3:
              _context5.n = 4;
              return response.json();
            case 4:
              result = _context5.v;
              _context5.n = 5;
              return this.populateSettings(result.defaults);
            case 5:
              this.updateNumberFormatPreview();
              OC.Notification.showTemporary('Settings reset to defaults');
              _context5.n = 7;
              break;
            case 6:
              _context5.p = 6;
              _t4 = _context5.v;
              console.error('Error resetting settings:', _t4);
              OC.Notification.showTemporary('Failed to reset settings');
            case 7:
              return _context5.a(2);
          }
        }, _callee5, this, [[1, 6]]);
      }));
      function resetSettings() {
        return _resetSettings.apply(this, arguments);
      }
      return resetSettings;
    }()
  }, {
    key: "updateNumberFormatPreview",
    value: function updateNumberFormatPreview() {
      var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4, _document$getElementB5;
      var decimals = parseInt(((_document$getElementB = document.getElementById('setting-number-format-decimals')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || '2');
      var decimalSep = ((_document$getElementB2 = document.getElementById('setting-number-format-decimal-sep')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value) || '.';
      var thousandsSep = (_document$getElementB3 = (_document$getElementB4 = document.getElementById('setting-number-format-thousands-sep')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value) !== null && _document$getElementB3 !== void 0 ? _document$getElementB3 : ',';
      var defaultCurrency = ((_document$getElementB5 = document.getElementById('setting-default-currency')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value) || 'USD';

      // Get currency symbol
      var currencySymbols = {
        'USD': '$',
        'EUR': '',
        'GBP': '',
        'CAD': 'C$',
        'AUD': 'A$',
        'JPY': '',
        'CHF': 'CHF',
        'CNY': '',
        'INR': '',
        'MXN': '$'
      };
      var symbol = currencySymbols[defaultCurrency] || '$';

      // Format number 1234.56
      var testNumber = 1234.56;
      var parts = testNumber.toFixed(decimals).split('.');
      var integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSep);
      var decimalPart = decimals > 0 ? decimalSep + parts[1] : '';
      var formatted = symbol + integerPart + decimalPart;
      var previewElement = document.getElementById('number-format-preview');
      if (previewElement) {
        previewElement.textContent = formatted;
      }
    }
  }, {
    key: "updateAccountFormDefaults",
    value: function updateAccountFormDefaults(settings) {
      // Update default currency in account form when it opens
      if (settings.default_currency) {
        var accountCurrencySelect = document.getElementById('account-currency');
        if (accountCurrencySelect && !accountCurrencySelect.value) {
          accountCurrencySelect.value = settings.default_currency;
        }
      }
    }

    // Password Protection UI methods
  }, {
    key: "showSetupPasswordModal",
    value: function showSetupPasswordModal() {
      var _this = this;
      var modal = document.createElement('div');
      modal.id = 'setup-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Set Up Password Protection</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <p>Enter a password to protect your budget app. You will need to enter this password when accessing the app.</p>\n                    <form id=\"setup-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"new-password\">New Password</label>\n                            <input type=\"password\" id=\"new-password\" class=\"budget-input\" required minlength=\"6\" autocomplete=\"new-password\">\n                            <small>Minimum 6 characters</small>\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"confirm-password\">Confirm Password</label>\n                            <input type=\"password\" id=\"confirm-password\" class=\"budget-input\" required autocomplete=\"new-password\">\n                        </div>\n                        <div id=\"setup-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Set Password</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('setup-password-form');
      var newPasswordInput = document.getElementById('new-password');
      var confirmPasswordInput = document.getElementById('confirm-password');
      var errorDiv = document.getElementById('setup-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(e) {
          var newPassword, confirmPassword, response, result, _t5;
          return _regenerator().w(function (_context6) {
            while (1) switch (_context6.p = _context6.n) {
              case 0:
                e.preventDefault();
                newPassword = newPasswordInput.value;
                confirmPassword = confirmPasswordInput.value;
                if (!(newPassword !== confirmPassword)) {
                  _context6.n = 1;
                  break;
                }
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.style.display = 'block';
                return _context6.a(2);
              case 1:
                _context6.p = 1;
                _context6.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/setup'), {
                  method: 'POST',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this.app.getAuthHeaders()),
                  body: JSON.stringify({
                    password: newPassword
                  })
                });
              case 2:
                response = _context6.v;
                _context6.n = 3;
                return response.json();
              case 3:
                result = _context6.v;
                if (response.ok && result.success) {
                  // Store session token
                  _this.app.sessionToken = result.sessionToken;
                  localStorage.setItem('budget_session_token', result.sessionToken);
                  OC.Notification.showTemporary('Password protection enabled');
                  modal.remove();

                  // Update UI
                  _this.updatePasswordButtons(true);
                } else {
                  errorDiv.textContent = result.error || 'Failed to set password';
                  errorDiv.style.display = 'block';
                }
                _context6.n = 5;
                break;
              case 4:
                _context6.p = 4;
                _t5 = _context6.v;
                console.error('Failed to set password:', _t5);
                errorDiv.textContent = 'Failed to set password. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context6.a(2);
            }
          }, _callee6, null, [[1, 4]]);
        }));
        return function (_x2) {
          return _ref.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      newPasswordInput.focus();
    }
  }, {
    key: "showChangePasswordModal",
    value: function showChangePasswordModal() {
      var _this2 = this;
      var modal = document.createElement('div');
      modal.id = 'change-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Change Password</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <form id=\"change-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"current-password\">Current Password</label>\n                            <input type=\"password\" id=\"current-password\" class=\"budget-input\" required autocomplete=\"current-password\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"new-password-change\">New Password</label>\n                            <input type=\"password\" id=\"new-password-change\" class=\"budget-input\" required minlength=\"6\" autocomplete=\"new-password\">\n                            <small>Minimum 6 characters</small>\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"confirm-password-change\">Confirm New Password</label>\n                            <input type=\"password\" id=\"confirm-password-change\" class=\"budget-input\" required autocomplete=\"new-password\">\n                        </div>\n                        <div id=\"change-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Change Password</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('change-password-form');
      var currentPasswordInput = document.getElementById('current-password');
      var newPasswordInput = document.getElementById('new-password-change');
      var confirmPasswordInput = document.getElementById('confirm-password-change');
      var errorDiv = document.getElementById('change-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(e) {
          var currentPassword, newPassword, confirmPassword, response, result, _t6;
          return _regenerator().w(function (_context7) {
            while (1) switch (_context7.p = _context7.n) {
              case 0:
                e.preventDefault();
                currentPassword = currentPasswordInput.value;
                newPassword = newPasswordInput.value;
                confirmPassword = confirmPasswordInput.value;
                if (!(newPassword !== confirmPassword)) {
                  _context7.n = 1;
                  break;
                }
                errorDiv.textContent = 'New passwords do not match';
                errorDiv.style.display = 'block';
                return _context7.a(2);
              case 1:
                _context7.p = 1;
                _context7.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/password'), {
                  method: 'PUT',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this2.app.getAuthHeaders()),
                  body: JSON.stringify({
                    currentPassword: currentPassword,
                    newPassword: newPassword
                  })
                });
              case 2:
                response = _context7.v;
                _context7.n = 3;
                return response.json();
              case 3:
                result = _context7.v;
                if (response.ok && result.success) {
                  OC.Notification.showTemporary('Password changed successfully');
                  modal.remove();
                } else {
                  errorDiv.textContent = result.error || 'Failed to change password';
                  errorDiv.style.display = 'block';
                }
                _context7.n = 5;
                break;
              case 4:
                _context7.p = 4;
                _t6 = _context7.v;
                console.error('Failed to change password:', _t6);
                errorDiv.textContent = 'Failed to change password. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context7.a(2);
            }
          }, _callee7, null, [[1, 4]]);
        }));
        return function (_x3) {
          return _ref2.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      currentPasswordInput.focus();
    }
  }, {
    key: "showDisablePasswordModal",
    value: function showDisablePasswordModal() {
      var _this3 = this;
      var modal = document.createElement('div');
      modal.id = 'disable-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Disable Password Protection</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <p>Enter your current password to disable password protection.</p>\n                    <form id=\"disable-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"disable-current-password\">Current Password</label>\n                            <input type=\"password\" id=\"disable-current-password\" class=\"budget-input\" required autocomplete=\"current-password\">\n                        </div>\n                        <div id=\"disable-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Disable Protection</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('disable-password-form');
      var passwordInput = document.getElementById('disable-current-password');
      var errorDiv = document.getElementById('disable-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(e) {
          var password, response, result, passwordToggle, passwordConfig, _t7;
          return _regenerator().w(function (_context8) {
            while (1) switch (_context8.p = _context8.n) {
              case 0:
                e.preventDefault();
                password = passwordInput.value;
                _context8.p = 1;
                _context8.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/disable'), {
                  method: 'DELETE',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this3.app.getAuthHeaders()),
                  body: JSON.stringify({
                    password: password
                  })
                });
              case 2:
                response = _context8.v;
                _context8.n = 3;
                return response.json();
              case 3:
                result = _context8.v;
                if (response.ok && result.success) {
                  // Update UI
                  passwordToggle = document.getElementById('setting-password-protection-enabled');
                  if (passwordToggle) passwordToggle.checked = false;
                  passwordConfig = document.getElementById('password-protection-config');
                  if (passwordConfig) passwordConfig.style.display = 'none';
                  OC.Notification.showTemporary('Password protection disabled');
                  modal.remove();
                } else {
                  errorDiv.textContent = result.error || 'Failed to disable password protection';
                  errorDiv.style.display = 'block';
                }
                _context8.n = 5;
                break;
              case 4:
                _context8.p = 4;
                _t7 = _context8.v;
                console.error('Failed to disable password protection:', _t7);
                errorDiv.textContent = 'Failed to disable password protection. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context8.a(2);
            }
          }, _callee8, null, [[1, 4]]);
        }));
        return function (_x4) {
          return _ref3.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      passwordInput.focus();
    }

    // Factory Reset methods
  }, {
    key: "setupFactoryResetEventListeners",
    value: function setupFactoryResetEventListeners() {
      var _this4 = this;
      var factoryResetBtn = document.getElementById('factory-reset-btn');
      var factoryResetModal = document.getElementById('factory-reset-modal');
      var factoryResetInput = document.getElementById('factory-reset-confirm-input');
      var factoryResetConfirmBtn = document.getElementById('factory-reset-confirm-btn');
      var modalCloseButtons = factoryResetModal ? factoryResetModal.querySelectorAll('.close-btn') : [];

      // Open modal
      if (factoryResetBtn) {
        factoryResetBtn.addEventListener('click', function () {
          _this4.openFactoryResetModal();
        });
      }

      // Enable/disable confirm button based on input value
      if (factoryResetInput && factoryResetConfirmBtn) {
        factoryResetInput.addEventListener('input', function (e) {
          // User must type exactly "DELETE" (case-sensitive)
          factoryResetConfirmBtn.disabled = e.target.value !== 'DELETE';
        });
      }

      // Confirm button
      if (factoryResetConfirmBtn) {
        factoryResetConfirmBtn.addEventListener('click', function () {
          _this4.executeFactoryReset();
        });
      }

      // Close modal buttons
      modalCloseButtons.forEach(function (btn) {
        btn.addEventListener('click', function () {
          _this4.closeFactoryResetModal();
        });
      });

      // Close modal on background click
      if (factoryResetModal) {
        factoryResetModal.addEventListener('click', function (e) {
          if (e.target === factoryResetModal) {
            _this4.closeFactoryResetModal();
          }
        });
      }
    }
  }, {
    key: "openFactoryResetModal",
    value: function openFactoryResetModal() {
      var modal = document.getElementById('factory-reset-modal');
      var input = document.getElementById('factory-reset-confirm-input');
      var confirmBtn = document.getElementById('factory-reset-confirm-btn');
      if (modal) {
        // Reset input and button state
        if (input) {
          input.value = '';
          input.focus(); // Auto-focus the input field
        }
        if (confirmBtn) confirmBtn.disabled = true;
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
      }
    }
  }, {
    key: "closeFactoryResetModal",
    value: function closeFactoryResetModal() {
      var modal = document.getElementById('factory-reset-modal');
      if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
      }
    }
  }, {
    key: "executeFactoryReset",
    value: function () {
      var _executeFactoryReset = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
        var confirmBtn, response, data, _confirmBtn, _t8;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              // Show loading state
              confirmBtn = document.getElementById('factory-reset-confirm-btn');
              if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.innerHTML = '<span class="icon-loading-small" aria-hidden="true"></span> Deleting...';
              }
              _context9.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/setup/factory-reset'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  confirmed: true
                })
              });
            case 1:
              response = _context9.v;
              _context9.n = 2;
              return response.json();
            case 2:
              data = _context9.v;
              if (response.ok) {
                _context9.n = 3;
                break;
              }
              throw new Error(data.error || 'Factory reset failed');
            case 3:
              // Close modal
              this.closeFactoryResetModal();

              // Show success message
              OC.Notification.showTemporary('Factory reset completed successfully. All data has been deleted.');

              // Reload the page to show empty state
              setTimeout(function () {
                window.location.reload();
              }, 1500);
              _context9.n = 5;
              break;
            case 4:
              _context9.p = 4;
              _t8 = _context9.v;
              console.error('Factory reset error:', _t8);

              // Reset button state
              _confirmBtn = document.getElementById('factory-reset-confirm-btn');
              if (_confirmBtn) {
                _confirmBtn.disabled = false;
                _confirmBtn.innerHTML = '<span class="icon-delete" aria-hidden="true"></span> Delete Everything';
              }
              OC.Notification.showTemporary(_t8.message || 'Failed to perform factory reset');
            case 5:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 4]]);
      }));
      function executeFactoryReset() {
        return _executeFactoryReset.apply(this, arguments);
      }
      return executeFactoryReset;
    }()
  }]);
}();


/***/ }),

/***/ "./src/modules/shared-expenses/SharedExpensesModule.js":
/*!*************************************************************!*\
  !*** ./src/modules/shared-expenses/SharedExpensesModule.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SharedExpensesModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Shared Expenses Module - Split expenses and settlements tracking
 */


var SharedExpensesModule = /*#__PURE__*/function () {
  function SharedExpensesModule(app) {
    _classCallCheck(this, SharedExpensesModule);
    this.app = app;
    this._sharedEventsSetup = false;
  }

  // Getters for app state
  return _createClass(SharedExpensesModule, [{
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "contacts",
    get: function get() {
      return this.app.contacts;
    },
    set: function set(value) {
      this.app.contacts = value;
    }
  }, {
    key: "splitContacts",
    get: function get() {
      return this.app.splitContacts;
    },
    set: function set(value) {
      this.app.splitContacts = value;
    }
  }, {
    key: "currentContactDetails",
    get: function get() {
      return this.app.currentContactDetails;
    },
    set: function set(value) {
      this.app.currentContactDetails = value;
    }
  }, {
    key: "loadSharedExpensesView",
    value: function () {
      var _loadSharedExpensesView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.loadBalanceSummary();
            case 1:
              _context.n = 2;
              return this.loadContacts();
            case 2:
              // Setup event listeners (only once)
              if (!this._sharedEventsSetup) {
                this.setupSharedExpenseEventListeners();
                this._sharedEventsSetup = true;
              }
            case 3:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function loadSharedExpensesView() {
        return _loadSharedExpensesView.apply(this, arguments);
      }
      return loadSharedExpensesView;
    }()
  }, {
    key: "loadBalanceSummary",
    value: function () {
      var _loadBalanceSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response, data, netBalance, netEl, _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/shared/balances'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 2;
                break;
              }
              throw new Error('Failed to load balances');
            case 2:
              _context2.n = 3;
              return response.json();
            case 3:
              data = _context2.v;
              document.getElementById('split-total-owed').textContent = this.formatCurrency(data.totalOwed);
              document.getElementById('split-total-owing').textContent = this.formatCurrency(data.totalOwing);
              netBalance = data.netBalance;
              netEl = document.getElementById('split-net-balance');
              netEl.textContent = this.formatCurrency(Math.abs(netBalance));
              netEl.className = 'summary-value ' + (netBalance >= 0 ? 'positive' : 'negative');
              if (netBalance > 0) {
                netEl.textContent = '+' + netEl.textContent;
              } else if (netBalance < 0) {
                netEl.textContent = '-' + this.formatCurrency(Math.abs(netBalance));
              }
              this.splitContacts = data.contacts;
              this.renderContactsList(data.contacts);
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t = _context2.v;
              console.error('Failed to load balances:', _t);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 4]]);
      }));
      function loadBalanceSummary() {
        return _loadBalanceSummary.apply(this, arguments);
      }
      return loadBalanceSummary;
    }()
  }, {
    key: "loadContacts",
    value: function () {
      var _loadContacts = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var response, _t2;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/shared/contacts'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 2;
                break;
              }
              throw new Error('Failed to load contacts');
            case 2:
              _context3.n = 3;
              return response.json();
            case 3:
              this.contacts = _context3.v;
              _context3.n = 5;
              break;
            case 4:
              _context3.p = 4;
              _t2 = _context3.v;
              console.error('Failed to load contacts:', _t2);
              this.contacts = [];
            case 5:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 4]]);
      }));
      function loadContacts() {
        return _loadContacts.apply(this, arguments);
      }
      return loadContacts;
    }()
  }, {
    key: "renderContactsList",
    value: function renderContactsList(contacts) {
      var _this = this;
      var container = document.getElementById('contacts-list');
      if (!container) return;
      if (!contacts || contacts.length === 0) {
        container.innerHTML = "\n                <div class=\"empty-state\">\n                    <div class=\"empty-icon\">\n                        <svg width=\"48\" height=\"48\" viewBox=\"0 0 24 24\" fill=\"currentColor\" opacity=\"0.3\">\n                            <path d=\"M16,13C15.71,13 15.38,13 15.03,13.05C16.19,13.89 17,15 17,16.5V19H23V16.5C23,14.17 18.33,13 16,13M8,13C5.67,13 1,14.17 1,16.5V19H15V16.5C15,14.17 10.33,13 8,13M8,11A3,3 0 0,0 11,8A3,3 0 0,0 8,5A3,3 0 0,0 5,8A3,3 0 0,0 8,11M16,11A3,3 0 0,0 19,8A3,3 0 0,0 16,5A3,3 0 0,0 13,8A3,3 0 0,0 16,11Z\"/>\n                        </svg>\n                    </div>\n                    <p>Add contacts to start splitting expenses</p>\n                </div>\n            ";
        return;
      }
      container.innerHTML = contacts.map(function (item) {
        var balance = item.balance;
        var balanceClass = balance > 0 ? 'owed' : balance < 0 ? 'owing' : 'settled';
        var balanceText = balance === 0 ? 'Settled' : balance > 0 ? "Owes you ".concat(_this.formatCurrency(balance)) : "You owe ".concat(_this.formatCurrency(Math.abs(balance)));
        return "\n                <div class=\"contact-card\" data-contact-id=\"".concat(item.contact.id, "\">\n                    <div class=\"contact-card-main\">\n                        <div class=\"contact-avatar\">\n                            ").concat(item.contact.name.charAt(0).toUpperCase(), "\n                        </div>\n                        <div class=\"contact-info\">\n                            <span class=\"contact-name\">").concat(_this.escapeHtml(item.contact.name), "</span>\n                            ").concat(item.contact.email ? "<span class=\"contact-email\">".concat(_this.escapeHtml(item.contact.email), "</span>") : '', "\n                        </div>\n                        <div class=\"contact-balance ").concat(balanceClass, "\">\n                            ").concat(balanceText, "\n                        </div>\n                    </div>\n                    <div class=\"contact-actions\">\n                        <button class=\"action-btn view-contact-btn\" data-id=\"").concat(item.contact.id, "\" title=\"View details\">\n                            <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                                <path d=\"M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z\"/>\n                            </svg>\n                        </button>\n                        <button class=\"action-btn edit-contact-btn\" data-id=\"").concat(item.contact.id, "\" title=\"Edit\">\n                            <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                                <path d=\"M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z\"/>\n                            </svg>\n                        </button>\n                        <button class=\"action-btn delete-contact-btn\" data-id=\"").concat(item.contact.id, "\" title=\"Delete\">\n                            <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                                <path d=\"M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z\"/>\n                            </svg>\n                        </button>\n                    </div>\n                </div>\n            ");
      }).join('');

      // Add click handlers
      container.querySelectorAll('.view-contact-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          _this.showContactDetails(parseInt(btn.dataset.id));
        });
      });
      container.querySelectorAll('.edit-contact-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          _this.editContact(parseInt(btn.dataset.id));
        });
      });
      container.querySelectorAll('.delete-contact-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.stopPropagation();
          _this.deleteContact(parseInt(btn.dataset.id));
        });
      });
      container.querySelectorAll('.contact-card').forEach(function (card) {
        card.addEventListener('click', function () {
          _this.showContactDetails(parseInt(card.dataset.contactId));
        });
      });
    }
  }, {
    key: "setupSharedExpenseEventListeners",
    value: function setupSharedExpenseEventListeners() {
      var _this2 = this;
      // Add contact button
      var addContactBtn = document.getElementById('add-contact-btn');
      if (addContactBtn) {
        addContactBtn.addEventListener('click', function () {
          return _this2.showContactModal();
        });
      }

      // Contact form submission
      var contactForm = document.getElementById('contact-form');
      if (contactForm) {
        contactForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveContact();
        });
      }

      // Share expense form
      var shareForm = document.getElementById('share-expense-form');
      if (shareForm) {
        shareForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveShareExpense();
        });
      }

      // Split type change
      var splitType = document.getElementById('share-split-type');
      if (splitType) {
        splitType.addEventListener('change', function () {
          var customGroup = document.getElementById('share-custom-amount-group');
          if (customGroup) {
            customGroup.style.display = splitType.value === 'custom' ? 'block' : 'none';
          }
        });
      }

      // Settlement form
      var settlementForm = document.getElementById('settlement-form');
      if (settlementForm) {
        settlementForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this2.saveSettlement();
        });
      }

      // Modal close buttons
      ['contact-modal', 'share-expense-modal', 'settlement-modal', 'contact-details-modal'].forEach(function (modalId) {
        var modal = document.getElementById(modalId);
        if (modal) {
          modal.querySelectorAll('.cancel-btn, .close-btn').forEach(function (btn) {
            btn.addEventListener('click', function () {
              return _this2.closeModal(modal);
            });
          });
        }
      });
    }
  }, {
    key: "showContactModal",
    value: function showContactModal() {
      var contact = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var modal = document.getElementById('contact-modal');
      var title = document.getElementById('contact-modal-title');
      var form = document.getElementById('contact-form');
      form.reset();
      document.getElementById('contact-id').value = contact ? contact.id : '';
      title.textContent = contact ? 'Edit Contact' : 'Add Contact';
      if (contact) {
        document.getElementById('contact-name').value = contact.name || '';
        document.getElementById('contact-email').value = contact.email || '';
      }
      modal.style.display = 'flex';
    }
  }, {
    key: "saveContact",
    value: function () {
      var _saveContact = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var id, name, email, url, response, _t3;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              id = document.getElementById('contact-id').value;
              name = document.getElementById('contact-name').value.trim();
              email = document.getElementById('contact-email').value.trim();
              if (name) {
                _context4.n = 1;
                break;
              }
              OC.Notification.showTemporary('Name is required');
              return _context4.a(2);
            case 1:
              _context4.p = 1;
              url = id ? OC.generateUrl("/apps/budget/api/shared/contacts/".concat(id)) : OC.generateUrl('/apps/budget/api/shared/contacts');
              _context4.n = 2;
              return fetch(url, {
                method: id ? 'PUT' : 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: name,
                  email: email || null
                })
              });
            case 2:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 3;
                break;
              }
              throw new Error('Failed to save contact');
            case 3:
              this.closeModal(document.getElementById('contact-modal'));
              OC.Notification.showTemporary(id ? 'Contact updated' : 'Contact added');
              _context4.n = 4;
              return this.loadBalanceSummary();
            case 4:
              _context4.n = 5;
              return this.loadContacts();
            case 5:
              _context4.n = 7;
              break;
            case 6:
              _context4.p = 6;
              _t3 = _context4.v;
              console.error('Failed to save contact:', _t3);
              OC.Notification.showTemporary('Failed to save contact');
            case 7:
              return _context4.a(2);
          }
        }, _callee4, this, [[1, 6]]);
      }));
      function saveContact() {
        return _saveContact.apply(this, arguments);
      }
      return saveContact;
    }()
  }, {
    key: "editContact",
    value: function () {
      var _editContact = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(id) {
        var _this$contacts;
        var contact;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              contact = (_this$contacts = this.contacts) === null || _this$contacts === void 0 ? void 0 : _this$contacts.find(function (c) {
                return c.id === id;
              });
              if (contact) {
                this.showContactModal(contact);
              }
            case 1:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
      function editContact(_x) {
        return _editContact.apply(this, arguments);
      }
      return editContact;
    }()
  }, {
    key: "deleteContact",
    value: function () {
      var _deleteContact = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(id) {
        var response, _t4;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              if (confirm('Are you sure you want to delete this contact? This will also remove all shared expense records with them.')) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              _context6.p = 1;
              _context6.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/shared/contacts/".concat(id)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context6.v;
              if (response.ok) {
                _context6.n = 3;
                break;
              }
              throw new Error('Failed to delete contact');
            case 3:
              OC.Notification.showTemporary('Contact deleted');
              _context6.n = 4;
              return this.loadBalanceSummary();
            case 4:
              _context6.n = 5;
              return this.loadContacts();
            case 5:
              _context6.n = 7;
              break;
            case 6:
              _context6.p = 6;
              _t4 = _context6.v;
              console.error('Failed to delete contact:', _t4);
              OC.Notification.showTemporary('Failed to delete contact');
            case 7:
              return _context6.a(2);
          }
        }, _callee6, this, [[1, 6]]);
      }));
      function deleteContact(_x2) {
        return _deleteContact.apply(this, arguments);
      }
      return deleteContact;
    }()
  }, {
    key: "showContactDetails",
    value: function () {
      var _showContactDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(contactId) {
        var _this3 = this;
        var response, data, balanceEl, balance, settleAllBtn, recordSettlementBtn, tabs, _t5;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              _context7.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/shared/contacts/".concat(contactId, "/details")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context7.v;
              if (response.ok) {
                _context7.n = 2;
                break;
              }
              throw new Error('Failed to load contact details');
            case 2:
              _context7.n = 3;
              return response.json();
            case 3:
              data = _context7.v;
              this.currentContactDetails = data;

              // Populate modal
              document.getElementById('contact-details-name').textContent = data.contact.name;
              document.getElementById('contact-details-email').textContent = data.contact.email || '';
              balanceEl = document.getElementById('contact-details-balance');
              balance = data.balance;
              balanceEl.textContent = balance === 0 ? 'Settled' : balance > 0 ? "Owes you ".concat(this.formatCurrency(balance)) : "You owe ".concat(this.formatCurrency(Math.abs(balance)));
              balanceEl.className = 'balance-value ' + (balance > 0 ? 'owed' : balance < 0 ? 'owing' : 'settled');

              // Render shares
              this.renderContactShares(data.shares);
              this.renderContactSettlements(data.settlements);

              // Setup actions
              settleAllBtn = document.getElementById('settle-all-btn');
              if (settleAllBtn) {
                settleAllBtn.onclick = function () {
                  return _this3.settleAllWithContact(contactId);
                };
              }
              recordSettlementBtn = document.getElementById('record-settlement-btn');
              if (recordSettlementBtn) {
                recordSettlementBtn.onclick = function () {
                  return _this3.showSettlementModal(contactId, data.contact.name, balance);
                };
              }

              // Tab switching
              tabs = document.querySelectorAll('#contact-details-modal .tab-button');
              tabs.forEach(function (tab) {
                tab.addEventListener('click', function () {
                  tabs.forEach(function (t) {
                    return t.classList.remove('active');
                  });
                  tab.classList.add('active');
                  document.getElementById('contact-shares-tab').style.display = tab.dataset.tab === 'shares' ? 'block' : 'none';
                  document.getElementById('contact-settlements-tab').style.display = tab.dataset.tab === 'settlements' ? 'block' : 'none';
                });
              });
              document.getElementById('contact-details-modal').style.display = 'flex';
              _context7.n = 5;
              break;
            case 4:
              _context7.p = 4;
              _t5 = _context7.v;
              console.error('Failed to load contact details:', _t5);
              OC.Notification.showTemporary('Failed to load contact details');
            case 5:
              return _context7.a(2);
          }
        }, _callee7, this, [[0, 4]]);
      }));
      function showContactDetails(_x3) {
        return _showContactDetails.apply(this, arguments);
      }
      return showContactDetails;
    }()
  }, {
    key: "renderContactShares",
    value: function renderContactShares(shares) {
      var _this4 = this;
      var container = document.getElementById('contact-shares-list');
      if (!shares || shares.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No shared expenses</div>';
        return;
      }
      container.innerHTML = shares.map(function (item) {
        var share = item.share;
        var txn = item.transaction;
        var statusClass = share.isSettled ? 'settled' : share.amount > 0 ? 'owed' : 'owing';
        return "\n                <div class=\"share-item ".concat(statusClass, "\">\n                    <div class=\"share-date\">").concat(txn.date, "</div>\n                    <div class=\"share-desc\">").concat(_this4.escapeHtml(txn.description), "</div>\n                    <div class=\"share-amount ").concat(share.amount >= 0 ? 'positive' : 'negative', "\">\n                        ").concat(share.amount >= 0 ? '+' : '').concat(_this4.formatCurrency(share.amount), "\n                    </div>\n                    <div class=\"share-status\">").concat(share.isSettled ? 'Settled' : 'Open', "</div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "renderContactSettlements",
    value: function renderContactSettlements(settlements) {
      var _this5 = this;
      var container = document.getElementById('contact-settlements-list');
      if (!settlements || settlements.length === 0) {
        container.innerHTML = '<div class="empty-state-small">No settlements yet</div>';
        return;
      }
      container.innerHTML = settlements.map(function (settlement) {
        return "\n            <div class=\"settlement-item\">\n                <div class=\"settlement-date\">".concat(settlement.date, "</div>\n                <div class=\"settlement-amount ").concat(settlement.amount >= 0 ? 'received' : 'paid', "\">\n                    ").concat(settlement.amount >= 0 ? 'Received' : 'Paid', " ").concat(_this5.formatCurrency(Math.abs(settlement.amount)), "\n                </div>\n                ").concat(settlement.notes ? "<div class=\"settlement-notes\">".concat(_this5.escapeHtml(settlement.notes), "</div>") : '', "\n            </div>\n        ");
      }).join('');
    }
  }, {
    key: "showSettlementModal",
    value: function showSettlementModal(contactId, contactName, balance) {
      var _this6 = this;
      this.closeModal(document.getElementById('contact-details-modal'));
      var modal = document.getElementById('settlement-modal');
      document.getElementById('settlement-contact-id').value = contactId;
      document.getElementById('settlement-contact-name').textContent = contactName;
      document.getElementById('settlement-balance').textContent = balance === 0 ? 'Settled' : balance > 0 ? "Owes you ".concat(this.formatCurrency(balance)) : "You owe ".concat(this.formatCurrency(Math.abs(balance)));
      document.getElementById('settlement-amount').value = Math.abs(balance).toFixed(2);
      document.getElementById('settlement-date').value = new Date().toISOString().split('T')[0];
      document.getElementById('settlement-notes').value = '';

      // Ensure form submit handler is attached
      var form = document.getElementById('settlement-form');
      if (form && !form.dataset.listenerAttached) {
        form.addEventListener('submit', function (e) {
          e.preventDefault();
          _this6.saveSettlement();
        });
        form.dataset.listenerAttached = 'true';
      }
      modal.style.display = 'flex';
    }
  }, {
    key: "saveSettlement",
    value: function () {
      var _saveSettlement = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var contactId, amount, date, notes, response, _t6;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              contactId = parseInt(document.getElementById('settlement-contact-id').value);
              amount = parseFloat(document.getElementById('settlement-amount').value);
              date = document.getElementById('settlement-date').value;
              notes = document.getElementById('settlement-notes').value.trim();
              if (!(!amount || !date)) {
                _context8.n = 1;
                break;
              }
              OC.Notification.showTemporary('Amount and date are required');
              return _context8.a(2);
            case 1:
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/shared/settlements'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  contactId: contactId,
                  amount: amount,
                  date: date,
                  notes: notes || null
                })
              });
            case 2:
              response = _context8.v;
              if (response.ok) {
                _context8.n = 3;
                break;
              }
              throw new Error('Failed to record settlement');
            case 3:
              this.closeModal(document.getElementById('settlement-modal'));
              OC.Notification.showTemporary('Settlement recorded');
              _context8.n = 4;
              return this.loadBalanceSummary();
            case 4:
              _context8.n = 6;
              break;
            case 5:
              _context8.p = 5;
              _t6 = _context8.v;
              console.error('Failed to record settlement:', _t6);
              OC.Notification.showTemporary('Failed to record settlement');
            case 6:
              return _context8.a(2);
          }
        }, _callee8, this, [[1, 5]]);
      }));
      function saveSettlement() {
        return _saveSettlement.apply(this, arguments);
      }
      return saveSettlement;
    }()
  }, {
    key: "settleAllWithContact",
    value: function () {
      var _settleAllWithContact = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(contactId) {
        var date, response, _t7;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              if (confirm('This will mark all shared expenses with this contact as settled. Continue?')) {
                _context9.n = 1;
                break;
              }
              return _context9.a(2);
            case 1:
              _context9.p = 1;
              date = new Date().toISOString().split('T')[0];
              _context9.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/shared/contacts/".concat(contactId, "/settle")), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  date: date
                })
              });
            case 2:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 3;
                break;
              }
              throw new Error('Failed to settle');
            case 3:
              this.closeModal(document.getElementById('contact-details-modal'));
              OC.Notification.showTemporary('All expenses settled');
              _context9.n = 4;
              return this.loadBalanceSummary();
            case 4:
              _context9.n = 6;
              break;
            case 5:
              _context9.p = 5;
              _t7 = _context9.v;
              console.error('Failed to settle:', _t7);
              OC.Notification.showTemporary('Failed to settle expenses');
            case 6:
              return _context9.a(2);
          }
        }, _callee9, this, [[1, 5]]);
      }));
      function settleAllWithContact(_x4) {
        return _settleAllWithContact.apply(this, arguments);
      }
      return settleAllWithContact;
    }()
  }, {
    key: "showShareExpenseModal",
    value: function () {
      var _showShareExpenseModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(transaction) {
        var _this7 = this;
        var modal, contactSelect;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              modal = document.getElementById('share-expense-modal'); // Load contacts if not already loaded
              if (!(!this.contacts || this.contacts.length === 0)) {
                _context0.n = 1;
                break;
              }
              _context0.n = 1;
              return this.loadContacts();
            case 1:
              if (!(!this.contacts || this.contacts.length === 0)) {
                _context0.n = 2;
                break;
              }
              OC.Notification.showTemporary('Please add contacts first in Shared Expenses');
              return _context0.a(2);
            case 2:
              document.getElementById('share-transaction-id').value = transaction.id;
              document.getElementById('share-transaction-date').textContent = transaction.date;
              document.getElementById('share-transaction-desc').textContent = transaction.description;
              document.getElementById('share-transaction-amount').textContent = this.formatCurrency(Math.abs(transaction.amount));

              // Populate contacts dropdown
              contactSelect = document.getElementById('share-contact');
              contactSelect.innerHTML = '<option value="">Select a contact...</option>' + (this.contacts || []).map(function (c) {
                return "<option value=\"".concat(c.id, "\">").concat(_this7.escapeHtml(c.name), "</option>");
              }).join('');
              document.getElementById('share-split-type').value = '50-50';
              document.getElementById('share-custom-amount-group').style.display = 'none';
              document.getElementById('share-amount').value = '';
              document.getElementById('share-notes').value = '';
              modal.style.display = 'flex';
            case 3:
              return _context0.a(2);
          }
        }, _callee0, this);
      }));
      function showShareExpenseModal(_x5) {
        return _showShareExpenseModal.apply(this, arguments);
      }
      return showShareExpenseModal;
    }()
  }, {
    key: "saveShareExpense",
    value: function () {
      var _saveShareExpense = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
        var transactionId, contactId, splitType, notes, url, body, amount, response, _t8;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              transactionId = parseInt(document.getElementById('share-transaction-id').value);
              contactId = parseInt(document.getElementById('share-contact').value);
              splitType = document.getElementById('share-split-type').value;
              notes = document.getElementById('share-notes').value.trim();
              if (contactId) {
                _context1.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select a contact');
              return _context1.a(2);
            case 1:
              _context1.p = 1;
              if (!(splitType === '50-50')) {
                _context1.n = 2;
                break;
              }
              url = OC.generateUrl('/apps/budget/api/shared/shares/split');
              body = {
                transactionId: transactionId,
                contactId: contactId,
                notes: notes || null
              };
              _context1.n = 4;
              break;
            case 2:
              amount = parseFloat(document.getElementById('share-amount').value);
              if (amount) {
                _context1.n = 3;
                break;
              }
              OC.Notification.showTemporary('Amount is required for custom splits');
              return _context1.a(2);
            case 3:
              url = OC.generateUrl('/apps/budget/api/shared/shares');
              body = {
                transactionId: transactionId,
                contactId: contactId,
                amount: amount,
                notes: notes || null
              };
            case 4:
              _context1.n = 5;
              return fetch(url, {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
              });
            case 5:
              response = _context1.v;
              if (response.ok) {
                _context1.n = 6;
                break;
              }
              throw new Error('Failed to share expense');
            case 6:
              this.closeModal(document.getElementById('share-expense-modal'));
              OC.Notification.showTemporary('Expense shared');
              _context1.n = 7;
              return this.loadBalanceSummary();
            case 7:
              _context1.n = 9;
              break;
            case 8:
              _context1.p = 8;
              _t8 = _context1.v;
              console.error('Failed to share expense:', _t8);
              OC.Notification.showTemporary('Failed to share expense');
            case 9:
              return _context1.a(2);
          }
        }, _callee1, this, [[1, 8]]);
      }));
      function saveShareExpense() {
        return _saveShareExpense.apply(this, arguments);
      }
      return saveShareExpense;
    }() // Delegate helper methods to app
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "closeModal",
    value: function closeModal(modal) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.closeModal(modal);
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/tagsets/TagSetsModule.js":
/*!**********************************************!*\
  !*** ./src/modules/tagsets/TagSetsModule.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TagSetsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Tag Sets Module - Category tag management and transaction tagging
 */


var TagSetsModule = /*#__PURE__*/function () {
  function TagSetsModule(app) {
    _classCallCheck(this, TagSetsModule);
    this.app = app;
  }

  // Getters for app state
  return _createClass(TagSetsModule, [{
    key: "tagSets",
    get: function get() {
      return this.app.tagSets;
    },
    set: function set(value) {
      this.app.tagSets = value;
    }
  }, {
    key: "selectedCategoryTagSets",
    get: function get() {
      return this.app.selectedCategoryTagSets;
    },
    set: function set(value) {
      this.app.selectedCategoryTagSets = value;
    }
  }, {
    key: "transactionTags",
    get: function get() {
      return this.app.transactionTags;
    },
    set: function set(value) {
      this.app.transactionTags = value;
    }
  }, {
    key: "allTagSetsForReports",
    get: function get() {
      return this.app.allTagSetsForReports;
    },
    set: function set(value) {
      this.app.allTagSetsForReports = value;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "transactions",
    get: function get() {
      return this.app.transactions;
    }

    /**
     * Load tag sets for a specific category
     */
  }, {
    key: "loadTagSetsForCategory",
    value: (function () {
      var _loadTagSetsForCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(categoryId) {
        var response, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/tag-sets?categoryId=".concat(categoryId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context.v;
              if (!response.ok) {
                _context.n = 3;
                break;
              }
              _context.n = 2;
              return response.json();
            case 2:
              this.selectedCategoryTagSets = _context.v;
              return _context.a(2, this.selectedCategoryTagSets);
            case 3:
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
              console.error('Failed to load tag sets:', _t);
            case 5:
              return _context.a(2, []);
          }
        }, _callee, this, [[0, 4]]);
      }));
      function loadTagSetsForCategory(_x) {
        return _loadTagSetsForCategory.apply(this, arguments);
      }
      return loadTagSetsForCategory;
    }()
    /**
     * Load tags for a transaction
     */
    )
  }, {
    key: "loadTransactionTags",
    value: (function () {
      var _loadTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(transactionId) {
        var response, tags, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/tags")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context2.v;
              if (!response.ok) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return response.json();
            case 2:
              tags = _context2.v;
              this.transactionTags[transactionId] = tags;
              return _context2.a(2, tags);
            case 3:
              _context2.n = 5;
              break;
            case 4:
              _context2.p = 4;
              _t2 = _context2.v;
              console.error('Failed to load transaction tags:', _t2);
            case 5:
              return _context2.a(2, []);
          }
        }, _callee2, this, [[0, 4]]);
      }));
      function loadTransactionTags(_x2) {
        return _loadTransactionTags.apply(this, arguments);
      }
      return loadTransactionTags;
    }()
    /**
     * Save tags for a transaction
     */
    )
  }, {
    key: "saveTransactionTags",
    value: (function () {
      var _saveTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(transactionId, tagIds) {
        var response, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/tags")), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  tagIds: tagIds
                })
              });
            case 1:
              response = _context3.v;
              if (!response.ok) {
                _context3.n = 3;
                break;
              }
              _context3.n = 2;
              return this.loadTransactionTags(transactionId);
            case 2:
              return _context3.a(2, true);
            case 3:
              _context3.n = 5;
              break;
            case 4:
              _context3.p = 4;
              _t3 = _context3.v;
              console.error('Failed to save transaction tags:', _t3);
            case 5:
              return _context3.a(2, false);
          }
        }, _callee3, this, [[0, 4]]);
      }));
      function saveTransactionTags(_x3, _x4) {
        return _saveTransactionTags.apply(this, arguments);
      }
      return saveTransactionTags;
    }()
    /**
     * Render tag chips for display in transaction list
     */
    )
  }, {
    key: "renderTagChips",
    value: function renderTagChips(tags) {
      var _this = this;
      if (!tags || tags.length === 0) {
        return '';
      }
      return tags.map(function (tag) {
        return "\n            <span class=\"tag-chip\" style=\"background-color: ".concat(tag.color || '#666', "; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-right: 4px;\">\n                ").concat(_this.escapeHtml(tag.name), "\n            </span>\n        ");
      }).join('');
    }

    /**
     * Render tag set management UI in category modal
     */
  }, {
    key: "renderCategoryTagSetsUI",
    value: (function () {
      var _renderCategoryTagSetsUI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(categoryId) {
        var container, tagSets, html;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              container = document.getElementById('category-tag-sets-container');
              if (container) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (categoryId) {
                _context4.n = 2;
                break;
              }
              container.innerHTML = '<p style="color: #999; font-style: italic;">Save category first to manage tag sets</p>';
              return _context4.a(2);
            case 2:
              _context4.n = 3;
              return this.loadTagSetsForCategory(categoryId);
            case 3:
              tagSets = _context4.v;
              html = "\n            <div class=\"tag-sets-header\">\n                <h4 style=\"margin: 0;\">Tag Sets</h4>\n                <button type=\"button\" class=\"add-tag-set-btn\" data-category-id=\"".concat(categoryId, "\">\n                    <span class=\"icon-add\" aria-hidden=\"true\"></span> Add Tag Set\n                </button>\n            </div>\n        ");
              if (tagSets.length === 0) {
                html += '<p style="color: #999; font-style: italic;">No tag sets yet. Add your first tag set to enable multi-dimensional categorization.</p>';
              }

              // Render each tag set
              if (tagSets.length > 0) {
                tagSets.forEach(function (tagSet) {
                  html += "\n                    <div class=\"tag-set-card\">\n                        <div class=\"tag-set-header\">\n                            <h5>".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tagSet.name), "</h5>\n                            <div class=\"tag-set-actions\">\n                                <button type=\"button\" class=\"add-tag-btn\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Add tag\">\n                                    <span class=\"icon-add\" aria-hidden=\"true\"></span>\n                                </button>\n                                <button type=\"button\" class=\"delete-tag-set-btn\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Delete tag set\">\n                                    <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                                </button>\n                            </div>\n                        </div>\n                        ").concat(tagSet.description ? "<p class=\"tag-set-description\">".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tagSet.description), "</p>") : '', "\n                        <div class=\"tags-list\">\n                            ").concat(tagSet.tags && tagSet.tags.length > 0 ? tagSet.tags.map(function (tag) {
                    return "\n                                <span class=\"tag-badge\" style=\"background-color: ".concat(tag.color || '#666', "\">\n                                    ").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tag.name), "\n                                    <button type=\"button\" class=\"delete-tag-btn\" data-tag-id=\"").concat(tag.id, "\" data-tag-set-id=\"").concat(tagSet.id, "\">\xD7</button>\n                                </span>\n                            ");
                  }).join('') : '<span style="color: #999; font-size: 12px;">No tags yet</span>', "\n                        </div>\n                    </div>\n                ");
                });
              }
              container.innerHTML = html;

              // Setup event listeners
              this.setupCategoryTagSetsModalListeners(categoryId);
            case 4:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
      function renderCategoryTagSetsUI(_x5) {
        return _renderCategoryTagSetsUI.apply(this, arguments);
      }
      return renderCategoryTagSetsUI;
    }()
    /**
     * Setup event listeners for tag set management in category modal
     */
    )
  }, {
    key: "setupCategoryTagSetsModalListeners",
    value: function setupCategoryTagSetsModalListeners(categoryId) {
      var _this2 = this;
      // Add tag set button
      document.querySelectorAll('.add-tag-set-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
          var name, description, _t4;
          return _regenerator().w(function (_context5) {
            while (1) switch (_context5.p = _context5.n) {
              case 0:
                name = prompt('Enter tag set name (e.g., "Priority", "Status"):');
                if (name) {
                  _context5.n = 1;
                  break;
                }
                return _context5.a(2);
              case 1:
                description = prompt('Enter description (optional):');
                _context5.p = 2;
                _context5.n = 3;
                return _this2.createTagSet(categoryId, name, description);
              case 3:
                _context5.n = 4;
                return _this2.renderCategoryTagSetsUI(categoryId);
              case 4:
                OC.Notification.showTemporary('Tag set created successfully');
                _context5.n = 6;
                break;
              case 5:
                _context5.p = 5;
                _t4 = _context5.v;
                console.error('Failed to create tag set:', _t4);
                OC.Notification.showTemporary('Failed to create tag set');
              case 6:
                return _context5.a(2);
            }
          }, _callee5, null, [[2, 5]]);
        })));
      });

      // Delete tag set buttons
      document.querySelectorAll('.delete-tag-set-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
          var tagSetId, _t5;
          return _regenerator().w(function (_context6) {
            while (1) switch (_context6.p = _context6.n) {
              case 0:
                tagSetId = parseInt(btn.dataset.tagSetId);
                if (confirm('Delete this tag set? All associated tags will be removed from transactions.')) {
                  _context6.n = 1;
                  break;
                }
                return _context6.a(2);
              case 1:
                _context6.p = 1;
                _context6.n = 2;
                return _this2.deleteTagSet(tagSetId);
              case 2:
                _context6.n = 3;
                return _this2.renderCategoryTagSetsUI(categoryId);
              case 3:
                OC.Notification.showTemporary('Tag set deleted');
                _context6.n = 5;
                break;
              case 4:
                _context6.p = 4;
                _t5 = _context6.v;
                console.error('Failed to delete tag set:', _t5);
                OC.Notification.showTemporary('Failed to delete tag set');
              case 5:
                return _context6.a(2);
            }
          }, _callee6, null, [[1, 4]]);
        })));
      });

      // Add tag buttons
      document.querySelectorAll('.add-tag-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
          var tagSetId, name, color, _t6;
          return _regenerator().w(function (_context7) {
            while (1) switch (_context7.p = _context7.n) {
              case 0:
                tagSetId = parseInt(btn.dataset.tagSetId);
                name = prompt('Enter tag name:');
                if (name) {
                  _context7.n = 1;
                  break;
                }
                return _context7.a(2);
              case 1:
                color = prompt('Enter color (e.g., #FF5733):') || '#666666';
                _context7.p = 2;
                _context7.n = 3;
                return _this2.createTag(tagSetId, name, color);
              case 3:
                _context7.n = 4;
                return _this2.renderCategoryTagSetsUI(categoryId);
              case 4:
                OC.Notification.showTemporary('Tag created successfully');
                _context7.n = 6;
                break;
              case 5:
                _context7.p = 5;
                _t6 = _context7.v;
                console.error('Failed to create tag:', _t6);
                OC.Notification.showTemporary('Failed to create tag');
              case 6:
                return _context7.a(2);
            }
          }, _callee7, null, [[2, 5]]);
        })));
      });

      // Delete tag buttons
      document.querySelectorAll('.delete-tag-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
          var tagId, tagSetId, _t7;
          return _regenerator().w(function (_context8) {
            while (1) switch (_context8.p = _context8.n) {
              case 0:
                tagId = parseInt(btn.dataset.tagId);
                tagSetId = parseInt(btn.dataset.tagSetId);
                if (confirm('Delete this tag? It will be removed from all transactions.')) {
                  _context8.n = 1;
                  break;
                }
                return _context8.a(2);
              case 1:
                _context8.p = 1;
                _context8.n = 2;
                return _this2.deleteTag(tagId, tagSetId);
              case 2:
                _context8.n = 3;
                return _this2.renderCategoryTagSetsUI(categoryId);
              case 3:
                OC.Notification.showTemporary('Tag deleted');
                _context8.n = 5;
                break;
              case 4:
                _context8.p = 4;
                _t7 = _context8.v;
                console.error('Failed to delete tag:', _t7);
                OC.Notification.showTemporary('Failed to delete tag');
              case 5:
                return _context8.a(2);
            }
          }, _callee8, null, [[1, 4]]);
        })));
      });
    }

    /**
     * Create a new tag set
     */
  }, {
    key: "createTagSet",
    value: (function () {
      var _createTagSet = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(categoryId, name, description) {
        var response;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              _context9.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/tag-sets'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  categoryId: categoryId,
                  name: name,
                  description: description || null
                })
              });
            case 1:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 2;
                break;
              }
              throw new Error('Failed to create tag set');
            case 2:
              _context9.n = 3;
              return response.json();
            case 3:
              return _context9.a(2, _context9.v);
          }
        }, _callee9);
      }));
      function createTagSet(_x6, _x7, _x8) {
        return _createTagSet.apply(this, arguments);
      }
      return createTagSet;
    }()
    /**
     * Delete a tag set
     */
    )
  }, {
    key: "deleteTagSet",
    value: (function () {
      var _deleteTagSet = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(tagSetId) {
        var response;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              _context0.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/tag-sets/".concat(tagSetId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context0.v;
              if (response.ok) {
                _context0.n = 2;
                break;
              }
              throw new Error('Failed to delete tag set');
            case 2:
              return _context0.a(2, true);
          }
        }, _callee0);
      }));
      function deleteTagSet(_x9) {
        return _deleteTagSet.apply(this, arguments);
      }
      return deleteTagSet;
    }()
    /**
     * Create a new tag
     */
    )
  }, {
    key: "createTag",
    value: (function () {
      var _createTag = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(tagSetId, name, color) {
        var response;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              _context1.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/tag-sets/".concat(tagSetId, "/tags")), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  name: name,
                  color: color || '#666666'
                })
              });
            case 1:
              response = _context1.v;
              if (response.ok) {
                _context1.n = 2;
                break;
              }
              throw new Error('Failed to create tag');
            case 2:
              _context1.n = 3;
              return response.json();
            case 3:
              return _context1.a(2, _context1.v);
          }
        }, _callee1);
      }));
      function createTag(_x0, _x1, _x10) {
        return _createTag.apply(this, arguments);
      }
      return createTag;
    }()
    /**
     * Delete a tag
     */
    )
  }, {
    key: "deleteTag",
    value: (function () {
      var _deleteTag = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(tagId, tagSetId) {
        var response;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              _context10.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/tag-sets/".concat(tagSetId, "/tags/").concat(tagId)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context10.v;
              if (response.ok) {
                _context10.n = 2;
                break;
              }
              throw new Error('Failed to delete tag');
            case 2:
              return _context10.a(2, true);
          }
        }, _callee10);
      }));
      function deleteTag(_x11, _x12) {
        return _deleteTag.apply(this, arguments);
      }
      return deleteTag;
    }()
    /**
     * Render transaction tag selectors
     */
    )
  }, {
    key: "renderTransactionTagSelectors",
    value: (function () {
      var _renderTransactionTagSelectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(categoryId, transactionId) {
        var _this3 = this;
        var container, tagSets, currentTags, currentTagIds, html;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              container = document.getElementById('transaction-tags-container');
              if (container) {
                _context12.n = 1;
                break;
              }
              return _context12.a(2);
            case 1:
              if (categoryId) {
                _context12.n = 2;
                break;
              }
              container.innerHTML = '<p style="color: #999; font-size: 12px;">No tag sets available for this category</p>';
              return _context12.a(2);
            case 2:
              _context12.n = 3;
              return this.loadTagSetsForCategory(categoryId);
            case 3:
              tagSets = _context12.v;
              if (!(tagSets.length === 0)) {
                _context12.n = 4;
                break;
              }
              container.innerHTML = '<p style="color: #999; font-size: 12px;">No tag sets available for this category</p>';
              return _context12.a(2);
            case 4:
              _context12.n = 5;
              return this.loadTransactionTags(transactionId);
            case 5:
              currentTags = _context12.v;
              currentTagIds = currentTags.map(function (t) {
                return t.id;
              });
              html = '';
              tagSets.forEach(function (tagSet) {
                html += "\n                <div class=\"tag-set-selector\">\n                    <label class=\"tag-set-label\">".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tagSet.name), "</label>\n                    <div class=\"tag-options\">\n                        ").concat(tagSet.tags && tagSet.tags.length > 0 ? tagSet.tags.map(function (tag) {
                  return "\n                            <label class=\"tag-option\">\n                                <input type=\"checkbox\"\n                                       value=\"".concat(tag.id, "\"\n                                       data-transaction-id=\"").concat(transactionId, "\"\n                                       ").concat(currentTagIds.includes(tag.id) ? 'checked' : '', ">\n                                <span class=\"tag-badge\" style=\"background-color: ").concat(tag.color || '#666', "\">\n                                    ").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tag.name), "\n                                </span>\n                            </label>\n                        ");
                }).join('') : '<span style="color: #999; font-size: 11px;">No tags defined</span>', "\n                    </div>\n                </div>\n            ");
              });
              container.innerHTML = html;

              // Add change listeners to save tags
              container.querySelectorAll('input[type="checkbox"]').forEach(function (checkbox) {
                checkbox.addEventListener('change', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
                  var selectedTags;
                  return _regenerator().w(function (_context11) {
                    while (1) switch (_context11.n) {
                      case 0:
                        selectedTags = Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(function (cb) {
                          return parseInt(cb.value);
                        });
                        _context11.n = 1;
                        return _this3.saveTransactionTags(transactionId, selectedTags);
                      case 1:
                        return _context11.a(2);
                    }
                  }, _callee11);
                })));
              });
            case 6:
              return _context12.a(2);
          }
        }, _callee12, this);
      }));
      function renderTransactionTagSelectors(_x13, _x14) {
        return _renderTransactionTagSelectors.apply(this, arguments);
      }
      return renderTransactionTagSelectors;
    }()
    /**
     * Load and display transaction tags in the transaction modal
     */
    )
  }, {
    key: "loadAndDisplayTransactionTags",
    value: (function () {
      var _loadAndDisplayTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
        var transactionId, categoryId;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              transactionId = document.getElementById('transaction-id').value;
              categoryId = document.getElementById('transaction-category').value;
              if (!(transactionId && categoryId)) {
                _context13.n = 1;
                break;
              }
              _context13.n = 1;
              return this.renderTransactionTagSelectors(parseInt(categoryId), parseInt(transactionId));
            case 1:
              return _context13.a(2);
          }
        }, _callee13, this);
      }));
      function loadAndDisplayTransactionTags() {
        return _loadAndDisplayTransactionTags.apply(this, arguments);
      }
      return loadAndDisplayTransactionTags;
    }()
    /**
     * Render tag sets in the category details view
     */
    )
  }, {
    key: "renderCategoryTagSetsList",
    value: (function () {
      var _renderCategoryTagSetsList = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(categoryId) {
        var container, tagSets, table, tbody, _t8;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              container = document.getElementById('category-tag-sets-list');
              if (container) {
                _context14.n = 1;
                break;
              }
              return _context14.a(2);
            case 1:
              _context14.p = 1;
              if (categoryId) {
                _context14.n = 2;
                break;
              }
              container.innerHTML = '<div class="empty-state"><p>Select a category to manage tag sets</p></div>';
              return _context14.a(2);
            case 2:
              _context14.n = 3;
              return this.loadTagSetsForCategory(categoryId);
            case 3:
              tagSets = _context14.v;
              // Clear the container first to avoid duplicates
              container.innerHTML = '';
              if (tagSets.length === 0) {
                container.innerHTML = '<div class="empty-state"><p style="font-size: 13px; color: var(--color-text-maxcontrast); margin: 8px 0;">No tag sets yet.</p></div>';
              } else {
                // Create table for list layout
                table = document.createElement('table');
                table.className = 'tag-sets-list-table';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                tbody = document.createElement('tbody');
                tagSets.forEach(function (tagSet) {
                  var row = document.createElement('tr');
                  row.className = 'tag-set-row';
                  row.style.borderBottom = '1px solid var(--color-border)';
                  row.innerHTML = "\n                        <td class=\"tag-set-name-cell\" style=\"padding: 12px 8px; vertical-align: top; width: 25%;\">\n                            <div class=\"tag-set-name\" style=\"font-weight: 600; margin-bottom: 4px;\">\n                                ".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tagSet.name), "\n                            </div>\n                            ").concat(tagSet.description ? "\n                                <div class=\"tag-set-description\" style=\"font-size: 12px; color: var(--color-text-maxcontrast);\">\n                                    ".concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tagSet.description), "\n                                </div>\n                            ") : '', "\n                        </td>\n                        <td class=\"tag-set-tags-cell\" style=\"padding: 12px 8px; vertical-align: top;\">\n                            <div class=\"tags-container\" style=\"display: flex; flex-wrap: wrap; gap: 6px;\">\n                                ").concat(tagSet.tags && tagSet.tags.length > 0 ? tagSet.tags.map(function (tag) {
                    return "\n                                    <span class=\"tag-badge\" style=\"background-color: ".concat(tag.color || '#666', "; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; display: inline-flex; align-items: center; gap: 4px;\">\n                                        ").concat(_utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(tag.name), "\n                                        <button class=\"delete-tag-btn\" data-tag-id=\"").concat(tag.id, "\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Delete tag\" style=\"background: none; border: none; color: white; cursor: pointer; padding: 0; margin-left: 2px; font-size: 16px; line-height: 1; opacity: 0.7;\">\xD7</button>\n                                    </span>\n                                ");
                  }).join('') : '<span class="no-tags-text" style="color: var(--color-text-maxcontrast); font-size: 12px; font-style: italic;">No tags yet</span>', "\n                            </div>\n                        </td>\n                        <td class=\"tag-set-actions-cell\" style=\"padding: 12px 8px; vertical-align: top; width: 120px; text-align: right;\">\n                            <div class=\"tag-set-actions\" style=\"display: flex; gap: 4px; justify-content: flex-end;\">\n                                <button class=\"action-btn add-tag-btn\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Add Tag\" style=\"padding: 6px 8px;\">\n                                    <span class=\"icon-add\" aria-hidden=\"true\"></span>\n                                </button>\n                                <button class=\"action-btn edit-tag-set-btn\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Edit Tag Set\" style=\"padding: 6px 8px;\">\n                                    <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                                </button>\n                                <button class=\"action-btn delete-tag-set-btn\" data-tag-set-id=\"").concat(tagSet.id, "\" title=\"Delete Tag Set\" style=\"padding: 6px 8px;\">\n                                    <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                                </button>\n                            </div>\n                        </td>\n                    ");
                  tbody.appendChild(row);
                });
                table.appendChild(tbody);
                container.appendChild(table);
              }

              // Always setup listeners, even when there are no tag sets (for the Add button)
              this.setupCategoryTagSetsListeners(categoryId);
              _context14.n = 5;
              break;
            case 4:
              _context14.p = 4;
              _t8 = _context14.v;
              console.error('Failed to load tag sets:', _t8);
              container.innerHTML = '<div class="error-state"><p>Failed to load tag sets</p></div>';
            case 5:
              return _context14.a(2);
          }
        }, _callee14, this, [[1, 4]]);
      }));
      function renderCategoryTagSetsList(_x15) {
        return _renderCategoryTagSetsList.apply(this, arguments);
      }
      return renderCategoryTagSetsList;
    }()
    /**
     * Setup event listeners for category tag sets list
     */
    )
  }, {
    key: "setupCategoryTagSetsListeners",
    value: function setupCategoryTagSetsListeners(categoryId) {
      var _this4 = this;
      // Add Tag Set button (check both IDs for compatibility)
      var addTagSetBtn = document.getElementById('add-tag-set-btn-detail') || document.getElementById('add-tag-set-btn');
      if (addTagSetBtn) {
        // Remove old listener if exists
        addTagSetBtn.replaceWith(addTagSetBtn.cloneNode(true));
        var newBtn = document.getElementById('add-tag-set-btn-detail') || document.getElementById('add-tag-set-btn');
        if (newBtn) {
          newBtn.addEventListener('click', function () {
            _this4.showAddTagSetModal(categoryId);
          });
        }
      }

      // Add Tag buttons
      document.querySelectorAll('.add-tag-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          var tagSetId = parseInt(btn.dataset.tagSetId);
          _this4.showAddTagModal(tagSetId, categoryId);
        });
      });

      // Delete Tag Set buttons
      document.querySelectorAll('.delete-tag-set-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
          var tagSetId, _t9;
          return _regenerator().w(function (_context15) {
            while (1) switch (_context15.p = _context15.n) {
              case 0:
                tagSetId = parseInt(btn.dataset.tagSetId);
                if (!confirm('Delete this tag set? All tags in this set will be removed.')) {
                  _context15.n = 5;
                  break;
                }
                _context15.p = 1;
                _context15.n = 2;
                return _this4.deleteTagSet(tagSetId);
              case 2:
                _context15.n = 3;
                return _this4.renderCategoryTagSetsList(categoryId);
              case 3:
                _this4.showNotification('Tag set deleted', 'success');
                _context15.n = 5;
                break;
              case 4:
                _context15.p = 4;
                _t9 = _context15.v;
                console.error('Failed to delete tag set:', _t9);
                _this4.showNotification('Failed to delete tag set', 'error');
              case 5:
                return _context15.a(2);
            }
          }, _callee15, null, [[1, 4]]);
        })));
      });

      // Delete Tag buttons
      document.querySelectorAll('.delete-tag-btn').forEach(function (btn) {
        btn.addEventListener('click', /*#__PURE__*/function () {
          var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(e) {
            var tagId, tagSetId, _t0;
            return _regenerator().w(function (_context16) {
              while (1) switch (_context16.p = _context16.n) {
                case 0:
                  e.preventDefault();
                  e.stopPropagation();
                  tagId = parseInt(btn.dataset.tagId);
                  tagSetId = parseInt(btn.dataset.tagSetId);
                  if (!confirm('Delete this tag? It will be removed from all transactions.')) {
                    _context16.n = 5;
                    break;
                  }
                  _context16.p = 1;
                  _context16.n = 2;
                  return _this4.deleteTag(tagId, tagSetId);
                case 2:
                  _context16.n = 3;
                  return _this4.renderCategoryTagSetsList(categoryId);
                case 3:
                  _this4.showNotification('Tag deleted', 'success');
                  _context16.n = 5;
                  break;
                case 4:
                  _context16.p = 4;
                  _t0 = _context16.v;
                  console.error('Failed to delete tag:', _t0);
                  _this4.showNotification('Failed to delete tag', 'error');
                case 5:
                  return _context16.a(2);
              }
            }, _callee16, null, [[1, 4]]);
          }));
          return function (_x16) {
            return _ref7.apply(this, arguments);
          };
        }());
      });
    }

    /**
     * Save a tag set from the modal form
     */
  }, {
    key: "saveTagSet",
    value: (function () {
      var _saveTagSet = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(e) {
        var categoryId, name, description, _t1;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              e.preventDefault();
              categoryId = document.getElementById('tag-set-category-id').value;
              name = document.getElementById('tag-set-name').value;
              description = document.getElementById('tag-set-description').value;
              _context17.p = 1;
              _context17.n = 2;
              return this.createTagSet(parseInt(categoryId), name, description);
            case 2:
              this.hideModals();
              _context17.n = 3;
              return this.renderCategoryTagSetsList(parseInt(categoryId));
            case 3:
              this.showNotification('Tag set created successfully', 'success');
              _context17.n = 5;
              break;
            case 4:
              _context17.p = 4;
              _t1 = _context17.v;
              console.error('Failed to create tag set:', _t1);
              this.showNotification('Failed to create tag set', 'error');
            case 5:
              return _context17.a(2);
          }
        }, _callee17, this, [[1, 4]]);
      }));
      function saveTagSet(_x17) {
        return _saveTagSet.apply(this, arguments);
      }
      return saveTagSet;
    }()
    /**
     * Show modal for adding tag set
     */
    )
  }, {
    key: "showAddTagSetModal",
    value: function showAddTagSetModal(categoryId) {
      var _this5 = this;
      var modal = document.getElementById('add-tag-set-modal');
      if (!modal) {
        console.error('Add tag set modal not found');
        return;
      }
      var categoryIdInput = document.getElementById('tag-set-category-id');
      var nameInput = document.getElementById('tag-set-name');
      var descInput = document.getElementById('tag-set-description');
      if (!categoryIdInput || !nameInput) {
        console.error('Tag set modal form inputs not found');
        return;
      }
      categoryIdInput.value = categoryId;
      nameInput.value = '';
      if (descInput) {
        descInput.value = '';
      }
      modal.style.display = 'flex';

      // Setup form submission (remove old listener first)
      var form = document.getElementById('add-tag-set-form');
      if (form) {
        var newForm = form.cloneNode(true);
        form.parentNode.replaceChild(newForm, form);
        newForm.addEventListener('submit', function (e) {
          return _this5.saveTagSet(e);
        });
      }
    }

    /**
     * Load all transaction tags for filtering
     */
  }, {
    key: "loadAllTransactionTags",
    value: (function () {
      var _loadAllTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19() {
        var _this6 = this;
        var tagPromises, results, _t10;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.p = _context19.n) {
            case 0:
              if (!(!this.transactions || this.transactions.length === 0)) {
                _context19.n = 1;
                break;
              }
              this.transactionTags = {};
              return _context19.a(2);
            case 1:
              _context19.p = 1;
              // Load tags for each transaction
              tagPromises = this.transactions.map(/*#__PURE__*/function () {
                var _ref8 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(transaction) {
                  var response, tags;
                  return _regenerator().w(function (_context18) {
                    while (1) switch (_context18.n) {
                      case 0:
                        _context18.n = 1;
                        return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transaction.id, "/tags")), {
                          headers: {
                            'requesttoken': OC.requestToken
                          }
                        });
                      case 1:
                        response = _context18.v;
                        if (!response.ok) {
                          _context18.n = 3;
                          break;
                        }
                        _context18.n = 2;
                        return response.json();
                      case 2:
                        tags = _context18.v;
                        return _context18.a(2, {
                          transactionId: transaction.id,
                          tags: Array.isArray(tags) ? tags : []
                        });
                      case 3:
                        return _context18.a(2, {
                          transactionId: transaction.id,
                          tags: []
                        });
                    }
                  }, _callee18);
                }));
                return function (_x18) {
                  return _ref8.apply(this, arguments);
                };
              }());
              _context19.n = 2;
              return Promise.all(tagPromises);
            case 2:
              results = _context19.v;
              // Store tags by transaction ID
              this.transactionTags = {};
              results.forEach(function (result) {
                _this6.transactionTags[result.transactionId] = result.tags;
              });
              _context19.n = 4;
              break;
            case 3:
              _context19.p = 3;
              _t10 = _context19.v;
              console.error('Failed to load transaction tags:', _t10);
              this.transactionTags = {};
            case 4:
              return _context19.a(2);
          }
        }, _callee19, this, [[1, 3]]);
      }));
      function loadAllTransactionTags() {
        return _loadAllTransactionTags.apply(this, arguments);
      }
      return loadAllTransactionTags;
    }()
    /**
     * Show modal for adding a tag
     */
    )
  }, {
    key: "showAddTagModal",
    value: function showAddTagModal(tagSetId, categoryId) {
      var _this7 = this;
      var modal = document.getElementById('add-tag-modal');
      if (!modal) {
        console.error('Add tag modal not found');
        return;
      }
      var tagSetIdInput = document.getElementById('tag-set-id');
      var categoryIdInput = document.getElementById('tag-category-id');
      var nameInput = document.getElementById('tag-name');
      var colorInput = document.getElementById('tag-color');
      if (!tagSetIdInput || !categoryIdInput || !nameInput || !colorInput) {
        console.error('Tag modal form inputs not found');
        return;
      }
      tagSetIdInput.value = tagSetId;
      categoryIdInput.value = categoryId;
      nameInput.value = '';
      colorInput.value = '#666666';
      modal.style.display = 'flex';

      // Setup form submission (remove old listener first)
      var form = document.getElementById('add-tag-form');
      if (form) {
        var newForm = form.cloneNode(true);
        form.parentNode.replaceChild(newForm, form);
        newForm.addEventListener('submit', function (e) {
          return _this7.saveTag(e);
        });
      }
    }

    /**
     * Save a tag from the modal form
     */
  }, {
    key: "saveTag",
    value: (function () {
      var _saveTag = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(e) {
        var tagSetId, categoryId, name, color, _t11;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.p = _context20.n) {
            case 0:
              e.preventDefault();
              tagSetId = parseInt(document.getElementById('tag-set-id').value);
              categoryId = parseInt(document.getElementById('tag-category-id').value);
              name = document.getElementById('tag-name').value;
              color = document.getElementById('tag-color').value;
              _context20.p = 1;
              _context20.n = 2;
              return this.createTag(tagSetId, name, color);
            case 2:
              this.hideModals();
              _context20.n = 3;
              return this.renderCategoryTagSetsList(categoryId);
            case 3:
              this.showNotification('Tag created successfully', 'success');
              _context20.n = 5;
              break;
            case 4:
              _context20.p = 4;
              _t11 = _context20.v;
              console.error('Failed to create tag:', _t11);
              this.showNotification('Failed to create tag', 'error');
            case 5:
              return _context20.a(2);
          }
        }, _callee20, this, [[1, 4]]);
      }));
      function saveTag(_x19) {
        return _saveTag.apply(this, arguments);
      }
      return saveTag;
    }()
    /**
     * Setup event listeners for add tag modal
     */
    )
  }, {
    key: "setupAddTagModalListeners",
    value: function setupAddTagModalListeners() {
      var _this8 = this;
      var form = document.getElementById('add-tag-form');
      if (form) {
        form.addEventListener('submit', function (e) {
          return _this8.saveTag(e);
        });
      }

      // Cancel buttons
      document.querySelectorAll('.cancel-tag-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return _this8.hideModals();
        });
      });

      // Close on background click
      var modal = document.getElementById('add-tag-modal');
      if (modal) {
        modal.addEventListener('click', function (e) {
          if (e.target === modal) {
            _this8.hideModals();
          }
        });
      }
    }

    // Delegate helper methods to app
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "hideModals",
    value: function hideModals() {
      // Hide all modals
      var modals = ['add-tag-set-modal', 'add-tag-modal', 'edit-tag-set-modal'];
      modals.forEach(function (modalId) {
        var modal = document.getElementById(modalId);
        if (modal) {
          modal.style.display = 'none';
        }
      });

      // Also try app's hideModals if it exists
      if (this.app.hideModals) {
        this.app.hideModals();
      }
    }
  }, {
    key: "showNotification",
    value: function showNotification(message) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';
      if (this.app.showNotification) {
        return this.app.showNotification(message, type);
      }
      // Fallback to OC notification
      OC.Notification.showTemporary(message);
    }
  }]);
}();


/***/ }),

/***/ "./src/modules/transactions/TransactionsModule.js":
/*!********************************************************!*\
  !*** ./src/modules/transactions/TransactionsModule.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransactionsModule)
/* harmony export */ });
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/dom.js */ "./src/utils/dom.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * TransactionsModule - Handles all transaction-related functionality
 *
 * This module manages:
 * - Transaction filtering, sorting, and pagination
 * - Bulk operations (edit, delete, reconcile)
 * - Inline editing of transactions
 * - Transaction matching and linking (transfers)
 * - Transaction splits
 * - Reconciliation mode
 */



var TransactionsModule = /*#__PURE__*/function () {
  function TransactionsModule(app) {
    _classCallCheck(this, TransactionsModule);
    this.app = app;

    // Transaction state
    this.transactionFilters = {};
    this.currentSort = {
      field: 'date',
      direction: 'desc'
    };
    this.currentPage = 1;
    this.rowsPerPage = 25;
    this.selectedTransactions = new Set();
    this.reconcileMode = false;
    this.reconcileData = null;

    // Inline editing state
    this.currentEditingCell = null;
    this.originalValue = null;

    // Filter timeout for debouncing
    this.filterTimeout = null;
  }

  // State proxies
  return _createClass(TransactionsModule, [{
    key: "accounts",
    get: function get() {
      return this.app.accounts;
    }
  }, {
    key: "categories",
    get: function get() {
      return this.app.categories;
    }
  }, {
    key: "transactions",
    get: function get() {
      return this.app.transactions;
    }
  }, {
    key: "settings",
    get: function get() {
      return this.app.settings;
    }
  }, {
    key: "categoryTree",
    get: function get() {
      return this.app.categoryTree;
    }
  }, {
    key: "allCategories",
    get: function get() {
      return this.app.allCategories;
    }

    // Helper proxies
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount, currency) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "formatDate",
    value: function formatDate(dateStr) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_0__.formatDate(dateStr, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_1__.escapeHtml(text);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      return this.app.getPrimaryCurrency();
    }

    // ===========================
    // Event Listeners Setup
    // ===========================
  }, {
    key: "setupTransactionEventListeners",
    value: function setupTransactionEventListeners() {
      var _this = this;
      // Initialize transaction state only if enhanced UI is present
      var hasEnhancedUI = document.getElementById('transactions-filters');
      if (hasEnhancedUI) {
        this.transactionFilters = {};
        this.currentSort = {
          field: 'date',
          direction: 'desc'
        };
        this.currentPage = 1;
        this.rowsPerPage = 25;
        this.selectedTransactions = new Set();
        this.reconcileMode = false;
      }

      // Toggle filters panel
      var toggleFiltersBtn = document.getElementById('toggle-filters-btn');
      if (toggleFiltersBtn) {
        toggleFiltersBtn.addEventListener('click', function () {
          _this.toggleFiltersPanel();
        });
      }

      // Filter controls
      var filterControls = ['filter-account', 'filter-category', 'filter-type', 'filter-date-from', 'filter-date-to', 'filter-amount-min', 'filter-amount-max', 'filter-search'];
      filterControls.forEach(function (controlId) {
        var control = document.getElementById(controlId);
        if (control) {
          var eventType = control.type === 'text' || control.type === 'number' ? 'input' : 'change';
          control.addEventListener(eventType, function () {
            if (control.type === 'text' || control.type === 'number') {
              // Debounce text/number inputs
              clearTimeout(_this.filterTimeout);
              _this.filterTimeout = setTimeout(function () {
                _this.updateFilters();
              }, 300);
            } else {
              _this.updateFilters();
            }
          });
        }
      });

      // Filter action buttons
      var applyFiltersBtn = document.getElementById('apply-filters-btn');
      if (applyFiltersBtn) {
        applyFiltersBtn.addEventListener('click', function () {
          _this.app.loadTransactions();
        });
      }
      var clearFiltersBtn = document.getElementById('clear-filters-btn');
      if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener('click', function () {
          _this.clearFilters();
        });
      }

      // Bulk actions
      var bulkActionsBtn = document.getElementById('bulk-actions-btn');
      if (bulkActionsBtn) {
        bulkActionsBtn.addEventListener('click', function () {
          _this.toggleBulkMode();
        });
      }
      var cancelBulkBtn = document.getElementById('cancel-bulk-btn');
      if (cancelBulkBtn) {
        cancelBulkBtn.addEventListener('click', function () {
          _this.cancelBulkMode();
        });
      }
      var bulkDeleteBtn = document.getElementById('bulk-delete-btn');
      if (bulkDeleteBtn) {
        bulkDeleteBtn.addEventListener('click', function () {
          _this.bulkDeleteTransactions();
        });
      }
      var bulkReconcileBtn = document.getElementById('bulk-reconcile-btn');
      if (bulkReconcileBtn) {
        bulkReconcileBtn.addEventListener('click', function () {
          _this.bulkReconcileTransactions();
        });
      }
      var bulkUnreconcileBtn = document.getElementById('bulk-unreconcile-btn');
      if (bulkUnreconcileBtn) {
        bulkUnreconcileBtn.addEventListener('click', function () {
          _this.bulkUnreconcileTransactions();
        });
      }
      var bulkEditBtn = document.getElementById('bulk-edit-btn');
      if (bulkEditBtn) {
        bulkEditBtn.addEventListener('click', function () {
          _this.showBulkEditModal();
        });
      }
      var bulkEditSubmitBtn = document.getElementById('bulk-edit-submit-btn');
      if (bulkEditSubmitBtn) {
        bulkEditSubmitBtn.addEventListener('click', function () {
          _this.submitBulkEdit();
        });
      }
      var cancelBulkEditBtns = document.querySelectorAll('.cancel-bulk-edit-btn');
      cancelBulkEditBtns.forEach(function (btn) {
        btn.addEventListener('click', function () {
          document.getElementById('bulk-edit-modal').style.display = 'none';
        });
      });

      // Reconciliation
      var reconcileModeBtn = document.getElementById('reconcile-mode-btn');
      if (reconcileModeBtn) {
        reconcileModeBtn.addEventListener('click', function () {
          _this.toggleReconcileMode();
        });
      }

      // Bulk Match All
      var bulkMatchBtn = document.getElementById('bulk-match-btn');
      if (bulkMatchBtn) {
        bulkMatchBtn.addEventListener('click', function () {
          _this.showBulkMatchModal();
        });
      }
      var startReconcileBtn = document.getElementById('start-reconcile-btn');
      if (startReconcileBtn) {
        startReconcileBtn.addEventListener('click', function () {
          _this.startReconciliation();
        });
      }
      var cancelReconcileBtn = document.getElementById('cancel-reconcile-btn');
      if (cancelReconcileBtn) {
        cancelReconcileBtn.addEventListener('click', function () {
          _this.cancelReconciliation();
        });
      }

      // Pagination
      var rowsPerPageSelect = document.getElementById('rows-per-page');
      if (rowsPerPageSelect) {
        rowsPerPageSelect.addEventListener('change', function (e) {
          _this.rowsPerPage = parseInt(e.target.value);
          _this.currentPage = 1;
          _this.app.loadTransactions();
        });
      }
      var prevPageBtn = document.getElementById('prev-page-btn');
      if (prevPageBtn) {
        prevPageBtn.addEventListener('click', function () {
          if (_this.currentPage > 1) {
            _this.currentPage--;
            _this.app.loadTransactions();
          }
        });
      }
      var nextPageBtn = document.getElementById('next-page-btn');
      if (nextPageBtn) {
        nextPageBtn.addEventListener('click', function () {
          _this.currentPage++;
          _this.app.loadTransactions();
        });
      }

      // Bottom pagination buttons
      var prevPageBtnBottom = document.getElementById('prev-page-btn-bottom');
      if (prevPageBtnBottom) {
        prevPageBtnBottom.addEventListener('click', function () {
          if (_this.currentPage > 1) {
            _this.currentPage--;
            _this.app.loadTransactions();
          }
        });
      }
      var nextPageBtnBottom = document.getElementById('next-page-btn-bottom');
      if (nextPageBtnBottom) {
        nextPageBtnBottom.addEventListener('click', function () {
          _this.currentPage++;
          _this.app.loadTransactions();
        });
      }

      // Table sorting and selection
      document.addEventListener('click', function (e) {
        // Column sorting
        if (e.target.closest('.sortable')) {
          var header = e.target.closest('.sortable');
          var field = header.getAttribute('data-sort');
          _this.sortTransactions(field);
        }

        // Select all checkbox
        if (e.target.id === 'select-all-transactions') {
          _this.toggleAllTransactionSelection(e.target.checked);
        }

        // Individual transaction checkboxes
        if (e.target.classList.contains('transaction-checkbox')) {
          var transactionId = parseInt(e.target.getAttribute('data-transaction-id'));
          _this.toggleTransactionSelection(transactionId, e.target.checked);
        }

        // Reconcile checkboxes
        if (e.target.classList.contains('reconcile-checkbox')) {
          var _transactionId = parseInt(e.target.getAttribute('data-transaction-id'));
          _this.toggleTransactionReconciliation(_transactionId, e.target.checked);
        }
      });
    }

    // Transaction filtering and display methods
  }, {
    key: "toggleFiltersPanel",
    value: function toggleFiltersPanel() {
      var filtersPanel = document.getElementById('transactions-filters');
      var toggleBtn = document.getElementById('toggle-filters-btn');
      if (filtersPanel.style.display === 'none') {
        filtersPanel.style.display = 'block';
        toggleBtn.classList.add('active');
        // Populate filter dropdowns
        this.populateFilterDropdowns();
      } else {
        filtersPanel.style.display = 'none';
        toggleBtn.classList.remove('active');
      }
    }
  }, {
    key: "populateFilterDropdowns",
    value: function populateFilterDropdowns() {
      // Populate account filter
      var accountFilter = document.getElementById('filter-account');
      if (accountFilter && this.accounts) {
        accountFilter.innerHTML = '<option value="">All Accounts</option>';
        this.accounts.forEach(function (account) {
          accountFilter.innerHTML += "<option value=\"".concat(account.id, "\">").concat(account.name, "</option>");
        });
      }

      // Populate category filter
      var categoryFilter = document.getElementById('filter-category');
      if (categoryFilter && this.categories) {
        categoryFilter.innerHTML = '<option value="">All Categories</option><option value="uncategorized">Uncategorized</option>';
        this.categories.forEach(function (category) {
          categoryFilter.innerHTML += "<option value=\"".concat(category.id, "\">").concat(category.name, "</option>");
        });
      }

      // Populate reconcile account select
      var reconcileAccount = document.getElementById('reconcile-account');
      if (reconcileAccount && this.accounts) {
        reconcileAccount.innerHTML = '<option value="">Select account to reconcile</option>';
        this.accounts.forEach(function (account) {
          reconcileAccount.innerHTML += "<option value=\"".concat(account.id, "\">").concat(account.name, "</option>");
        });
      }
    }
  }, {
    key: "updateFilters",
    value: function updateFilters() {
      var _document$getElementB, _document$getElementB2, _document$getElementB3, _document$getElementB4, _document$getElementB5, _document$getElementB6, _document$getElementB7, _document$getElementB8;
      this.transactionFilters = {
        account: ((_document$getElementB = document.getElementById('filter-account')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.value) || '',
        category: ((_document$getElementB2 = document.getElementById('filter-category')) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.value) || '',
        type: ((_document$getElementB3 = document.getElementById('filter-type')) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.value) || '',
        dateFrom: ((_document$getElementB4 = document.getElementById('filter-date-from')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value) || '',
        dateTo: ((_document$getElementB5 = document.getElementById('filter-date-to')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value) || '',
        amountMin: ((_document$getElementB6 = document.getElementById('filter-amount-min')) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.value) || '',
        amountMax: ((_document$getElementB7 = document.getElementById('filter-amount-max')) === null || _document$getElementB7 === void 0 ? void 0 : _document$getElementB7.value) || '',
        search: ((_document$getElementB8 = document.getElementById('filter-search')) === null || _document$getElementB8 === void 0 ? void 0 : _document$getElementB8.value) || ''
      };

      // Auto-apply filters if any are set
      var hasFilters = Object.values(this.transactionFilters).some(function (value) {
        return value !== '';
      });
      if (hasFilters) {
        this.currentPage = 1;
        this.app.loadTransactions();
      }
    }
  }, {
    key: "clearFilters",
    value: function clearFilters() {
      var filterInputs = ['filter-account', 'filter-category', 'filter-type', 'filter-date-from', 'filter-date-to', 'filter-amount-min', 'filter-amount-max', 'filter-search'];
      filterInputs.forEach(function (inputId) {
        var input = document.getElementById(inputId);
        if (input) {
          input.value = '';
        }
      });
      this.transactionFilters = {};
      this.currentPage = 1;
      this.app.loadTransactions();
    }
  }, {
    key: "sortTransactions",
    value: function sortTransactions(field) {
      if (this.currentSort.field === field) {
        this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        this.currentSort.field = field;
        this.currentSort.direction = 'asc';
      }

      // Update sort indicators
      document.querySelectorAll('.sort-indicator').forEach(function (indicator) {
        indicator.className = 'sort-indicator';
      });
      var currentHeader = document.querySelector("[data-sort=\"".concat(field, "\"] .sort-indicator"));
      if (currentHeader) {
        currentHeader.className = "sort-indicator ".concat(this.currentSort.direction);
      }
      this.app.loadTransactions();
    }

    // Bulk operations
  }, {
    key: "toggleBulkMode",
    value: function toggleBulkMode() {
      var bulkPanel = document.getElementById('bulk-actions-panel');
      var bulkBtn = document.getElementById('bulk-actions-btn');
      var selectColumn = document.querySelectorAll('.select-column');
      if (bulkPanel.style.display === 'none') {
        bulkPanel.style.display = 'block';
        bulkBtn.classList.add('active');
        selectColumn.forEach(function (col) {
          return col.style.display = 'table-cell';
        });
        this.app.loadTransactions(); // Reload to show checkboxes
      } else {
        this.cancelBulkMode();
      }
    }
  }, {
    key: "cancelBulkMode",
    value: function cancelBulkMode() {
      var bulkPanel = document.getElementById('bulk-actions-panel');
      var bulkBtn = document.getElementById('bulk-actions-btn');
      var selectColumn = document.querySelectorAll('.select-column');
      bulkPanel.style.display = 'none';
      bulkBtn.classList.remove('active');
      selectColumn.forEach(function (col) {
        return col.style.display = 'none';
      });
      this.selectedTransactions.clear();
      this.updateBulkActionsState();
      this.app.loadTransactions(); // Reload to hide checkboxes
    }
  }, {
    key: "toggleAllTransactionSelection",
    value: function toggleAllTransactionSelection(checked) {
      var _this2 = this;
      this.selectedTransactions.clear();
      if (checked) {
        // Select all visible transactions
        document.querySelectorAll('.transaction-checkbox').forEach(function (checkbox) {
          checkbox.checked = true;
          var transactionId = parseInt(checkbox.getAttribute('data-transaction-id'));
          _this2.selectedTransactions.add(transactionId);
        });
      } else {
        document.querySelectorAll('.transaction-checkbox').forEach(function (checkbox) {
          checkbox.checked = false;
        });
      }
      this.updateBulkActionsState();
    }
  }, {
    key: "toggleTransactionSelection",
    value: function toggleTransactionSelection(transactionId, checked) {
      if (checked) {
        this.selectedTransactions.add(transactionId);
      } else {
        this.selectedTransactions["delete"](transactionId);
      }

      // Update select all checkbox
      var selectAllCheckbox = document.getElementById('select-all-transactions');
      var allCheckboxes = document.querySelectorAll('.transaction-checkbox');
      var checkedCheckboxes = document.querySelectorAll('.transaction-checkbox:checked');
      if (selectAllCheckbox) {
        selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length && allCheckboxes.length > 0;
        selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < allCheckboxes.length;
      }
      this.updateBulkActionsState();
    }
  }, {
    key: "updateBulkActionsState",
    value: function updateBulkActionsState() {
      var selectedCount = this.selectedTransactions.size;
      var selectedCountElement = document.getElementById('selected-count');
      var bulkActionsBtn = document.getElementById('bulk-actions-btn');
      var bulkDeleteBtn = document.getElementById('bulk-delete-btn');
      var bulkReconcileBtn = document.getElementById('bulk-reconcile-btn');
      var bulkUnreconcileBtn = document.getElementById('bulk-unreconcile-btn');
      var bulkEditBtn = document.getElementById('bulk-edit-btn');
      if (selectedCountElement) {
        selectedCountElement.textContent = selectedCount;
      }
      var disabled = selectedCount === 0;
      if (bulkActionsBtn) {
        bulkActionsBtn.disabled = disabled;
      }
      if (bulkDeleteBtn) {
        bulkDeleteBtn.disabled = disabled;
      }
      if (bulkReconcileBtn) {
        bulkReconcileBtn.disabled = disabled;
      }
      if (bulkUnreconcileBtn) {
        bulkUnreconcileBtn.disabled = disabled;
      }
      if (bulkEditBtn) {
        bulkEditBtn.disabled = disabled;
      }
    }
  }, {
    key: "bulkDeleteTransactions",
    value: function () {
      var _bulkDeleteTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var response, result, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              if (!(this.selectedTransactions.size === 0)) {
                _context.n = 1;
                break;
              }
              return _context.a(2);
            case 1:
              if (confirm("Are you sure you want to delete ".concat(this.selectedTransactions.size, " transactions? This action cannot be undone."))) {
                _context.n = 2;
                break;
              }
              return _context.a(2);
            case 2:
              _context.p = 2;
              _context.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-delete'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  ids: Array.from(this.selectedTransactions)
                })
              });
            case 3:
              response = _context.v;
              _context.n = 4;
              return response.json();
            case 4:
              result = _context.v;
              if (result.success > 0) {
                OC.Notification.showTemporary("Successfully deleted ".concat(result.success, " transaction(s)"));
                this.selectedTransactions.clear();
                this.app.loadTransactions();
              }
              if (result.failed > 0) {
                OC.Notification.showTemporary("Failed to delete ".concat(result.failed, " transaction(s)"), {
                  type: 'error'
                });
              }
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              console.error('Bulk deletion failed:', _t);
              OC.Notification.showTemporary('Failed to delete transactions');
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[2, 5]]);
      }));
      function bulkDeleteTransactions() {
        return _bulkDeleteTransactions.apply(this, arguments);
      }
      return bulkDeleteTransactions;
    }()
  }, {
    key: "bulkReconcileTransactions",
    value: function () {
      var _bulkReconcileTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var response, result, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              if (!(this.selectedTransactions.size === 0)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (confirm("Are you sure you want to mark ".concat(this.selectedTransactions.size, " transactions as reconciled?"))) {
                _context2.n = 2;
                break;
              }
              return _context2.a(2);
            case 2:
              _context2.p = 2;
              _context2.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-reconcile'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  ids: Array.from(this.selectedTransactions),
                  reconciled: true
                })
              });
            case 3:
              response = _context2.v;
              _context2.n = 4;
              return response.json();
            case 4:
              result = _context2.v;
              if (result.success > 0) {
                OC.Notification.showTemporary("Successfully reconciled ".concat(result.success, " transaction(s)"));
                this.selectedTransactions.clear();
                this.app.loadTransactions();
              }
              if (result.failed > 0) {
                OC.Notification.showTemporary("Failed to reconcile ".concat(result.failed, " transaction(s)"), {
                  type: 'error'
                });
              }
              _context2.n = 6;
              break;
            case 5:
              _context2.p = 5;
              _t2 = _context2.v;
              console.error('Bulk reconcile failed:', _t2);
              OC.Notification.showTemporary('Failed to reconcile transactions');
            case 6:
              return _context2.a(2);
          }
        }, _callee2, this, [[2, 5]]);
      }));
      function bulkReconcileTransactions() {
        return _bulkReconcileTransactions.apply(this, arguments);
      }
      return bulkReconcileTransactions;
    }()
  }, {
    key: "bulkUnreconcileTransactions",
    value: function () {
      var _bulkUnreconcileTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var response, result, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              if (!(this.selectedTransactions.size === 0)) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2);
            case 1:
              if (confirm("Are you sure you want to mark ".concat(this.selectedTransactions.size, " transactions as unreconciled?"))) {
                _context3.n = 2;
                break;
              }
              return _context3.a(2);
            case 2:
              _context3.p = 2;
              _context3.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-reconcile'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  ids: Array.from(this.selectedTransactions),
                  reconciled: false
                })
              });
            case 3:
              response = _context3.v;
              _context3.n = 4;
              return response.json();
            case 4:
              result = _context3.v;
              if (result.success > 0) {
                OC.Notification.showTemporary("Successfully unreconciled ".concat(result.success, " transaction(s)"));
                this.selectedTransactions.clear();
                this.app.loadTransactions();
              }
              if (result.failed > 0) {
                OC.Notification.showTemporary("Failed to unreconcile ".concat(result.failed, " transaction(s)"), {
                  type: 'error'
                });
              }
              _context3.n = 6;
              break;
            case 5:
              _context3.p = 5;
              _t3 = _context3.v;
              console.error('Bulk unreconcile failed:', _t3);
              OC.Notification.showTemporary('Failed to unreconcile transactions');
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this, [[2, 5]]);
      }));
      function bulkUnreconcileTransactions() {
        return _bulkUnreconcileTransactions.apply(this, arguments);
      }
      return bulkUnreconcileTransactions;
    }()
  }, {
    key: "showBulkEditModal",
    value: function showBulkEditModal() {
      if (this.selectedTransactions.size === 0) {
        return;
      }
      var modal = document.getElementById('bulk-edit-modal');
      var countElement = document.getElementById('bulk-edit-count');
      var categorySelect = document.getElementById('bulk-edit-category');

      // Update count
      if (countElement) {
        countElement.textContent = this.selectedTransactions.size;
      }

      // Populate category dropdown
      if (categorySelect && this.categories) {
        categorySelect.innerHTML = '<option value="">Don\'t change</option>';
        this.categories.forEach(function (cat) {
          var option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          categorySelect.appendChild(option);
        });
      }

      // Reset form
      document.getElementById('bulk-edit-vendor').value = '';
      document.getElementById('bulk-edit-reference').value = '';
      document.getElementById('bulk-edit-notes').value = '';
      modal.style.display = 'flex';
    }
  }, {
    key: "submitBulkEdit",
    value: function () {
      var _submitBulkEdit = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var categoryId, vendor, reference, notes, updates, response, result, _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              categoryId = document.getElementById('bulk-edit-category').value;
              vendor = document.getElementById('bulk-edit-vendor').value.trim();
              reference = document.getElementById('bulk-edit-reference').value.trim();
              notes = document.getElementById('bulk-edit-notes').value.trim(); // Build updates object with only non-empty fields
              updates = {};
              if (categoryId) updates.categoryId = parseInt(categoryId);
              if (vendor) updates.vendor = vendor;
              if (reference) updates.reference = reference;
              if (notes) updates.notes = notes;
              if (!(Object.keys(updates).length === 0)) {
                _context4.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please fill in at least one field to update');
              return _context4.a(2);
            case 1:
              if (confirm("Are you sure you want to update ".concat(this.selectedTransactions.size, " transactions?"))) {
                _context4.n = 2;
                break;
              }
              return _context4.a(2);
            case 2:
              _context4.p = 2;
              _context4.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-edit'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  ids: Array.from(this.selectedTransactions),
                  updates: updates
                })
              });
            case 3:
              response = _context4.v;
              _context4.n = 4;
              return response.json();
            case 4:
              result = _context4.v;
              if (result.success > 0) {
                OC.Notification.showTemporary("Successfully updated ".concat(result.success, " transaction(s)"));
                this.selectedTransactions.clear();
                this.app.loadTransactions();

                // Close modal
                document.getElementById('bulk-edit-modal').style.display = 'none';
              }
              if (result.failed > 0) {
                OC.Notification.showTemporary("Failed to update ".concat(result.failed, " transaction(s)"), {
                  type: 'error'
                });
              }
              _context4.n = 6;
              break;
            case 5:
              _context4.p = 5;
              _t4 = _context4.v;
              console.error('Bulk edit failed:', _t4);
              OC.Notification.showTemporary('Failed to update transactions');
            case 6:
              return _context4.a(2);
          }
        }, _callee4, this, [[2, 5]]);
      }));
      function submitBulkEdit() {
        return _submitBulkEdit.apply(this, arguments);
      }
      return submitBulkEdit;
    }() // Reconciliation
  }, {
    key: "toggleReconcileMode",
    value: function toggleReconcileMode() {
      var reconcilePanel = document.getElementById('reconcile-panel');
      var reconcileBtn = document.getElementById('reconcile-mode-btn');
      if (reconcilePanel.style.display === 'none') {
        reconcilePanel.style.display = 'block';
        reconcileBtn.classList.add('active');
        this.populateFilterDropdowns();
      } else {
        reconcilePanel.style.display = 'none';
        reconcileBtn.classList.remove('active');
        this.reconcileMode = false;
        this.app.loadTransactions();
      }
    }
  }, {
    key: "startReconciliation",
    value: function () {
      var _startReconciliation = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var accountId, statementBalance, statementDate, _this$accounts, account, result, response, currentBalance, targetBalance, difference, filterAccount, _t5, _t6;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              accountId = document.getElementById('reconcile-account').value;
              statementBalance = document.getElementById('reconcile-statement-balance').value;
              statementDate = document.getElementById('reconcile-statement-date').value;
              if (!(!accountId || !statementBalance || !statementDate)) {
                _context5.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please fill in all reconciliation fields');
              return _context5.a(2);
            case 1:
              _context5.p = 1;
              // Check if we have the reconcile endpoint, otherwise simulate it
              account = (_this$accounts = this.accounts) === null || _this$accounts === void 0 ? void 0 : _this$accounts.find(function (a) {
                return a.id === parseInt(accountId);
              });
              if (account) {
                _context5.n = 2;
                break;
              }
              throw new Error('Account not found');
            case 2:
              _context5.p = 2;
              _context5.n = 3;
              return fetch(OC.generateUrl("/apps/budget/api/accounts/".concat(accountId, "/reconcile")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  statementBalance: parseFloat(statementBalance)
                })
              });
            case 3:
              response = _context5.v;
              if (!response.ok) {
                _context5.n = 5;
                break;
              }
              _context5.n = 4;
              return response.json();
            case 4:
              result = _context5.v;
              _context5.n = 6;
              break;
            case 5:
              throw new Error('Endpoint not available');
            case 6:
              _context5.n = 8;
              break;
            case 7:
              _context5.p = 7;
              _t5 = _context5.v;
              // Fallback: simulate reconciliation locally
              console.warn('Reconcile API not available, using local simulation:', _t5);
              currentBalance = account.balance || 0;
              targetBalance = parseFloat(statementBalance);
              difference = targetBalance - currentBalance;
              result = {
                currentBalance: currentBalance,
                statementBalance: targetBalance,
                difference: difference,
                isBalanced: Math.abs(difference) < 0.01
              };
            case 8:
              this.reconcileMode = true;
              this.reconcileData = result;

              // Show reconcile columns and filter by account
              document.querySelectorAll('.reconcile-column').forEach(function (col) {
                col.style.display = 'table-cell';
              });

              // Set account filter
              filterAccount = document.getElementById('filter-account');
              if (filterAccount) {
                filterAccount.value = accountId;
                this.updateFilters();
              }

              // Hide reconcile panel and show reconcile info
              document.getElementById('reconcile-panel').style.display = 'none';
              this.showReconcileInfo(result);
              OC.Notification.showTemporary('Reconciliation mode started');
              _context5.n = 10;
              break;
            case 9:
              _context5.p = 9;
              _t6 = _context5.v;
              console.error('Reconciliation failed:', _t6);
              OC.Notification.showTemporary('Failed to start reconciliation: ' + _t6.message);
            case 10:
              return _context5.a(2);
          }
        }, _callee5, this, [[2, 7], [1, 9]]);
      }));
      function startReconciliation() {
        return _startReconciliation.apply(this, arguments);
      }
      return startReconciliation;
    }()
  }, {
    key: "showReconcileInfo",
    value: function showReconcileInfo(reconcileData) {
      var _this3 = this;
      // Create floating reconcile info panel
      var existingInfo = document.getElementById('reconcile-info-float');
      if (existingInfo) {
        existingInfo.remove();
      }
      var infoPanel = document.createElement('div');
      infoPanel.id = 'reconcile-info-float';
      infoPanel.className = 'reconcile-info-float';
      infoPanel.innerHTML = "\n            <div class=\"reconcile-info-content\">\n                <h4>Account Reconciliation</h4>\n                <div class=\"reconcile-stats\">\n                    <div class=\"stat\">\n                        <label>Current Balance:</label>\n                        <span class=\"amount\">".concat(this.formatCurrency(reconcileData.currentBalance || 0), "</span>\n                    </div>\n                    <div class=\"stat\">\n                        <label>Statement Balance:</label>\n                        <span class=\"amount\">").concat(this.formatCurrency(reconcileData.statementBalance || 0), "</span>\n                    </div>\n                    <div class=\"stat ").concat(reconcileData.isBalanced ? 'balanced' : 'unbalanced', "\">\n                        <label>Difference:</label>\n                        <span class=\"amount\">").concat(this.formatCurrency(reconcileData.difference || 0), "</span>\n                    </div>\n                </div>\n                <button id=\"finish-reconcile-btn\" class=\"primary\" ").concat(!reconcileData.isBalanced ? 'disabled' : '', ">\n                    Finish Reconciliation\n                </button>\n                <button id=\"cancel-reconcile-info-btn\" class=\"secondary\">Cancel</button>\n            </div>\n        ");
      document.body.appendChild(infoPanel);

      // Add event listeners
      document.getElementById('finish-reconcile-btn').addEventListener('click', function () {
        _this3.finishReconciliation();
      });
      document.getElementById('cancel-reconcile-info-btn').addEventListener('click', function () {
        _this3.cancelReconciliation();
      });
    }
  }, {
    key: "cancelReconciliation",
    value: function cancelReconciliation() {
      this.reconcileMode = false;
      this.reconcileData = null;

      // Hide reconcile columns
      document.querySelectorAll('.reconcile-column').forEach(function (col) {
        col.style.display = 'none';
      });

      // Remove floating info panel
      var infoPanel = document.getElementById('reconcile-info-float');
      if (infoPanel) {
        infoPanel.remove();
      }

      // Reset reconcile panel
      document.getElementById('reconcile-panel').style.display = 'none';
      document.getElementById('reconcile-mode-btn').classList.remove('active');
      this.app.loadTransactions();
    }
  }, {
    key: "toggleTransactionReconciliation",
    value: function () {
      var _toggleTransactionReconciliation = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(transactionId, checked) {
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              // Implementation would update transaction reconciliation status
              // This is a placeholder for the actual API call
              console.log('Toggle reconciliation for transaction:', transactionId, checked);
            case 1:
              return _context6.a(2);
          }
        }, _callee6);
      }));
      function toggleTransactionReconciliation(_x, _x2) {
        return _toggleTransactionReconciliation.apply(this, arguments);
      }
      return toggleTransactionReconciliation;
    }() // Rendering
  }, {
    key: "renderTransactionsTable",
    value: function renderTransactionsTable(transactions) {
      var _this4 = this;
      return transactions.map(function (t) {
        var isSplit = t.isSplit || t.is_split;
        var categoryDisplay = isSplit ? '<span class="split-indicator" title="This transaction is split across multiple categories">Split</span>' : t.categoryName ? "<span class=\"category-name\">".concat(_this4.escapeHtml(t.categoryName), "</span>") : '-';
        return "\n            <tr class=\"".concat(isSplit ? 'split-transaction' : '', "\">\n                <td class=\"select-column\">\n                    <input type=\"checkbox\" class=\"transaction-checkbox\" data-transaction-id=\"").concat(t.id, "\">\n                </td>\n                <td>").concat(_this4.formatDate(t.date), "</td>\n                <td>").concat(_this4.escapeHtml(t.description), "</td>\n                <td>").concat(categoryDisplay, "</td>\n                <td class=\"amount ").concat(t.type, "\">").concat(_this4.formatCurrency(t.amount, t.accountCurrency), "</td>\n                <td>").concat(_this4.escapeHtml(t.accountName), "</td>\n                <td class=\"reconcile-column\"></td>\n                <td>\n                    <button class=\"tertiary transaction-split-btn\" data-transaction-id=\"").concat(t.id, "\" title=\"").concat(isSplit ? 'Edit splits' : 'Split transaction', "\">\n                        ").concat(isSplit ? 'Splits' : 'Split', "\n                    </button>\n                    <button class=\"tertiary transaction-edit-btn\" data-transaction-id=\"").concat(t.id, "\" aria-label=\"Edit transaction: ").concat(t.description, "\">Edit</button>\n                    <button class=\"error transaction-delete-btn\" data-transaction-id=\"").concat(t.id, "\" aria-label=\"Delete transaction: ").concat(t.description, "\">Delete</button>\n                </td>\n            </tr>\n            ");
      }).join('');
    }
  }, {
    key: "renderTransactionsList",
    value: function renderTransactionsList(transactions) {
      var _this5 = this;
      return transactions.map(function (t) {
        return "\n            <div class=\"transaction-item\">\n                <span class=\"transaction-date\">".concat(_this5.formatDate(t.date), "</span>\n                <span class=\"transaction-description\">").concat(t.description, "</span>\n                <span class=\"amount ").concat(t.type, "\">").concat(_this5.formatCurrency(t.amount, t.accountCurrency), "</span>\n            </div>\n        ");
      }).join('');
    }
  }, {
    key: "populateTransactionModalDropdowns",
    value: function populateTransactionModalDropdowns() {
      // Populate account dropdown
      var accountSelect = document.getElementById('transaction-account');
      if (accountSelect && this.accounts) {
        // Save current value
        var currentValue = accountSelect.value;

        // Clear and rebuild options
        accountSelect.innerHTML = '<option value="">Choose an account</option>';
        this.accounts.forEach(function (account) {
          var option = document.createElement('option');
          option.value = account.id;
          option.textContent = account.name;
          accountSelect.appendChild(option);
        });

        // Restore previous value if it exists
        if (currentValue) {
          accountSelect.value = currentValue;
        }
      }

      // Populate category dropdown
      var categorySelect = document.getElementById('transaction-category');
      if (categorySelect && this.categories) {
        // Save current value
        var _currentValue = categorySelect.value;

        // Clear and rebuild options
        categorySelect.innerHTML = '<option value="">No category</option>';

        // Use flat categories list if available, otherwise use hierarchical
        var categoriesList = this.allCategories || this.categories;
        this.renderCategoryOptions(categorySelect, categoriesList);

        // Restore previous value if it exists
        if (_currentValue) {
          categorySelect.value = _currentValue;
        }
      }
    }
  }, {
    key: "renderCategoryOptions",
    value: function renderCategoryOptions(selectElement, categories) {
      var _this6 = this;
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      categories.forEach(function (category) {
        var option = document.createElement('option');
        option.value = category.id;
        option.textContent = '  '.repeat(level) + category.name;
        selectElement.appendChild(option);

        // Recursively add child categories
        if (category.children && category.children.length > 0) {
          _this6.renderCategoryOptions(selectElement, category.children, level + 1);
        }
      });
    }
  }, {
    key: "showTransactionModal",
    value: function showTransactionModal() {
      var _this7 = this;
      var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var preSelectedAccountId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var modal = document.getElementById('transaction-modal');
      if (modal) {
        // Populate account and category dropdowns first
        this.populateTransactionModalDropdowns();
        if (transaction) {
          // Populate form with transaction data (editing mode)
          document.getElementById('transaction-id').value = transaction.id;
          document.getElementById('transaction-date').value = transaction.date;
          document.getElementById('transaction-account').value = transaction.accountId;
          document.getElementById('transaction-type').value = transaction.type;
          document.getElementById('transaction-amount').value = transaction.amount;
          document.getElementById('transaction-description').value = transaction.description;
          document.getElementById('transaction-vendor').value = transaction.vendor || '';
          document.getElementById('transaction-category').value = transaction.categoryId || '';
          document.getElementById('transaction-notes').value = transaction.notes || '';

          // Load tag selectors for this transaction
          this.app.renderTransactionTagSelectors(transaction.categoryId, transaction.id);
        } else {
          // Clear form (new transaction mode)
          document.getElementById('transaction-form').reset();
          document.getElementById('transaction-id').value = '';
          document.getElementById('transaction-date').value = new Date().toISOString().split('T')[0];

          // Pre-select account if provided
          if (preSelectedAccountId) {
            document.getElementById('transaction-account').value = preSelectedAccountId;
          }

          // Clear tag selectors
          this.app.renderTransactionTagSelectors(null, null);
        }

        // Set up category change listener to update tag selectors
        var categorySelect = document.getElementById('transaction-category');
        if (categorySelect) {
          // Remove old listener if exists
          var oldListener = categorySelect.onchange;
          categorySelect.onchange = function () {
            if (oldListener) oldListener();
            var transactionId = document.getElementById('transaction-id').value;
            _this7.app.renderTransactionTagSelectors(categorySelect.value || null, transactionId || null);
          };
        }
        modal.style.display = 'flex';
      }
    }
  }, {
    key: "editTransaction",
    value: function editTransaction(id) {
      var transaction = this.transactions.find(function (t) {
        return t.id === id;
      });
      if (transaction) {
        this.showTransactionModal(transaction);
      }
    }
  }, {
    key: "saveTransaction",
    value: function () {
      var _saveTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
        var id, date, accountId, type, amount, description, vendor, categoryId, notes, data, response, error, _t7;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              // Get form values
              id = document.getElementById('transaction-id').value;
              date = document.getElementById('transaction-date').value;
              accountId = parseInt(document.getElementById('transaction-account').value);
              type = document.getElementById('transaction-type').value;
              amount = parseFloat(document.getElementById('transaction-amount').value);
              description = document.getElementById('transaction-description').value;
              vendor = document.getElementById('transaction-vendor').value;
              categoryId = document.getElementById('transaction-category').value;
              notes = document.getElementById('transaction-notes').value; // Build request data
              data = {
                date: date,
                accountId: accountId,
                type: type,
                amount: amount,
                description: description,
                vendor: vendor || null,
                categoryId: categoryId ? parseInt(categoryId) : null,
                notes: notes || null
              };
              _context7.p = 1;
              if (!id) {
                _context7.n = 3;
                break;
              }
              _context7.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(id)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(data)
              });
            case 2:
              response = _context7.v;
              _context7.n = 5;
              break;
            case 3:
              _context7.n = 4;
              return fetch(OC.generateUrl('/apps/budget/api/transactions'), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(data)
              });
            case 4:
              response = _context7.v;
            case 5:
              if (!response.ok) {
                _context7.n = 8;
                break;
              }
              OC.Notification.showTemporary(id ? 'Transaction updated' : 'Transaction created');
              this.app.hideModals();
              _context7.n = 6;
              return this.app.loadTransactions();
            case 6:
              _context7.n = 7;
              return this.app.loadAccounts();
            case 7:
              _context7.n = 10;
              break;
            case 8:
              _context7.n = 9;
              return response.json();
            case 9:
              error = _context7.v;
              throw new Error(error.error || 'Failed to save transaction');
            case 10:
              _context7.n = 12;
              break;
            case 11:
              _context7.p = 11;
              _t7 = _context7.v;
              console.error('Failed to save transaction:', _t7);
              OC.Notification.showTemporary(_t7.message || 'Failed to save transaction');
            case 12:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 11]]);
      }));
      function saveTransaction() {
        return _saveTransaction.apply(this, arguments);
      }
      return saveTransaction;
    }()
  }, {
    key: "deleteTransaction",
    value: function () {
      var _deleteTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(id) {
        var response, _t8;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              if (confirm('Are you sure you want to delete this transaction?')) {
                _context8.n = 1;
                break;
              }
              return _context8.a(2);
            case 1:
              _context8.p = 1;
              _context8.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(id)), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context8.v;
              if (response.ok) {
                OC.Notification.showTemporary('Transaction deleted');
                this.app.loadTransactions();
              }
              _context8.n = 4;
              break;
            case 3:
              _context8.p = 3;
              _t8 = _context8.v;
              console.error('Failed to delete transaction:', _t8);
              OC.Notification.showTemporary('Failed to delete transaction');
            case 4:
              return _context8.a(2);
          }
        }, _callee8, this, [[1, 3]]);
      }));
      function deleteTransaction(_x3) {
        return _deleteTransaction.apply(this, arguments);
      }
      return deleteTransaction;
    }() // Transaction matching and linking
  }, {
    key: "findTransactionMatches",
    value: function () {
      var _findTransactionMatches = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(transactionId) {
        var response, _t9;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              _context9.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/matches")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context9.v;
              if (response.ok) {
                _context9.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context9.n = 3;
              return response.json();
            case 3:
              return _context9.a(2, _context9.v);
            case 4:
              _context9.p = 4;
              _t9 = _context9.v;
              console.error('Failed to find matches:', _t9);
              throw _t9;
            case 5:
              return _context9.a(2);
          }
        }, _callee9, null, [[0, 4]]);
      }));
      function findTransactionMatches(_x4) {
        return _findTransactionMatches.apply(this, arguments);
      }
      return findTransactionMatches;
    }()
  }, {
    key: "linkTransactions",
    value: function () {
      var _linkTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(transactionId, targetId) {
        var response, error, _t0;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              _context0.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/link/").concat(targetId)), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context0.v;
              if (response.ok) {
                _context0.n = 3;
                break;
              }
              _context0.n = 2;
              return response.json();
            case 2:
              error = _context0.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context0.n = 4;
              return response.json();
            case 4:
              return _context0.a(2, _context0.v);
            case 5:
              _context0.p = 5;
              _t0 = _context0.v;
              console.error('Failed to link transactions:', _t0);
              throw _t0;
            case 6:
              return _context0.a(2);
          }
        }, _callee0, null, [[0, 5]]);
      }));
      function linkTransactions(_x5, _x6) {
        return _linkTransactions.apply(this, arguments);
      }
      return linkTransactions;
    }()
  }, {
    key: "unlinkTransaction",
    value: function () {
      var _unlinkTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(transactionId) {
        var response, error, _t1;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              _context1.p = 0;
              _context1.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/link")), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context1.v;
              if (response.ok) {
                _context1.n = 3;
                break;
              }
              _context1.n = 2;
              return response.json();
            case 2:
              error = _context1.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context1.n = 4;
              return response.json();
            case 4:
              return _context1.a(2, _context1.v);
            case 5:
              _context1.p = 5;
              _t1 = _context1.v;
              console.error('Failed to unlink transaction:', _t1);
              throw _t1;
            case 6:
              return _context1.a(2);
          }
        }, _callee1, null, [[0, 5]]);
      }));
      function unlinkTransaction(_x7) {
        return _unlinkTransaction.apply(this, arguments);
      }
      return unlinkTransaction;
    }()
  }, {
    key: "showMatchingModal",
    value: function () {
      var _showMatchingModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(transactionId) {
        var _this$transactions,
          _this$accounts2,
          _this8 = this;
        var transaction, modal, sourceDetails, loadingEl, emptyEl, listEl, account, currency, typeClass, result, _t10;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              transaction = (_this$transactions = this.transactions) === null || _this$transactions === void 0 ? void 0 : _this$transactions.find(function (t) {
                return t.id === transactionId;
              });
              if (transaction) {
                _context10.n = 1;
                break;
              }
              OC.Notification.showTemporary('Transaction not found');
              return _context10.a(2);
            case 1:
              modal = document.getElementById('matching-modal');
              sourceDetails = modal.querySelector('.source-details');
              loadingEl = document.getElementById('matching-loading');
              emptyEl = document.getElementById('matching-empty');
              listEl = document.getElementById('matching-list'); // Populate source transaction info
              account = (_this$accounts2 = this.accounts) === null || _this$accounts2 === void 0 ? void 0 : _this$accounts2.find(function (a) {
                return a.id === transaction.accountId;
              });
              currency = transaction.accountCurrency || (account === null || account === void 0 ? void 0 : account.currency) || this.getPrimaryCurrency();
              typeClass = transaction.type === 'credit' ? 'positive' : 'negative';
              sourceDetails.querySelector('.source-date').textContent = this.formatDate(transaction.date);
              sourceDetails.querySelector('.source-description').textContent = transaction.description;
              sourceDetails.querySelector('.source-amount').textContent = this.formatCurrency(transaction.amount, currency);
              sourceDetails.querySelector('.source-amount').className = "source-amount ".concat(typeClass);
              sourceDetails.querySelector('.source-account').textContent = (account === null || account === void 0 ? void 0 : account.name) || 'Unknown Account';

              // Show modal and loading state
              modal.style.display = 'flex';
              loadingEl.style.display = 'flex';
              emptyEl.style.display = 'none';
              listEl.innerHTML = '';
              _context10.p = 2;
              _context10.n = 3;
              return this.findTransactionMatches(transactionId);
            case 3:
              result = _context10.v;
              loadingEl.style.display = 'none';
              if (!(!result.matches || result.matches.length === 0)) {
                _context10.n = 4;
                break;
              }
              emptyEl.style.display = 'flex';
              return _context10.a(2);
            case 4:
              // Render matches
              listEl.innerHTML = result.matches.map(function (match) {
                var _this8$accounts;
                var matchAccount = (_this8$accounts = _this8.accounts) === null || _this8$accounts === void 0 ? void 0 : _this8$accounts.find(function (a) {
                  return a.id === match.accountId;
                });
                var matchCurrency = match.accountCurrency || (matchAccount === null || matchAccount === void 0 ? void 0 : matchAccount.currency) || _this8.getPrimaryCurrency();
                var matchTypeClass = match.type === 'credit' ? 'positive' : 'negative';
                return "\n                    <div class=\"match-item\" data-match-id=\"".concat(match.id, "\">\n                        <span class=\"match-date\">").concat(_this8.formatDate(match.date), "</span>\n                        <span class=\"match-description\">").concat(_this8.escapeHtml(match.description), "</span>\n                        <span class=\"match-amount ").concat(matchTypeClass, "\">").concat(_this8.formatCurrency(match.amount, matchCurrency), "</span>\n                        <span class=\"match-account\">").concat((matchAccount === null || matchAccount === void 0 ? void 0 : matchAccount.name) || 'Unknown', "</span>\n                        <button class=\"link-match-btn\" data-source-id=\"").concat(transactionId, "\" data-target-id=\"").concat(match.id, "\">\n                            Link as Transfer\n                        </button>\n                    </div>\n                ");
              }).join('');
              _context10.n = 6;
              break;
            case 5:
              _context10.p = 5;
              _t10 = _context10.v;
              loadingEl.style.display = 'none';
              emptyEl.style.display = 'flex';
              emptyEl.querySelector('p').textContent = 'Failed to search for matches. Please try again.';
            case 6:
              return _context10.a(2);
          }
        }, _callee10, this, [[2, 5]]);
      }));
      function showMatchingModal(_x8) {
        return _showMatchingModal.apply(this, arguments);
      }
      return showMatchingModal;
    }()
  }, {
    key: "handleLinkMatch",
    value: function () {
      var _handleLinkMatch = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(sourceId, targetId) {
        var _t11;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              _context11.p = 0;
              _context11.n = 1;
              return this.linkTransactions(sourceId, targetId);
            case 1:
              OC.Notification.showTemporary('Transactions linked as transfer');

              // Close modal and refresh transactions
              document.getElementById('matching-modal').style.display = 'none';
              _context11.n = 2;
              return this.app.loadTransactions();
            case 2:
              _context11.n = 4;
              break;
            case 3:
              _context11.p = 3;
              _t11 = _context11.v;
              OC.Notification.showTemporary(_t11.message || 'Failed to link transactions');
            case 4:
              return _context11.a(2);
          }
        }, _callee11, this, [[0, 3]]);
      }));
      function handleLinkMatch(_x9, _x0) {
        return _handleLinkMatch.apply(this, arguments);
      }
      return handleLinkMatch;
    }()
  }, {
    key: "handleUnlinkTransaction",
    value: function () {
      var _handleUnlinkTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(transactionId) {
        var _t12;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.p = _context12.n) {
            case 0:
              if (confirm('Are you sure you want to unlink this transaction from its transfer pair?')) {
                _context12.n = 1;
                break;
              }
              return _context12.a(2);
            case 1:
              _context12.p = 1;
              _context12.n = 2;
              return this.unlinkTransaction(transactionId);
            case 2:
              OC.Notification.showTemporary('Transaction unlinked');
              _context12.n = 3;
              return this.app.loadTransactions();
            case 3:
              _context12.n = 5;
              break;
            case 4:
              _context12.p = 4;
              _t12 = _context12.v;
              OC.Notification.showTemporary(_t12.message || 'Failed to unlink transaction');
            case 5:
              return _context12.a(2);
          }
        }, _callee12, this, [[1, 4]]);
      }));
      function handleUnlinkTransaction(_x1) {
        return _handleUnlinkTransaction.apply(this, arguments);
      }
      return handleUnlinkTransaction;
    }() // Transaction splits
  }, {
    key: "showSplitModal",
    value: function () {
      var _showSplitModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(transactionId) {
        var _this$transactions2,
          _this$accounts3,
          _this9 = this;
        var transaction, modal, isSplit, titleEl, transactionInfoEl, splitsContainer, account, currency, splits, _t13;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.p = _context13.n) {
            case 0:
              transaction = (_this$transactions2 = this.transactions) === null || _this$transactions2 === void 0 ? void 0 : _this$transactions2.find(function (t) {
                return t.id === transactionId;
              });
              if (transaction) {
                _context13.n = 1;
                break;
              }
              OC.Notification.showTemporary('Transaction not found');
              return _context13.a(2);
            case 1:
              modal = document.getElementById('split-modal');
              if (modal) {
                _context13.n = 2;
                break;
              }
              console.error('Split modal not found');
              return _context13.a(2);
            case 2:
              isSplit = transaction.isSplit || transaction.is_split;
              titleEl = document.getElementById('split-modal-title');
              transactionInfoEl = document.getElementById('split-transaction-info');
              splitsContainer = document.getElementById('splits-container'); // Set title and store transaction id
              titleEl.textContent = isSplit ? 'Edit Transaction Splits' : 'Split Transaction';
              modal.dataset.transactionId = transactionId;

              // Display transaction info
              account = (_this$accounts3 = this.accounts) === null || _this$accounts3 === void 0 ? void 0 : _this$accounts3.find(function (a) {
                return a.id === transaction.accountId;
              });
              currency = transaction.accountCurrency || (account === null || account === void 0 ? void 0 : account.currency) || this.getPrimaryCurrency();
              transactionInfoEl.innerHTML = "\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Date:</span>\n                <span>".concat(this.formatDate(transaction.date), "</span>\n            </div>\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Description:</span>\n                <span>").concat(this.escapeHtml(transaction.description), "</span>\n            </div>\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Total Amount:</span>\n                <span class=\"split-total-amount\">").concat(this.formatCurrency(transaction.amount, currency), "</span>\n            </div>\n        ");

              // Store transaction data for later
              modal.dataset.totalAmount = transaction.amount;
              modal.dataset.currency = currency;

              // Clear and set up splits container
              splitsContainer.innerHTML = '';
              if (!isSplit) {
                _context13.n = 7;
                break;
              }
              _context13.p = 3;
              _context13.n = 4;
              return this.getTransactionSplits(transactionId);
            case 4:
              splits = _context13.v;
              splits.forEach(function (split, index) {
                _this9.addSplitRow(splitsContainer, split, index === 0);
              });
              _context13.n = 6;
              break;
            case 5:
              _context13.p = 5;
              _t13 = _context13.v;
              console.error('Failed to load splits:', _t13);
              // Add two empty rows as fallback
              this.addSplitRow(splitsContainer, null, true);
              this.addSplitRow(splitsContainer, null, false);
            case 6:
              _context13.n = 8;
              break;
            case 7:
              // Start with two empty split rows
              this.addSplitRow(splitsContainer, null, true);
              this.addSplitRow(splitsContainer, null, false);
            case 8:
              this.updateSplitRemaining();
              modal.style.display = 'flex';
            case 9:
              return _context13.a(2);
          }
        }, _callee13, this, [[3, 5]]);
      }));
      function showSplitModal(_x10) {
        return _showSplitModal.apply(this, arguments);
      }
      return showSplitModal;
    }()
  }, {
    key: "addSplitRow",
    value: function addSplitRow(container) {
      var _this$transactions3,
        _this0 = this;
      var split = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var isFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var modal = document.getElementById('split-modal');
      var currency = (modal === null || modal === void 0 ? void 0 : modal.dataset.currency) || this.getPrimaryCurrency();
      var rowIndex = container.children.length;

      // Get the transaction to determine its type
      var transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
      var transaction = (_this$transactions3 = this.transactions) === null || _this$transactions3 === void 0 ? void 0 : _this$transactions3.find(function (t) {
        return t.id === transactionId;
      });
      var transactionType = (transaction === null || transaction === void 0 ? void 0 : transaction.type) || 'debit';
      var row = document.createElement('div');
      row.className = 'split-row';
      row.dataset.index = rowIndex;
      row.innerHTML = "\n            <div class=\"split-field split-amount-field\">\n                <label>Amount</label>\n                <input type=\"number\" class=\"split-amount\" step=\"0.01\" min=\"0.01\"\n                       value=\"".concat(split ? split.amount : '', "\" placeholder=\"0.00\" required>\n            </div>\n            <div class=\"split-field split-category-field\">\n                <label>Category</label>\n                <select class=\"split-category\">\n                    <option value=\"\">Uncategorized</option>\n                    ").concat(this.getCategoryOptions(split === null || split === void 0 ? void 0 : split.categoryId, transactionType), "\n                </select>\n            </div>\n            <div class=\"split-field split-description-field\">\n                <label>Description</label>\n                <input type=\"text\" class=\"split-description\" maxlength=\"255\"\n                       value=\"").concat((split === null || split === void 0 ? void 0 : split.description) || '', "\" placeholder=\"Optional note\">\n            </div>\n            <div class=\"split-actions\">\n                <button type=\"button\" class=\"split-remove-btn ").concat(isFirst ? 'disabled' : '', "\"\n                        ").concat(isFirst ? 'disabled' : '', " title=\"Remove split\">\n                    <span class=\"icon-delete\"></span>\n                </button>\n            </div>\n        ");

      // Add event listeners
      row.querySelector('.split-amount').addEventListener('input', function () {
        return _this0.updateSplitRemaining();
      });
      row.querySelector('.split-remove-btn').addEventListener('click', function (e) {
        if (!e.currentTarget.classList.contains('disabled')) {
          row.remove();
          _this0.updateSplitRemaining();
        }
      });
      container.appendChild(row);
    }
  }, {
    key: "getCategoryOptions",
    value: function getCategoryOptions() {
      var _this1 = this;
      var selectedId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var transactionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!this.categories) return '';

      // Determine category type based on transaction type
      // credit = income categories, debit = expense categories
      var categoryType = transactionType === 'credit' ? 'income' : 'expense';
      return this.categories.filter(function (c) {
        return c.type === categoryType;
      }).map(function (c) {
        return "<option value=\"".concat(c.id, "\" ").concat(c.id === selectedId ? 'selected' : '', ">").concat(_this1.escapeHtml(c.name), "</option>");
      }).join('');
    }
  }, {
    key: "updateSplitRemaining",
    value: function updateSplitRemaining() {
      var modal = document.getElementById('split-modal');
      var totalAmount = parseFloat((modal === null || modal === void 0 ? void 0 : modal.dataset.totalAmount) || 0);
      var currency = (modal === null || modal === void 0 ? void 0 : modal.dataset.currency) || this.getPrimaryCurrency();
      var remainingEl = document.getElementById('split-remaining');
      var remainingAmountEl = document.getElementById('split-remaining-amount');
      var allocatedAmount = Array.from(document.querySelectorAll('.split-amount')).reduce(function (sum, input) {
        return sum + (parseFloat(input.value) || 0);
      }, 0);
      var remaining = totalAmount - allocatedAmount;
      if (remainingEl && remainingAmountEl) {
        remainingAmountEl.textContent = this.formatCurrency(Math.abs(remaining), currency);
        remainingEl.classList.toggle('over', remaining < -0.01);
        remainingEl.classList.toggle('balanced', Math.abs(remaining) < 0.01);
      }
    }
  }, {
    key: "getTransactionSplits",
    value: function () {
      var _getTransactionSplits = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(transactionId) {
        var response;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              _context14.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context14.v;
              if (response.ok) {
                _context14.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context14.n = 3;
              return response.json();
            case 3:
              return _context14.a(2, _context14.v);
          }
        }, _callee14);
      }));
      function getTransactionSplits(_x11) {
        return _getTransactionSplits.apply(this, arguments);
      }
      return getTransactionSplits;
    }()
  }, {
    key: "saveSplits",
    value: function () {
      var _saveSplits = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
        var modal, transactionId, totalAmount, splits, splitTotal, response, error, _t14;
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.p = _context15.n) {
            case 0:
              modal = document.getElementById('split-modal');
              transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
              totalAmount = parseFloat((modal === null || modal === void 0 ? void 0 : modal.dataset.totalAmount) || 0); // Collect splits data
              splits = Array.from(document.querySelectorAll('.split-row')).map(function (row) {
                return {
                  amount: parseFloat(row.querySelector('.split-amount').value) || 0,
                  categoryId: parseInt(row.querySelector('.split-category').value) || null,
                  description: row.querySelector('.split-description').value.trim() || null
                };
              }).filter(function (split) {
                return split.amount > 0;
              }); // Validate
              if (!(splits.length < 2)) {
                _context15.n = 1;
                break;
              }
              OC.Notification.showTemporary('A split transaction must have at least 2 parts');
              return _context15.a(2);
            case 1:
              splitTotal = splits.reduce(function (sum, s) {
                return sum + s.amount;
              }, 0);
              if (!(Math.abs(splitTotal - totalAmount) > 0.01)) {
                _context15.n = 2;
                break;
              }
              OC.Notification.showTemporary("Split amounts (".concat(splitTotal.toFixed(2), ") must equal transaction amount (").concat(totalAmount.toFixed(2), ")"));
              return _context15.a(2);
            case 2:
              _context15.p = 2;
              _context15.n = 3;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  splits: splits
                })
              });
            case 3:
              response = _context15.v;
              if (response.ok) {
                _context15.n = 5;
                break;
              }
              _context15.n = 4;
              return response.json();
            case 4:
              error = _context15.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 5:
              this.hideSplitModal();
              OC.Notification.showTemporary('Transaction split successfully');
              _context15.n = 6;
              return this.app.loadTransactions();
            case 6:
              _context15.n = 8;
              break;
            case 7:
              _context15.p = 7;
              _t14 = _context15.v;
              console.error('Failed to save splits:', _t14);
              OC.Notification.showTemporary(_t14.message || 'Failed to save splits');
            case 8:
              return _context15.a(2);
          }
        }, _callee15, this, [[2, 7]]);
      }));
      function saveSplits() {
        return _saveSplits.apply(this, arguments);
      }
      return saveSplits;
    }()
  }, {
    key: "unsplitTransaction",
    value: function () {
      var _unsplitTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
        var modal, transactionId, response, error, _t15;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              modal = document.getElementById('split-modal');
              transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
              if (confirm('Are you sure you want to remove the split and revert to a single transaction?')) {
                _context16.n = 1;
                break;
              }
              return _context16.a(2);
            case 1:
              _context16.p = 1;
              _context16.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context16.v;
              if (response.ok) {
                _context16.n = 4;
                break;
              }
              _context16.n = 3;
              return response.json();
            case 3:
              error = _context16.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 4:
              this.hideSplitModal();
              OC.Notification.showTemporary('Transaction unsplit successfully');
              _context16.n = 5;
              return this.app.loadTransactions();
            case 5:
              _context16.n = 7;
              break;
            case 6:
              _context16.p = 6;
              _t15 = _context16.v;
              console.error('Failed to unsplit transaction:', _t15);
              OC.Notification.showTemporary(_t15.message || 'Failed to unsplit transaction');
            case 7:
              return _context16.a(2);
          }
        }, _callee16, this, [[1, 6]]);
      }));
      function unsplitTransaction() {
        return _unsplitTransaction.apply(this, arguments);
      }
      return unsplitTransaction;
    }()
  }, {
    key: "hideSplitModal",
    value: function hideSplitModal() {
      var modal = document.getElementById('split-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Bulk matching
  }, {
    key: "bulkMatchTransactions",
    value: function () {
      var _bulkMatchTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
        var response, error;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              _context17.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-match'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                }
              });
            case 1:
              response = _context17.v;
              if (response.ok) {
                _context17.n = 3;
                break;
              }
              _context17.n = 2;
              return response.json();
            case 2:
              error = _context17.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context17.n = 4;
              return response.json();
            case 4:
              return _context17.a(2, _context17.v);
          }
        }, _callee17);
      }));
      function bulkMatchTransactions() {
        return _bulkMatchTransactions.apply(this, arguments);
      }
      return bulkMatchTransactions;
    }()
  }, {
    key: "showBulkMatchModal",
    value: function () {
      var _showBulkMatchModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
        var _this10 = this;
        var modal, loadingEl, resultsEl, emptyEl, autoMatchedSection, needsReviewSection, autoMatchedList, needsReviewList, result, _t16;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.p = _context18.n) {
            case 0:
              modal = document.getElementById('bulk-match-modal');
              loadingEl = document.getElementById('bulk-match-loading');
              resultsEl = document.getElementById('bulk-match-results');
              emptyEl = document.getElementById('bulk-match-empty');
              autoMatchedSection = document.getElementById('auto-matched-section');
              needsReviewSection = document.getElementById('needs-review-section');
              autoMatchedList = document.getElementById('auto-matched-list');
              needsReviewList = document.getElementById('needs-review-list'); // Reset state
              loadingEl.style.display = 'flex';
              resultsEl.style.display = 'none';
              emptyEl.style.display = 'none';
              autoMatchedSection.style.display = 'none';
              needsReviewSection.style.display = 'none';
              autoMatchedList.innerHTML = '';
              needsReviewList.innerHTML = '';

              // Show modal
              modal.style.display = 'flex';
              _context18.p = 1;
              _context18.n = 2;
              return this.bulkMatchTransactions();
            case 2:
              result = _context18.v;
              loadingEl.style.display = 'none';
              resultsEl.style.display = 'block';

              // Update summary counts
              document.getElementById('auto-matched-count').textContent = result.stats.autoMatchedCount;
              document.getElementById('needs-review-count').textContent = result.stats.needsReviewCount;

              // Check if no results
              if (!(result.stats.autoMatchedCount === 0 && result.stats.needsReviewCount === 0)) {
                _context18.n = 3;
                break;
              }
              emptyEl.style.display = 'flex';
              return _context18.a(2);
            case 3:
              // Render auto-matched pairs
              if (result.autoMatched && result.autoMatched.length > 0) {
                autoMatchedSection.style.display = 'block';
                autoMatchedList.innerHTML = result.autoMatched.map(function (pair) {
                  return _this10.renderAutoMatchedPair(pair);
                }).join('');
              }

              // Render needs review items
              if (result.needsReview && result.needsReview.length > 0) {
                needsReviewSection.style.display = 'block';
                needsReviewList.innerHTML = result.needsReview.map(function (item, index) {
                  return _this10.renderNeedsReviewItem(item, index);
                }).join('');
              }
              _context18.n = 5;
              break;
            case 4:
              _context18.p = 4;
              _t16 = _context18.v;
              loadingEl.style.display = 'none';
              resultsEl.style.display = 'block';
              emptyEl.style.display = 'flex';
              emptyEl.querySelector('p').textContent = _t16.message || 'Failed to match transactions. Please try again.';
            case 5:
              return _context18.a(2);
          }
        }, _callee18, this, [[1, 4]]);
      }));
      function showBulkMatchModal() {
        return _showBulkMatchModal.apply(this, arguments);
      }
      return showBulkMatchModal;
    }()
  }, {
    key: "renderAutoMatchedPair",
    value: function renderAutoMatchedPair(pair) {
      var tx = pair.transaction;
      var linked = pair.linkedTo;
      var txCurrency = tx.account_currency || this.getPrimaryCurrency();
      var linkedCurrency = linked.accountCurrency || this.getPrimaryCurrency();
      var txTypeClass = tx.type === 'credit' ? 'positive' : 'negative';
      var linkedTypeClass = linked.type === 'credit' ? 'positive' : 'negative';
      return "\n            <div class=\"bulk-match-pair\" data-tx-id=\"".concat(tx.id, "\" data-linked-id=\"").concat(linked.id, "\">\n                <div class=\"pair-transaction\">\n                    <span class=\"pair-date\">").concat(this.formatDate(tx.date), "</span>\n                    <span class=\"pair-description\">").concat(this.escapeHtml(tx.description), "</span>\n                    <div class=\"pair-details\">\n                        <span class=\"pair-amount ").concat(txTypeClass, "\">").concat(this.formatCurrency(tx.amount, txCurrency), "</span>\n                        <span class=\"pair-account\">").concat(this.escapeHtml(tx.account_name), "</span>\n                    </div>\n                </div>\n                <span class=\"pair-arrow\">\u2194</span>\n                <div class=\"pair-transaction\">\n                    <span class=\"pair-date\">").concat(this.formatDate(linked.date), "</span>\n                    <span class=\"pair-description\">").concat(this.escapeHtml(linked.description), "</span>\n                    <div class=\"pair-details\">\n                        <span class=\"pair-amount ").concat(linkedTypeClass, "\">").concat(this.formatCurrency(linked.amount, linkedCurrency), "</span>\n                        <span class=\"pair-account\">").concat(this.escapeHtml(linked.accountName), "</span>\n                    </div>\n                </div>\n                <button class=\"undo-match-btn\" data-tx-id=\"").concat(tx.id, "\">Undo</button>\n            </div>\n        ");
    }
  }, {
    key: "renderNeedsReviewItem",
    value: function renderNeedsReviewItem(item, index) {
      var _this11 = this;
      var tx = item.transaction;
      var txCurrency = tx.account_currency || this.getPrimaryCurrency();
      var txTypeClass = tx.type === 'credit' ? 'positive' : 'negative';
      var matchesHtml = item.matches.map(function (match) {
        var matchCurrency = match.accountCurrency || _this11.getPrimaryCurrency();
        var matchTypeClass = match.type === 'credit' ? 'positive' : 'negative';
        return "\n                <label class=\"review-match-option\">\n                    <input type=\"radio\" name=\"review-match-".concat(index, "\" value=\"").concat(match.id, "\">\n                    <div class=\"match-info\">\n                        <div class=\"match-info-main\">\n                            <span class=\"match-date\">").concat(_this11.formatDate(match.date), "</span>\n                            <span class=\"match-description\">").concat(_this11.escapeHtml(match.description), "</span>\n                        </div>\n                        <span class=\"pair-amount ").concat(matchTypeClass, "\">").concat(_this11.formatCurrency(match.amount, matchCurrency), "</span>\n                        <span class=\"pair-account\">").concat(_this11.escapeHtml(match.accountName), "</span>\n                    </div>\n                </label>\n            ");
      }).join('');
      return "\n            <div class=\"bulk-review-item\" data-tx-id=\"".concat(tx.id, "\" data-index=\"").concat(index, "\">\n                <div class=\"review-source\">\n                    <div class=\"review-source-info\">\n                        <span class=\"review-source-date\">").concat(this.formatDate(tx.date), "</span>\n                        <span class=\"review-source-description\">").concat(this.escapeHtml(tx.description), "</span>\n                        <div class=\"review-source-details\">\n                            <span class=\"pair-amount ").concat(txTypeClass, "\">").concat(this.formatCurrency(tx.amount, txCurrency), "</span>\n                            <span class=\"pair-account\">").concat(this.escapeHtml(tx.account_name), "</span>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"review-matches-label\">Select a match (").concat(item.matchCount, " options):</div>\n                <div class=\"review-matches\">\n                    ").concat(matchesHtml, "\n                </div>\n                <button class=\"link-selected-btn\" data-tx-id=\"").concat(tx.id, "\" data-index=\"").concat(index, "\" disabled>Link Selected</button>\n            </div>\n        ");
    }
  }, {
    key: "handleBulkMatchUndo",
    value: function () {
      var _handleBulkMatchUndo = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(transactionId) {
        var pairEl, countEl, currentCount, autoMatchedList, _t17;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.p = _context19.n) {
            case 0:
              _context19.p = 0;
              _context19.n = 1;
              return this.unlinkTransaction(transactionId);
            case 1:
              // Remove the pair from the UI
              pairEl = document.querySelector(".bulk-match-pair[data-tx-id=\"".concat(transactionId, "\"]"));
              if (pairEl) {
                pairEl.remove();
              }

              // Update count
              countEl = document.getElementById('auto-matched-count');
              currentCount = parseInt(countEl.textContent);
              countEl.textContent = currentCount - 1;

              // Check if section is now empty
              autoMatchedList = document.getElementById('auto-matched-list');
              if (autoMatchedList.children.length === 0) {
                document.getElementById('auto-matched-section').style.display = 'none';
              }
              OC.Notification.showTemporary('Match undone');
              _context19.n = 3;
              break;
            case 2:
              _context19.p = 2;
              _t17 = _context19.v;
              OC.Notification.showTemporary(_t17.message || 'Failed to undo match');
            case 3:
              return _context19.a(2);
          }
        }, _callee19, this, [[0, 2]]);
      }));
      function handleBulkMatchUndo(_x12) {
        return _handleBulkMatchUndo.apply(this, arguments);
      }
      return handleBulkMatchUndo;
    }()
  }, {
    key: "handleBulkMatchLink",
    value: function () {
      var _handleBulkMatchLink = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(transactionId, index) {
        var reviewItem, selectedRadio, targetId, reviewCountEl, autoCountEl, currentReviewCount, currentAutoCount, needsReviewList, _t18;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.p = _context20.n) {
            case 0:
              reviewItem = document.querySelector(".bulk-review-item[data-index=\"".concat(index, "\"]"));
              selectedRadio = reviewItem.querySelector("input[name=\"review-match-".concat(index, "\"]:checked"));
              if (selectedRadio) {
                _context20.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select a match first');
              return _context20.a(2);
            case 1:
              targetId = parseInt(selectedRadio.value);
              _context20.p = 2;
              _context20.n = 3;
              return this.linkTransactions(transactionId, targetId);
            case 3:
              // Remove the review item from the UI
              reviewItem.remove();

              // Update counts
              reviewCountEl = document.getElementById('needs-review-count');
              autoCountEl = document.getElementById('auto-matched-count');
              currentReviewCount = parseInt(reviewCountEl.textContent);
              currentAutoCount = parseInt(autoCountEl.textContent);
              reviewCountEl.textContent = currentReviewCount - 1;
              autoCountEl.textContent = currentAutoCount + 1;

              // Check if review section is now empty
              needsReviewList = document.getElementById('needs-review-list');
              if (needsReviewList.children.length === 0) {
                document.getElementById('needs-review-section').style.display = 'none';
              }
              OC.Notification.showTemporary('Transactions linked');
              _context20.n = 5;
              break;
            case 4:
              _context20.p = 4;
              _t18 = _context20.v;
              OC.Notification.showTemporary(_t18.message || 'Failed to link transactions');
            case 5:
              return _context20.a(2);
          }
        }, _callee20, this, [[2, 4]]);
      }));
      function handleBulkMatchLink(_x13, _x14) {
        return _handleBulkMatchLink.apply(this, arguments);
      }
      return handleBulkMatchLink;
    }() // Inline editing (placeholder - full implementation would be extensive)
  }, {
    key: "setupInlineEditingListeners",
    value: function setupInlineEditingListeners() {
      var _this12 = this;
      var transactionsTable = document.getElementById('transactions-table');
      if (!transactionsTable) {
        return;
      }

      // Handle click on editable cells
      transactionsTable.addEventListener('click', function (e) {
        var cell = e.target.closest('.editable-cell');
        if (cell && !cell.classList.contains('editing')) {
          // Don't trigger if clicking on checkbox
          if (e.target.type === 'checkbox') return;
          _this12.startInlineEdit(cell);
        }
      });

      // Close any open inline editors when clicking outside
      document.addEventListener('click', function (e) {
        if (!e.target.closest('.editable-cell') && !e.target.closest('.category-autocomplete-dropdown')) {
          _this12.closeAllInlineEditors();
        }
      });
    }
  }, {
    key: "startInlineEdit",
    value: function startInlineEdit(cell) {
      // Close any other open editors first
      this.closeAllInlineEditors();
      var field = cell.dataset.field;
      var value = cell.dataset.value;
      var transactionId = parseInt(cell.dataset.transactionId);
      var transaction = this.transactions.find(function (t) {
        return t.id === transactionId;
      });
      if (!transaction) {
        return;
      }
      cell.classList.add('editing');
      this.currentEditingCell = cell;
      this.originalValue = value;
      switch (field) {
        case 'date':
          this.createDateEditor(cell, value);
          break;
        case 'description':
          this.createTextEditor(cell, value, 'description');
          break;
        case 'categoryId':
          this.createCategoryEditor(cell, value);
          break;
        case 'amount':
          this.createAmountEditor(cell, transaction);
          break;
        case 'accountId':
          this.createAccountEditor(cell, value);
          break;
        case 'tags':
          this.createTagsEditor(cell, transaction);
          break;
        default:
          this.createTextEditor(cell, value, field);
      }
    }
  }, {
    key: "createDateEditor",
    value: function createDateEditor(cell, value) {
      var input = document.createElement('input');
      input.type = 'date';
      input.className = 'inline-edit-input';
      input.value = value;
      this.setupEditorEvents(input, cell, 'date');
      cell.innerHTML = '';
      cell.appendChild(input);
      input.focus();
    }
  }, {
    key: "createTextEditor",
    value: function createTextEditor(cell, value, field) {
      var input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-edit-input';
      input.value = value || '';
      input.placeholder = field === 'description' ? 'Enter description...' : '';
      this.setupEditorEvents(input, cell, field);
      cell.innerHTML = '';
      cell.appendChild(input);
      input.focus();
      input.select();
    }
  }, {
    key: "createAmountEditor",
    value: function createAmountEditor(cell, transaction) {
      var container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.gap = '4px';

      // Type toggle
      var typeToggle = document.createElement('div');
      typeToggle.className = 'inline-type-toggle';
      var creditBtn = document.createElement('button');
      creditBtn.type = 'button';
      creditBtn.className = "inline-type-btn ".concat(transaction.type === 'credit' ? 'active' : '');
      creditBtn.textContent = '+';
      creditBtn.title = 'Income';
      var debitBtn = document.createElement('button');
      debitBtn.type = 'button';
      debitBtn.className = "inline-type-btn ".concat(transaction.type === 'debit' ? 'active' : '');
      debitBtn.textContent = '-';
      debitBtn.title = 'Expense';
      typeToggle.appendChild(creditBtn);
      typeToggle.appendChild(debitBtn);

      // Amount input
      var input = document.createElement('input');
      input.type = 'number';
      input.className = 'inline-edit-input';
      input.value = transaction.amount;
      input.step = '0.01';
      input.min = '0';
      input.dataset.type = transaction.type;

      // Type toggle events
      creditBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        creditBtn.classList.add('active');
        debitBtn.classList.remove('active');
        input.dataset.type = 'credit';
      });
      debitBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        debitBtn.classList.add('active');
        creditBtn.classList.remove('active');
        input.dataset.type = 'debit';
      });
      this.setupEditorEvents(input, cell, 'amount');
      container.appendChild(typeToggle);
      container.appendChild(input);
      cell.innerHTML = '';
      cell.appendChild(container);
      input.focus();
      input.select();
    }
  }, {
    key: "createCategoryEditor",
    value: function createCategoryEditor(cell, currentCategoryId) {
      var _this13 = this;
      var container = document.createElement('div');
      container.className = 'category-autocomplete';
      var input = document.createElement('input');
      input.type = 'text';
      input.className = 'category-autocomplete-input';
      input.placeholder = 'Type to search...';

      // Try hierarchical first (for categories page), then flat (for transactions page)
      var categoryData = null;
      if (this.categoryTree && this.categoryTree.length > 0) {
        categoryData = this.categoryTree;
      } else if (this.allCategories && this.allCategories.length > 0) {
        categoryData = this.allCategories;
      } else if (this.categories && this.categories.length > 0) {
        categoryData = this.categories;
      }

      // Build flat list of categories for search
      var flatCategories = categoryData ? this.getFlatCategoryList(categoryData) : [];

      // Set current category name as value
      var currentCategory = flatCategories.find(function (c) {
        return c.id === parseInt(currentCategoryId);
      });
      input.value = currentCategory ? currentCategory.name : '';
      input.dataset.categoryId = currentCategoryId || '';
      var dropdown = document.createElement('div');
      dropdown.className = 'category-autocomplete-dropdown';
      dropdown.style.display = 'none';
      container.appendChild(input);
      container.appendChild(dropdown);
      var showDropdown = function showDropdown() {
        var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var filtered = filter ? flatCategories.filter(function (c) {
          return c.name.toLowerCase().includes(filter.toLowerCase());
        }) : flatCategories;
        if (filtered.length === 0) {
          dropdown.innerHTML = '<div class="category-autocomplete-empty">No categories found</div>';
        } else {
          dropdown.innerHTML = filtered.map(function (c) {
            return "\n                    <div class=\"category-autocomplete-item ".concat(c.id === parseInt(input.dataset.categoryId) ? 'selected' : '', "\"\n                         data-category-id=\"").concat(c.id, "\"\n                         data-category-name=\"").concat(c.name, "\">\n                        ").concat(c.prefix).concat(c.name, "\n                    </div>\n                ");
          }).join('');
        }

        // Add "Uncategorized" option
        dropdown.innerHTML = "\n                <div class=\"category-autocomplete-item ".concat(!input.dataset.categoryId ? 'selected' : '', "\"\n                     data-category-id=\"\"\n                     data-category-name=\"\">\n                    Uncategorized\n                </div>\n            ") + dropdown.innerHTML;
        dropdown.style.display = 'block';
      };
      input.addEventListener('focus', function () {
        return showDropdown(input.value);
      });
      input.addEventListener('input', function () {
        return showDropdown(input.value);
      });

      // CRITICAL: Prevent input blur when clicking dropdown
      dropdown.addEventListener('mousedown', function (e) {
        e.preventDefault();
      });
      dropdown.addEventListener('click', function (e) {
        e.stopPropagation();
        var item = e.target.closest('.category-autocomplete-item');
        if (item) {
          input.dataset.categoryId = item.dataset.categoryId;
          input.value = item.dataset.categoryName;
          dropdown.style.display = 'none';
          _this13.saveInlineEdit(cell, 'categoryId', item.dataset.categoryId);
        }
      });
      input.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
          _this13.cancelInlineEdit(cell);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          dropdown.style.display = 'none';
          _this13.saveInlineEdit(cell, 'categoryId', input.dataset.categoryId);
        } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
          e.preventDefault();
          _this13.navigateCategoryDropdown(dropdown, e.key === 'ArrowDown' ? 1 : -1, input);
        }
      });
      input.addEventListener('blur', function () {
        setTimeout(function () {
          if (!container.contains(document.activeElement)) {
            dropdown.style.display = 'none';
            if (input.dataset.categoryId !== (currentCategoryId || '')) {
              _this13.saveInlineEdit(cell, 'categoryId', input.dataset.categoryId);
            } else {
              _this13.cancelInlineEdit(cell);
            }
          }
        }, 200);
      });
      cell.innerHTML = '';
      cell.appendChild(container);
      input.focus();
      input.select();
      showDropdown();
    }
  }, {
    key: "navigateCategoryDropdown",
    value: function navigateCategoryDropdown(dropdown, direction, input) {
      var items = dropdown.querySelectorAll('.category-autocomplete-item');
      if (items.length === 0) return;
      var currentHighlighted = dropdown.querySelector('.category-autocomplete-item.highlighted');
      var nextIndex = 0;
      if (currentHighlighted) {
        currentHighlighted.classList.remove('highlighted');
        var currentIndex = Array.from(items).indexOf(currentHighlighted);
        nextIndex = currentIndex + direction;
        if (nextIndex < 0) nextIndex = items.length - 1;
        if (nextIndex >= items.length) nextIndex = 0;
      } else {
        nextIndex = direction === 1 ? 0 : items.length - 1;
      }
      items[nextIndex].classList.add('highlighted');
      items[nextIndex].scrollIntoView({
        block: 'nearest'
      });
      input.dataset.categoryId = items[nextIndex].dataset.categoryId;
    }
  }, {
    key: "createAccountEditor",
    value: function createAccountEditor(cell, currentAccountId) {
      var _this$accounts4,
        _this14 = this;
      var select = document.createElement('select');
      select.className = 'inline-edit-select';
      (_this$accounts4 = this.accounts) === null || _this$accounts4 === void 0 || _this$accounts4.forEach(function (account) {
        var option = document.createElement('option');
        option.value = account.id;
        option.textContent = account.name;
        option.selected = account.id === parseInt(currentAccountId);
        select.appendChild(option);
      });
      select.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
          _this14.cancelInlineEdit(cell);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          _this14.saveInlineEdit(cell, 'accountId', select.value);
        }
      });
      select.addEventListener('change', function () {
        _this14.saveInlineEdit(cell, 'accountId', select.value);
      });
      select.addEventListener('blur', function () {
        setTimeout(function () {
          if (cell.classList.contains('editing')) {
            _this14.cancelInlineEdit(cell);
          }
        }, 100);
      });
      cell.innerHTML = '';
      cell.appendChild(select);
      select.focus();
    }
  }, {
    key: "createTagsEditor",
    value: function () {
      var _createTagsEditor = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(cell, transaction) {
        var _this15 = this;
        var categoryId, tagSets, currentTagIds, selectedTags, container, input, dropdown, allTags, renderDropdown, _t19;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.p = _context21.n) {
            case 0:
              categoryId = transaction.categoryId;
              if (categoryId) {
                _context21.n = 1;
                break;
              }
              cell.innerHTML = '<span style="color: var(--color-text-maxcontrast); font-size: 11px; font-style: italic;">Select category first</span>';
              setTimeout(function () {
                return _this15.cancelInlineEdit(cell);
              }, 1500);
              return _context21.a(2);
            case 1:
              cell.innerHTML = '<span style="color: var(--color-text-maxcontrast); font-size: 11px;">Loading...</span>';
              _context21.p = 2;
              _context21.n = 3;
              return this.loadTagSetsForCategory(categoryId);
            case 3:
              tagSets = _context21.v;
              if (!(tagSets.length === 0)) {
                _context21.n = 4;
                break;
              }
              cell.innerHTML = '<span style="color: var(--color-text-maxcontrast); font-size: 11px; font-style: italic;">No tag sets</span>';
              setTimeout(function () {
                return _this15.cancelInlineEdit(cell);
              }, 1500);
              return _context21.a(2);
            case 4:
              currentTagIds = this.app.getTransactionTagIds(transaction.id);
              selectedTags = new Set(currentTagIds);
              container = document.createElement('div');
              container.className = 'tags-autocomplete';
              input = document.createElement('input');
              input.type = 'text';
              input.className = 'tags-autocomplete-input';
              input.placeholder = 'Type to filter tags...';
              dropdown = document.createElement('div');
              dropdown.className = 'tags-autocomplete-dropdown';
              dropdown.style.display = 'none';
              container.appendChild(input);
              container.appendChild(dropdown);
              allTags = [];
              tagSets.forEach(function (tagSet) {
                tagSet.tags.forEach(function (tag) {
                  allTags.push({
                    id: tag.id,
                    name: tag.name,
                    color: tag.color,
                    tagSetName: tagSet.name,
                    tagSetId: tagSet.id
                  });
                });
              });
              renderDropdown = function renderDropdown() {
                var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
                var filtered = filter ? allTags.filter(function (t) {
                  return t.name.toLowerCase().includes(filter.toLowerCase()) || t.tagSetName.toLowerCase().includes(filter.toLowerCase());
                }) : allTags;
                var grouped = {};
                filtered.forEach(function (tag) {
                  if (!grouped[tag.tagSetId]) {
                    grouped[tag.tagSetId] = {
                      name: tag.tagSetName,
                      tags: []
                    };
                  }
                  grouped[tag.tagSetId].tags.push(tag);
                });
                var html = '';
                Object.values(grouped).forEach(function (group) {
                  html += "<div class=\"tags-group-header\">".concat(_this15.escapeHtml(group.name), "</div>");
                  group.tags.forEach(function (tag) {
                    var isSelected = selectedTags.has(tag.id);
                    html += "\n                            <div class=\"tags-autocomplete-item ".concat(isSelected ? 'selected' : '', "\"\n                                 data-tag-id=\"").concat(tag.id, "\">\n                                <span class=\"tag-chip\"\n                                      style=\"display: inline-flex; align-items: center; background-color: ").concat(_this15.escapeHtml(tag.color), "; color: white;\n                                             padding: 2px 6px; border-radius: 10px; font-size: 10px; line-height: 14px; margin-right: 4px;\">\n                                    ").concat(_this15.escapeHtml(tag.name), "\n                                </span>\n                                <span class=\"tag-check\">").concat(isSelected ? '' : '', "</span>\n                            </div>\n                        ");
                  });
                });
                dropdown.innerHTML = html || '<div class="tags-autocomplete-empty">No tags found</div>';
                dropdown.style.display = 'block';
              };
              input.addEventListener('focus', function () {
                return renderDropdown(input.value);
              });
              input.addEventListener('input', function () {
                return renderDropdown(input.value);
              });
              dropdown.addEventListener('mousedown', function (e) {
                e.preventDefault();
              });
              dropdown.addEventListener('click', function (e) {
                e.stopPropagation();
                var item = e.target.closest('.tags-autocomplete-item');
                if (item) {
                  var tagId = parseInt(item.dataset.tagId);
                  var clickedTag = allTags.find(function (t) {
                    return t.id === tagId;
                  });
                  if (!clickedTag) return;
                  var tagsFromSameSet = allTags.filter(function (t) {
                    return t.tagSetId === clickedTag.tagSetId;
                  });
                  tagsFromSameSet.forEach(function (t) {
                    if (t.id !== tagId) {
                      selectedTags["delete"](t.id);
                    }
                  });
                  if (selectedTags.has(tagId)) {
                    selectedTags["delete"](tagId);
                  } else {
                    selectedTags.add(tagId);
                  }
                  renderDropdown(input.value);
                }
              });
              input.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                  _this15.cancelInlineEdit(cell);
                } else if (e.key === 'Enter') {
                  e.preventDefault();
                  _this15.saveTagsFromEditor(cell, selectedTags, transaction.id);
                }
              });
              input.addEventListener('blur', function () {
                setTimeout(function () {
                  if (cell.classList.contains('editing')) {
                    _this15.saveTagsFromEditor(cell, selectedTags, transaction.id);
                  }
                }, 200);
              });
              cell.innerHTML = '';
              cell.appendChild(container);
              input.focus();
              renderDropdown();
              _context21.n = 6;
              break;
            case 5:
              _context21.p = 5;
              _t19 = _context21.v;
              console.error('Failed to load tag sets:', _t19);
              cell.innerHTML = '<span style="color: var(--color-error); font-size: 11px;">Error loading tags</span>';
              setTimeout(function () {
                return _this15.cancelInlineEdit(cell);
              }, 1500);
            case 6:
              return _context21.a(2);
          }
        }, _callee21, this, [[2, 5]]);
      }));
      function createTagsEditor(_x15, _x16) {
        return _createTagsEditor.apply(this, arguments);
      }
      return createTagsEditor;
    }()
  }, {
    key: "saveTagsFromEditor",
    value: function () {
      var _saveTagsFromEditor = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22(cell, selectedTags, transactionId) {
        var tagIds, response, cellDisplay, _t20;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.p = _context22.n) {
            case 0:
              tagIds = Array.from(selectedTags);
              _context22.p = 1;
              _context22.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/tags")), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  tagIds: tagIds
                })
              });
            case 2:
              response = _context22.v;
              if (!response.ok) {
                _context22.n = 4;
                break;
              }
              _context22.n = 3;
              return this.app.loadTransactionTags(transactionId);
            case 3:
              this.cancelInlineEdit(cell);
              cellDisplay = cell.querySelector('.cell-display');
              if (cellDisplay) {
                cellDisplay.innerHTML = this.app.renderTransactionTags(transactionId);
              }
              _context22.n = 5;
              break;
            case 4:
              console.error('Failed to save tags');
              this.cancelInlineEdit(cell);
            case 5:
              _context22.n = 7;
              break;
            case 6:
              _context22.p = 6;
              _t20 = _context22.v;
              console.error('Failed to save tags:', _t20);
              this.cancelInlineEdit(cell);
            case 7:
              return _context22.a(2);
          }
        }, _callee22, this, [[1, 6]]);
      }));
      function saveTagsFromEditor(_x17, _x18, _x19) {
        return _saveTagsFromEditor.apply(this, arguments);
      }
      return saveTagsFromEditor;
    }()
  }, {
    key: "loadTagSetsForCategory",
    value: function () {
      var _loadTagSetsForCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23(categoryId) {
        var response, _t21;
        return _regenerator().w(function (_context23) {
          while (1) switch (_context23.p = _context23.n) {
            case 0:
              _context23.p = 0;
              _context23.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/tag-sets?categoryId=".concat(categoryId)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context23.v;
              if (response.ok) {
                _context23.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context23.n = 3;
              return response.json();
            case 3:
              return _context23.a(2, _context23.v);
            case 4:
              _context23.p = 4;
              _t21 = _context23.v;
              console.error('Failed to load tag sets:', _t21);
              return _context23.a(2, []);
          }
        }, _callee23, null, [[0, 4]]);
      }));
      function loadTagSetsForCategory(_x20) {
        return _loadTagSetsForCategory.apply(this, arguments);
      }
      return loadTagSetsForCategory;
    }()
  }, {
    key: "setupEditorEvents",
    value: function setupEditorEvents(input, cell, field) {
      var _this16 = this;
      input.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
          _this16.cancelInlineEdit(cell);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (field === 'amount') {
            var type = input.dataset.type;
            _this16.saveInlineEdit(cell, field, input.value, {
              type: type
            });
          } else {
            _this16.saveInlineEdit(cell, field, input.value);
          }
        }
      });
      input.addEventListener('blur', function (e) {
        var _e$relatedTarget;
        if ((_e$relatedTarget = e.relatedTarget) !== null && _e$relatedTarget !== void 0 && _e$relatedTarget.closest('.inline-type-toggle')) {
          return;
        }
        setTimeout(function () {
          if (cell.classList.contains('editing')) {
            if (field === 'amount') {
              var type = input.dataset.type;
              _this16.saveInlineEdit(cell, field, input.value, {
                type: type
              });
            } else {
              _this16.saveInlineEdit(cell, field, input.value);
            }
          }
        }, 100);
      });
    }
  }, {
    key: "saveInlineEdit",
    value: function () {
      var _saveInlineEdit = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee24(cell, field, value) {
        var extra,
          transactionId,
          transaction,
          hasChanged,
          newAmount,
          newType,
          newCatId,
          updateData,
          response,
          result,
          _args24 = arguments,
          _t22;
        return _regenerator().w(function (_context24) {
          while (1) switch (_context24.p = _context24.n) {
            case 0:
              extra = _args24.length > 3 && _args24[3] !== undefined ? _args24[3] : {};
              transactionId = parseInt(cell.dataset.transactionId);
              transaction = this.transactions.find(function (t) {
                return t.id === transactionId;
              });
              if (transaction) {
                _context24.n = 1;
                break;
              }
              this.cancelInlineEdit(cell);
              return _context24.a(2);
            case 1:
              // Check if value actually changed
              hasChanged = false;
              if (field === 'amount') {
                newAmount = parseFloat(value);
                newType = extra.type || transaction.type;
                hasChanged = newAmount !== transaction.amount || newType !== transaction.type;
              } else if (field === 'categoryId') {
                newCatId = value === '' ? null : parseInt(value);
                hasChanged = newCatId !== transaction.categoryId;
              } else if (field === 'accountId') {
                hasChanged = parseInt(value) !== transaction.accountId;
              } else {
                hasChanged = value !== (transaction[field] || '');
              }
              if (hasChanged) {
                _context24.n = 2;
                break;
              }
              this.cancelInlineEdit(cell);
              return _context24.a(2);
            case 2:
              cell.classList.add('cell-saving');
              updateData = {};
              if (field === 'amount') {
                updateData.amount = parseFloat(value);
                if (extra.type) {
                  updateData.type = extra.type;
                }
              } else if (field === 'categoryId') {
                updateData.categoryId = value === '' ? null : parseInt(value);
              } else if (field === 'accountId') {
                updateData.accountId = parseInt(value);
              } else {
                updateData[field] = value;
              }
              _context24.p = 3;
              _context24.n = 4;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId)), {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify(updateData)
              });
            case 4:
              response = _context24.v;
              if (!response.ok) {
                _context24.n = 7;
                break;
              }
              _context24.n = 5;
              return response.json();
            case 5:
              result = _context24.v;
              Object.assign(transaction, result);
              if (!(field === 'accountId')) {
                _context24.n = 6;
                break;
              }
              _context24.n = 6;
              return this.app.loadAccounts();
            case 6:
              this.app.renderEnhancedTransactionsTable();
              this.app.applyColumnVisibility();
              OC.Notification.showTemporary('Transaction updated');
              _context24.n = 8;
              break;
            case 7:
              throw new Error('Update failed');
            case 8:
              _context24.n = 10;
              break;
            case 9:
              _context24.p = 9;
              _t22 = _context24.v;
              console.error('Failed to save inline edit:', _t22);
              OC.Notification.showTemporary('Failed to update transaction');
              this.cancelInlineEdit(cell);
            case 10:
              return _context24.a(2);
          }
        }, _callee24, this, [[3, 9]]);
      }));
      function saveInlineEdit(_x21, _x22, _x23) {
        return _saveInlineEdit.apply(this, arguments);
      }
      return saveInlineEdit;
    }()
  }, {
    key: "cancelInlineEdit",
    value: function cancelInlineEdit(cell) {
      if (!cell || !cell.classList.contains('editing')) return;

      // Re-render the table to restore original display
      this.app.renderEnhancedTransactionsTable();
      this.app.applyColumnVisibility();
      this.currentEditingCell = null;
      this.originalValue = null;
    }
  }, {
    key: "closeAllInlineEditors",
    value: function closeAllInlineEditors() {
      var _this17 = this;
      var editingCells = document.querySelectorAll('.editable-cell.editing');
      editingCells.forEach(function (cell) {
        _this17.cancelInlineEdit(cell);
      });
    }

    // Helper methods for categories
  }, {
    key: "getFlatCategoryList",
    value: function getFlatCategoryList() {
      var categories = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var cats = categories || this.categories || [];
      var result = [];
      var _iterator = _createForOfIteratorHelper(cats),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var cat = _step.value;
          result.push({
            id: cat.id,
            name: cat.name,
            prefix: prefix
          });
          if (cat.children && cat.children.length > 0) {
            result = result.concat(this.getFlatCategoryList(cat.children, prefix + '  '));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return result;
    }
  }]);
}();


/***/ }),

/***/ "./src/utils/api.js":
/*!**************************!*\
  !*** ./src/utils/api.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ApiClient)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * API Client wrapper for centralized fetch calls with auth headers
 */
var ApiClient = /*#__PURE__*/function () {
  function ApiClient(appState) {
    _classCallCheck(this, ApiClient);
    this.state = appState;
  }

  /**
   * Get auth headers including session token if available
   * @returns {object} Headers object
   */
  return _createClass(ApiClient, [{
    key: "getHeaders",
    value: function getHeaders() {
      var headers = {
        'Content-Type': 'application/json',
        'requesttoken': OC.requestToken
      };

      // Add session token if password protection is enabled
      var sessionToken = this.state ? this.state.get('sessionToken') : null;
      if (sessionToken) {
        headers['X-Budget-Session'] = sessionToken;
      }
      return headers;
    }

    /**
     * Perform GET request
     * @param {string} url - API endpoint (relative URL)
     * @param {object} options - Additional fetch options
     * @returns {Promise} Response data
     */
  }, {
    key: "get",
    value: (function () {
      var _get = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
        var options,
          response,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.n = 1;
              return fetch(OC.generateUrl(url), _objectSpread({
                method: 'GET',
                headers: _objectSpread(_objectSpread({}, this.getHeaders()), options.headers)
              }, options));
            case 1:
              response = _context.v;
              if (response.ok) {
                _context.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              return _context.a(2, response.json());
          }
        }, _callee, this);
      }));
      function get(_x) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
    /**
     * Perform POST request
     * @param {string} url - API endpoint (relative URL)
     * @param {object} data - Data to send in request body
     * @param {object} options - Additional fetch options
     * @returns {Promise} Response data
     */
    )
  }, {
    key: "post",
    value: (function () {
      var _post = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(url) {
        var data,
          options,
          response,
          _args2 = arguments;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              data = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};
              _context2.n = 1;
              return fetch(OC.generateUrl(url), _objectSpread({
                method: 'POST',
                headers: _objectSpread(_objectSpread({}, this.getHeaders()), options.headers),
                body: JSON.stringify(data)
              }, options));
            case 1:
              response = _context2.v;
              if (response.ok) {
                _context2.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              return _context2.a(2, response.json());
          }
        }, _callee2, this);
      }));
      function post(_x2) {
        return _post.apply(this, arguments);
      }
      return post;
    }()
    /**
     * Perform PUT request
     * @param {string} url - API endpoint (relative URL)
     * @param {object} data - Data to send in request body
     * @param {object} options - Additional fetch options
     * @returns {Promise} Response data
     */
    )
  }, {
    key: "put",
    value: (function () {
      var _put = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(url) {
        var data,
          options,
          response,
          _args3 = arguments;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              data = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              _context3.n = 1;
              return fetch(OC.generateUrl(url), _objectSpread({
                method: 'PUT',
                headers: _objectSpread(_objectSpread({}, this.getHeaders()), options.headers),
                body: JSON.stringify(data)
              }, options));
            case 1:
              response = _context3.v;
              if (response.ok) {
                _context3.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              return _context3.a(2, response.json());
          }
        }, _callee3, this);
      }));
      function put(_x3) {
        return _put.apply(this, arguments);
      }
      return put;
    }()
    /**
     * Perform DELETE request
     * @param {string} url - API endpoint (relative URL)
     * @param {object} options - Additional fetch options
     * @returns {Promise} Response data
     */
    )
  }, {
    key: "delete",
    value: (function () {
      var _delete2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(url) {
        var options,
          response,
          _args4 = arguments;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              _context4.n = 1;
              return fetch(OC.generateUrl(url), _objectSpread({
                method: 'DELETE',
                headers: _objectSpread(_objectSpread({}, this.getHeaders()), options.headers)
              }, options));
            case 1:
              response = _context4.v;
              if (response.ok) {
                _context4.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              return _context4.a(2, response.json());
          }
        }, _callee4, this);
      }));
      function _delete(_x4) {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
    /**
     * Upload file (multipart/form-data)
     * @param {string} url - API endpoint (relative URL)
     * @param {FormData} formData - Form data with file
     * @returns {Promise} Response data
     */
    )
  }, {
    key: "upload",
    value: (function () {
      var _upload = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(url, formData) {
        var headers, sessionToken, response;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              headers = {
                'requesttoken': OC.requestToken
              }; // Add session token if available
              sessionToken = this.state ? this.state.get('sessionToken') : null;
              if (sessionToken) {
                headers['X-Budget-Session'] = sessionToken;
              }
              _context5.n = 1;
              return fetch(OC.generateUrl(url), {
                method: 'POST',
                headers: headers,
                body: formData
              });
            case 1:
              response = _context5.v;
              if (response.ok) {
                _context5.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 2:
              return _context5.a(2, response.json());
          }
        }, _callee5, this);
      }));
      function upload(_x5, _x6) {
        return _upload.apply(this, arguments);
      }
      return upload;
    }())
  }]);
}();


/***/ }),

/***/ "./src/utils/dom.js":
/*!**************************!*\
  !*** ./src/utils/dom.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeModal: () => (/* binding */ closeModal),
/* harmony export */   escapeHtml: () => (/* binding */ escapeHtml)
/* harmony export */ });
/**
 * DOM manipulation and HTML utilities
 */

/**
 * Escape HTML special characters to prevent XSS
 * @param {string} str - String to escape
 * @returns {string} Escaped HTML string
 */
function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * Close a modal by hiding it and setting ARIA attributes
 * @param {HTMLElement} modal - Modal element to close
 */
function closeModal(modal) {
  if (modal) {
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
  }
}

/***/ }),

/***/ "./src/utils/formatters.js":
/*!*********************************!*\
  !*** ./src/utils/formatters.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatAccountType: () => (/* binding */ formatAccountType),
/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),
/* harmony export */   formatCurrencyCompact: () => (/* binding */ formatCurrencyCompact),
/* harmony export */   formatDate: () => (/* binding */ formatDate),
/* harmony export */   getAccountsHash: () => (/* binding */ getAccountsHash),
/* harmony export */   getPrimaryCurrency: () => (/* binding */ getPrimaryCurrency)
/* harmony export */ });
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * Formatting utilities for currency, dates, and numbers
 * All functions are pure - they accept required data as parameters
 */

/**
 * Format currency amount according to user settings
 * @param {number} amount - Amount to format
 * @param {string|null} currency - Currency code (e.g., 'USD', 'EUR')
 * @param {object} settings - User settings object
 * @returns {string} Formatted currency string
 */
function formatCurrency(amount, currency, settings) {
  var _settings$number_form;
  var currencyCode = currency || getPrimaryCurrency([], settings);
  var decimals = parseInt(settings.number_format_decimals) || 2;
  var decimalSep = settings.number_format_decimal_sep || '.';
  var thousandsSep = (_settings$number_form = settings.number_format_thousands_sep) !== null && _settings$number_form !== void 0 ? _settings$number_form : ',';

  // Format the number manually using user settings
  var absAmount = Math.abs(amount);
  var parts = absAmount.toFixed(decimals).split('.');
  var intPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSep);
  var decPart = parts[1] || '';

  // Get currency symbol
  var symbols = {
    'USD': '$',
    'EUR': '',
    'GBP': '',
    'CAD': 'C$',
    'AUD': 'A$',
    'JPY': '',
    'CHF': 'CHF',
    'CNY': '',
    'INR': '',
    'MXN': '$',
    'BRL': 'R$',
    'KRW': '',
    'SGD': 'S$',
    'HKD': 'HK$',
    'NOK': 'kr',
    'SEK': 'kr',
    'DKK': 'kr',
    'NZD': 'NZ$',
    'ZAR': 'R',
    'RUB': ''
  };
  var symbol = symbols[currencyCode] || currencyCode;
  var formattedNumber = decimals > 0 ? "".concat(intPart).concat(decimalSep).concat(decPart) : intPart;
  var sign = amount < 0 ? '-' : '';
  return "".concat(sign).concat(symbol).concat(formattedNumber);
}

/**
 * Get primary currency based on account balances
 * @param {array} accounts - Array of account objects
 * @param {object} settings - User settings object
 * @returns {string} Primary currency code
 */
function getPrimaryCurrency(accounts, settings) {
  // Get default currency from settings (matches backend SettingController default of 'GBP')
  var defaultCurrency = (settings === null || settings === void 0 ? void 0 : settings.default_currency) || 'GBP';

  // Default fallback to user's setting
  if (!Array.isArray(accounts) || accounts.length === 0) {
    return defaultCurrency;
  }

  // Weight currencies by absolute balance (same logic as backend ForecastService)
  var currencyWeights = {};
  accounts.forEach(function (account) {
    var currency = account.currency || defaultCurrency;
    var balance = Math.abs(parseFloat(account.balance) || 0);
    currencyWeights[currency] = (currencyWeights[currency] || 0) + balance;
  });

  // Find currency with highest weight
  var primaryCurrency = defaultCurrency;
  var maxWeight = 0;
  for (var _i = 0, _Object$entries = Object.entries(currencyWeights); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      currency = _Object$entries$_i[0],
      weight = _Object$entries$_i[1];
    if (weight > maxWeight) {
      maxWeight = weight;
      primaryCurrency = currency;
    }
  }
  return primaryCurrency;
}

/**
 * Format date string according to user settings
 * @param {string} dateStr - Date string in YYYY-MM-DD format
 * @param {object} settings - User settings object
 * @returns {string} Formatted date string
 */
function formatDate(dateStr, settings) {
  if (!dateStr) return '';

  // Parse date string directly to avoid timezone conversion issues
  // Assumes dateStr is in YYYY-MM-DD format from backend
  var parts = dateStr.split(/[-/]/);
  if (parts.length !== 3) {
    // Fallback for unexpected format
    return dateStr;
  }
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10);
  var day = parseInt(parts[2], 10);

  // Use user's date format preference from settings
  var format = (settings === null || settings === void 0 ? void 0 : settings.date_format) || 'Y-m-d';

  // Format the date according to PHP date format codes
  var pad = function pad(num) {
    return String(num).padStart(2, '0');
  };
  var monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  var monthName = monthNames[month - 1];

  // Convert PHP date format to actual date string
  return format.replace('Y', year).replace('m', pad(month)).replace('d', pad(day)).replace('M', monthName).replace('j', day);
}

/**
 * Format account type for display
 * @param {string} type - Account type code
 * @returns {string} Formatted account type name
 */
function formatAccountType(type) {
  if (!type) return '';
  var typeNames = {
    checking: 'Checking',
    savings: 'Savings',
    credit_card: 'Credit Card',
    investment: 'Investment',
    cash: 'Cash',
    loan: 'Loan',
    mortgage: 'Mortgage',
    pension: 'Pension'
  };
  return typeNames[type] || type.replace(/_/g, ' ').replace(/\b\w/g, function (c) {
    return c.toUpperCase();
  });
}

/**
 * Format currency in compact form (with K/M suffix)
 * @param {number} value - Amount to format
 * @param {string|null} currency - Currency code
 * @param {object} settings - User settings object
 * @returns {string} Compact formatted currency string
 */
function formatCurrencyCompact(value, currency, settings) {
  if (Math.abs(value) >= 1000000) {
    return formatCurrency(value / 1000000, currency, settings).replace(/[\d,.]+/, function (m) {
      return parseFloat(m).toFixed(1);
    }) + 'M';
  }
  if (Math.abs(value) >= 1000) {
    return formatCurrency(value / 1000, currency, settings).replace(/[\d,.]+/, function (m) {
      return parseFloat(m).toFixed(1);
    }) + 'K';
  }
  return formatCurrency(value, currency, settings);
}

/**
 * Generate hash of accounts for caching purposes
 * @param {array} accounts - Array of account objects
 * @returns {string} Hash string
 */
function getAccountsHash(accounts) {
  if (!Array.isArray(accounts)) return '';
  return accounts.map(function (a) {
    return "".concat(a.id, ":").concat(a.currency, ":").concat(a.balance);
  }).join('|');
}

/***/ }),

/***/ "./src/utils/helpers.js":
/*!******************************!*\
  !*** ./src/utils/helpers.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debounce: () => (/* binding */ debounce)
/* harmony export */ });
/**
 * General utility helper functions
 */

/**
 * Debounce function calls to limit execution rate
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, wait) {
  var timeout;
  return function executedFunction() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var later = function later() {
      clearTimeout(timeout);
      func.apply(void 0, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/***/ }),

/***/ "./src/utils/validators.js":
/*!*********************************!*\
  !*** ./src/utils/validators.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validateEmail: () => (/* binding */ validateEmail),
/* harmony export */   validateLength: () => (/* binding */ validateLength),
/* harmony export */   validateNumber: () => (/* binding */ validateNumber),
/* harmony export */   validatePattern: () => (/* binding */ validatePattern),
/* harmony export */   validateRequired: () => (/* binding */ validateRequired)
/* harmony export */ });
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * Form validation utilities
 * Pure validation functions without DOM manipulation
 */

/**
 * Validate a value against a set of validation rules
 * @param {string} value - Value to validate
 * @param {object} validationRules - Rules to apply
 * @returns {object} { isValid: boolean, error: string }
 */
function validate(value) {
  var validationRules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var trimmedValue = typeof value === 'string' ? value.trim() : value;

  // Apply validation rules
  for (var _i = 0, _Object$entries = Object.entries(validationRules); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      rule = _Object$entries$_i[0],
      ruleValue = _Object$entries$_i[1];
    var isValid = true;
    var errorMessage = '';
    switch (rule) {
      case 'required':
        if (ruleValue && !trimmedValue) {
          isValid = false;
          errorMessage = 'This field is required';
        }
        break;
      case 'minLength':
        if (trimmedValue && trimmedValue.length < ruleValue) {
          isValid = false;
          errorMessage = "Minimum ".concat(ruleValue, " characters required");
        }
        break;
      case 'maxLength':
        if (trimmedValue && trimmedValue.length > ruleValue) {
          isValid = false;
          errorMessage = "Maximum ".concat(ruleValue, " characters allowed");
        }
        break;
      case 'pattern':
        if (trimmedValue && !ruleValue.test(trimmedValue)) {
          isValid = false;
          errorMessage = validationRules.patternMessage || 'Invalid format';
        }
        break;
      case 'email':
        if (trimmedValue && ruleValue && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmedValue)) {
          isValid = false;
          errorMessage = 'Invalid email address';
        }
        break;
      case 'min':
        if (trimmedValue && parseFloat(trimmedValue) < ruleValue) {
          isValid = false;
          errorMessage = "Minimum value is ".concat(ruleValue);
        }
        break;
      case 'max':
        if (trimmedValue && parseFloat(trimmedValue) > ruleValue) {
          isValid = false;
          errorMessage = "Maximum value is ".concat(ruleValue);
        }
        break;
    }
    if (!isValid) {
      return {
        isValid: false,
        error: errorMessage
      };
    }
  }
  return {
    isValid: true
  };
}

/**
 * Validate required field
 * @param {string} value - Value to validate
 * @param {string} fieldName - Field name for error message
 * @returns {object} { isValid: boolean, error: string }
 */
function validateRequired(value) {
  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'This field';
  if (!value || typeof value === 'string' && value.trim() === '') {
    return {
      isValid: false,
      error: "".concat(fieldName, " is required")
    };
  }
  return {
    isValid: true
  };
}

/**
 * Validate email address format
 * @param {string} email - Email to validate
 * @returns {object} { isValid: boolean, error: string }
 */
function validateEmail(email) {
  if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return {
      isValid: false,
      error: 'Invalid email address'
    };
  }
  return {
    isValid: true
  };
}

/**
 * Validate numeric value is within range
 * @param {number|string} value - Value to validate
 * @param {number} min - Minimum value (optional)
 * @param {number} max - Maximum value (optional)
 * @returns {object} { isValid: boolean, error: string }
 */
function validateNumber(value) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var num = parseFloat(value);
  if (isNaN(num)) {
    return {
      isValid: false,
      error: 'Must be a valid number'
    };
  }
  if (min !== null && num < min) {
    return {
      isValid: false,
      error: "Minimum value is ".concat(min)
    };
  }
  if (max !== null && num > max) {
    return {
      isValid: false,
      error: "Maximum value is ".concat(max)
    };
  }
  return {
    isValid: true
  };
}

/**
 * Validate string length
 * @param {string} value - Value to validate
 * @param {number} minLength - Minimum length (optional)
 * @param {number} maxLength - Maximum length (optional)
 * @returns {object} { isValid: boolean, error: string }
 */
function validateLength(value) {
  var minLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var length = value ? value.length : 0;
  if (minLength !== null && length < minLength) {
    return {
      isValid: false,
      error: "Minimum ".concat(minLength, " characters required")
    };
  }
  if (maxLength !== null && length > maxLength) {
    return {
      isValid: false,
      error: "Maximum ".concat(maxLength, " characters allowed")
    };
  }
  return {
    isValid: true
  };
}

/**
 * Validate value matches pattern
 * @param {string} value - Value to validate
 * @param {RegExp} pattern - Regular expression pattern
 * @param {string} errorMessage - Error message to show
 * @returns {object} { isValid: boolean, error: string }
 */
function validatePattern(value, pattern) {
  var errorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Invalid format';
  if (!value || !pattern.test(value)) {
    return {
      isValid: false,
      error: errorMessage
    };
  }
  return {
    isValid: true
  };
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var chart_js_auto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js/auto */ "./node_modules/chart.js/auto/auto.js");
/* harmony import */ var _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/formatters.js */ "./src/utils/formatters.js");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/dom.js */ "./src/utils/dom.js");
/* harmony import */ var _utils_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers.js */ "./src/utils/helpers.js");
/* harmony import */ var _utils_validators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/validators.js */ "./src/utils/validators.js");
/* harmony import */ var _utils_api_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/api.js */ "./src/utils/api.js");
/* harmony import */ var _config_dashboardWidgets_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config/dashboardWidgets.js */ "./src/config/dashboardWidgets.js");
/* harmony import */ var _core_Router_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/Router.js */ "./src/core/Router.js");
/* harmony import */ var _modules_auth_AuthModule_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/auth/AuthModule.js */ "./src/modules/auth/AuthModule.js");
/* harmony import */ var _modules_dashboard_DashboardModule_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/dashboard/DashboardModule.js */ "./src/modules/dashboard/DashboardModule.js");
/* harmony import */ var _modules_transactions_TransactionsModule_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/transactions/TransactionsModule.js */ "./src/modules/transactions/TransactionsModule.js");
/* harmony import */ var _modules_pensions_PensionsModule_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/pensions/PensionsModule.js */ "./src/modules/pensions/PensionsModule.js");
/* harmony import */ var _modules_savings_SavingsModule_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/savings/SavingsModule.js */ "./src/modules/savings/SavingsModule.js");
/* harmony import */ var _modules_income_IncomeModule_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/income/IncomeModule.js */ "./src/modules/income/IncomeModule.js");
/* harmony import */ var _modules_bills_BillsModule_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/bills/BillsModule.js */ "./src/modules/bills/BillsModule.js");
/* harmony import */ var _modules_settings_SettingsModule_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/settings/SettingsModule.js */ "./src/modules/settings/SettingsModule.js");
/* harmony import */ var _modules_shared_expenses_SharedExpensesModule_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/shared-expenses/SharedExpensesModule.js */ "./src/modules/shared-expenses/SharedExpensesModule.js");
/* harmony import */ var _modules_tagsets_TagSetsModule_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/tagsets/TagSetsModule.js */ "./src/modules/tagsets/TagSetsModule.js");
/* harmony import */ var _modules_rules_RulesModule_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/rules/RulesModule.js */ "./src/modules/rules/RulesModule.js");
/* harmony import */ var _modules_forecast_ForecastModule_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/forecast/ForecastModule.js */ "./src/modules/forecast/ForecastModule.js");
/* harmony import */ var _modules_reports_ReportsModule_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/reports/ReportsModule.js */ "./src/modules/reports/ReportsModule.js");
/* harmony import */ var _modules_import_ImportModule_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/import/ImportModule.js */ "./src/modules/import/ImportModule.js");
/* harmony import */ var _modules_accounts_AccountsModule_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/accounts/AccountsModule.js */ "./src/modules/accounts/AccountsModule.js");
/* harmony import */ var _modules_categories_CategoriesModule_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/categories/CategoriesModule.js */ "./src/modules/categories/CategoriesModule.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Budget App - Main JavaScript
 */



// Utilities






// Configuration


// Core


// Modules
















var BudgetApp = /*#__PURE__*/function () {
  function BudgetApp() {
    _classCallCheck(this, BudgetApp);
    this.currentView = 'dashboard';
    this.accounts = [];
    this.categories = [];
    this.transactions = [];
    this.pensions = [];
    this.currentPension = null;
    this.charts = {};
    this.settings = {};
    this.columnVisibility = {};
    this.dashboardConfig = {
      hero: {
        order: [],
        visibility: {}
      },
      widgets: {
        order: [],
        visibility: {}
      }
    };
    this.dashboardLocked = true; // Default to locked
    this.widgetDataLoaded = {}; // Track which widgets have loaded data (Phase 2+)
    this.widgetData = {}; // Store widget-specific lazy-loaded data (Phase 2+)
    this.sessionToken = localStorage.getItem('budget_session_token'); // Session token for auth
    this.lastActivityTime = Date.now(); // Track last user activity for session timeout
    this.inactivityTimer = null; // Timer for auto-lock

    // Tag sets feature
    this.tagSets = []; // All tag sets with their tags
    this.selectedCategoryTagSets = []; // Tag sets for currently selected/editing category
    this.transactionTags = {}; // Cache of transaction tags by transaction ID
    this.allTagSetsForReports = []; // All tag sets for reports filtering

    // Savings goals
    this.savingsGoals = [];

    // Recurring income
    this.recurringIncome = [];

    // Bills
    this.bills = [];

    // Shared expenses
    this.contacts = [];
    this.splitContacts = [];
    this.currentContactDetails = null;

    // Rules
    this.rules = [];

    // Initialize core infrastructure
    this.router = new _core_Router_js__WEBPACK_IMPORTED_MODULE_7__["default"](this);

    // Initialize modules
    this.authModule = new _modules_auth_AuthModule_js__WEBPACK_IMPORTED_MODULE_8__["default"](this);
    this.dashboardModule = new _modules_dashboard_DashboardModule_js__WEBPACK_IMPORTED_MODULE_9__["default"](this);
    this.transactionsModule = new _modules_transactions_TransactionsModule_js__WEBPACK_IMPORTED_MODULE_10__["default"](this);
    this.pensionsModule = new _modules_pensions_PensionsModule_js__WEBPACK_IMPORTED_MODULE_11__["default"](this);
    this.savingsModule = new _modules_savings_SavingsModule_js__WEBPACK_IMPORTED_MODULE_12__["default"](this);
    this.incomeModule = new _modules_income_IncomeModule_js__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    this.billsModule = new _modules_bills_BillsModule_js__WEBPACK_IMPORTED_MODULE_14__["default"](this);
    this.settingsModule = new _modules_settings_SettingsModule_js__WEBPACK_IMPORTED_MODULE_15__["default"](this);
    this.sharedExpensesModule = new _modules_shared_expenses_SharedExpensesModule_js__WEBPACK_IMPORTED_MODULE_16__["default"](this);
    this.tagSetsModule = new _modules_tagsets_TagSetsModule_js__WEBPACK_IMPORTED_MODULE_17__["default"](this);
    this.rulesModule = new _modules_rules_RulesModule_js__WEBPACK_IMPORTED_MODULE_18__["default"](this);
    this.forecastModule = new _modules_forecast_ForecastModule_js__WEBPACK_IMPORTED_MODULE_19__["default"](this);
    this.reportsModule = new _modules_reports_ReportsModule_js__WEBPACK_IMPORTED_MODULE_20__["default"](this);
    this.importModule = new _modules_import_ImportModule_js__WEBPACK_IMPORTED_MODULE_21__["default"](this);
    this.accountsModule = new _modules_accounts_AccountsModule_js__WEBPACK_IMPORTED_MODULE_22__["default"](this);
    this.categoriesModule = new _modules_categories_CategoriesModule_js__WEBPACK_IMPORTED_MODULE_23__["default"](this);
    this.init();
  }
  return _createClass(BudgetApp, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var authRequired;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.authModule.checkAuth();
            case 1:
              authRequired = _context.v;
              if (!authRequired) {
                _context.n = 2;
                break;
              }
              // Show password prompt modal
              this.authModule.showPasswordModal();
              return _context.a(2);
            case 2:
              // Authentication passed or not required, proceed with normal init
              this.setupNavigation();
              this.setupEventListeners();
              this.authModule.setupActivityMonitoring();
              _context.n = 3;
              return this.authModule.setupLockButton();
            case 3:
              this.loadInitialData();
              this.showView('dashboard');
            case 4:
              return _context.a(2);
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }() // ============================================
    // Auth Module Delegations
    // ============================================
  }, {
    key: "getAuthHeaders",
    value: function getAuthHeaders() {
      return this.authModule.getAuthHeaders();
    }

    // Navigation - delegated to Router
  }, {
    key: "setupNavigation",
    value: function setupNavigation() {
      return this.router.setupNavigation();
    }
  }, {
    key: "showView",
    value: function showView(viewName) {
      return this.router.showView(viewName);
    }
  }, {
    key: "reloadCurrentView",
    value: function reloadCurrentView() {
      return this.router.reloadCurrentView();
    }
  }, {
    key: "setupEventListeners",
    value: function setupEventListeners() {
      var _this = this,
        _document$getElementB,
        _document$getElementB2,
        _document$getElementB3;
      // Navigation search functionality
      this.setupNavigationSearch();

      // Settings toggle (collapsible bottom nav)
      this.setupSettingsToggle();

      // Transaction form
      var transactionForm = document.getElementById('transaction-form');
      if (transactionForm) {
        transactionForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this.saveTransaction();
        });
      }

      // Quick Add form (Phase 4)
      var quickAddForm = document.getElementById('quick-add-form');
      if (quickAddForm) {
        quickAddForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this.saveQuickAddTransaction();
        });
      }

      // Quick Add reset button (Phase 4)
      var quickAddReset = document.getElementById('quick-add-reset');
      if (quickAddReset) {
        quickAddReset.addEventListener('click', function () {
          _this.resetQuickAddForm();
        });
      }

      // Add transaction button
      var addTransactionBtn = document.getElementById('add-transaction-btn');
      if (addTransactionBtn) {
        addTransactionBtn.addEventListener('click', function () {
          _this.showTransactionModal();
        });
      }

      // Account add transaction button
      var accountAddTransactionBtn = document.getElementById('account-add-transaction-btn');
      if (accountAddTransactionBtn) {
        accountAddTransactionBtn.addEventListener('click', function () {
          var _this$currentAccount;
          _this.showTransactionModal(null, (_this$currentAccount = _this.currentAccount) === null || _this$currentAccount === void 0 ? void 0 : _this$currentAccount.id);
        });
      }

      // Account form
      var accountForm = document.getElementById('account-form');
      if (accountForm) {
        accountForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this.saveAccount();
        });
      }

      // Category form
      var categoryForm = document.getElementById('category-form');
      if (categoryForm) {
        categoryForm.addEventListener('submit', function (e) {
          e.preventDefault();
          _this.saveCategory();
        });
      }

      // Update parent dropdown when category type changes
      var categoryType = document.getElementById('category-type');
      if (categoryType) {
        categoryType.addEventListener('change', function () {
          _this.populateCategoryParentDropdown();
        });
      }

      // Add account button
      var addAccountBtn = document.getElementById('add-account-btn');
      if (addAccountBtn) {
        addAccountBtn.addEventListener('click', function (e) {
          e.preventDefault();
          _this.showAccountModal();
        });
      }

      // Account type change for conditional fields
      var accountType = document.getElementById('account-type');
      if (accountType) {
        accountType.addEventListener('change', function () {
          _this.setupAccountTypeConditionals();
        });
      }

      // Institution autocomplete
      var institutionInput = document.getElementById('account-institution');
      if (institutionInput) {
        institutionInput.addEventListener('input', function () {
          _this.setupInstitutionAutocomplete();
        });
        institutionInput.addEventListener('blur', function () {
          setTimeout(function () {
            document.getElementById('institution-suggestions').style.display = 'none';
          }, 200);
        });
      }

      // Modal cancel button
      document.querySelectorAll('.cancel-btn').forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          // Check if closing bulk match modal - refresh transactions
          var bulkMatchModal = document.getElementById('bulk-match-modal');
          if (bulkMatchModal && bulkMatchModal.style.display !== 'none' && bulkMatchModal.contains(e.target)) {
            _this.hideModals();
            _this.loadTransactions();
          } else {
            _this.hideModals();
          }
        });
      });

      // Split modal buttons
      (_document$getElementB = document.getElementById('split-save-btn')) === null || _document$getElementB === void 0 || _document$getElementB.addEventListener('click', function () {
        _this.saveSplits();
      });
      (_document$getElementB2 = document.getElementById('split-unsplit-btn')) === null || _document$getElementB2 === void 0 || _document$getElementB2.addEventListener('click', function () {
        _this.unsplitTransaction();
      });
      (_document$getElementB3 = document.getElementById('add-split-row-btn')) === null || _document$getElementB3 === void 0 || _document$getElementB3.addEventListener('click', function () {
        var container = document.getElementById('splits-container');
        if (container) {
          _this.addSplitRow(container);
          _this.updateSplitRemaining();
        }
      });

      // Column configuration toggle
      var columnConfigBtn = document.getElementById('column-config-btn');
      var columnConfigDropdown = document.getElementById('column-config-dropdown');
      if (columnConfigBtn && columnConfigDropdown) {
        columnConfigBtn.addEventListener('click', function (e) {
          e.stopPropagation();
          var isVisible = columnConfigDropdown.style.display !== 'none';
          columnConfigDropdown.style.display = isVisible ? 'none' : 'block';
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function (e) {
          if (!columnConfigBtn.contains(e.target) && !columnConfigDropdown.contains(e.target)) {
            columnConfigDropdown.style.display = 'none';
          }
        });

        // Column visibility toggles
        ['date', 'description', 'vendor', 'category', 'amount', 'account'].forEach(function (col) {
          var checkbox = document.getElementById("col-toggle-".concat(col));
          if (checkbox) {
            checkbox.addEventListener('change', function () {
              _this.toggleColumnVisibility(col, checkbox.checked);
            });
          }
        });
      }

      // Account action buttons, transaction action buttons, and autocomplete (using event delegation)
      document.addEventListener('click', function (e) {
        if (e.target.classList.contains('edit-account-btn') || e.target.closest('.edit-account-btn')) {
          var button = e.target.classList.contains('edit-account-btn') ? e.target : e.target.closest('.edit-account-btn');
          var accountId = parseInt(button.getAttribute('data-account-id'));
          _this.editAccount(accountId);
        } else if (e.target.classList.contains('delete-account-btn') || e.target.closest('.delete-account-btn')) {
          var _button = e.target.classList.contains('delete-account-btn') ? e.target : e.target.closest('.delete-account-btn');
          var _accountId = parseInt(_button.getAttribute('data-account-id'));
          _this.deleteAccount(_accountId);
        } else if (e.target.classList.contains('view-transactions-btn') || e.target.closest('.view-transactions-btn')) {
          var _button2 = e.target.classList.contains('view-transactions-btn') ? e.target : e.target.closest('.view-transactions-btn');
          var _accountId2 = parseInt(_button2.getAttribute('data-account-id'));
          _this.viewAccountTransactions(_accountId2);
        } else if (e.target.classList.contains('transaction-edit-btn') || e.target.closest('.transaction-edit-btn')) {
          var _button3 = e.target.classList.contains('transaction-edit-btn') ? e.target : e.target.closest('.transaction-edit-btn');
          var transactionId = parseInt(_button3.getAttribute('data-transaction-id'));
          _this.editTransaction(transactionId);
        } else if (e.target.classList.contains('transaction-delete-btn') || e.target.closest('.transaction-delete-btn')) {
          var _button4 = e.target.classList.contains('transaction-delete-btn') ? e.target : e.target.closest('.transaction-delete-btn');
          var _transactionId = parseInt(_button4.getAttribute('data-transaction-id'));
          _this.deleteTransaction(_transactionId);
        } else if (e.target.classList.contains('transaction-split-btn') || e.target.closest('.transaction-split-btn')) {
          var _button5 = e.target.classList.contains('transaction-split-btn') ? e.target : e.target.closest('.transaction-split-btn');
          var _transactionId2 = parseInt(_button5.getAttribute('data-transaction-id'));
          _this.showSplitModal(_transactionId2);
        } else if (e.target.classList.contains('transaction-share-btn') || e.target.closest('.transaction-share-btn')) {
          var _this$transactions;
          var _button6 = e.target.classList.contains('transaction-share-btn') ? e.target : e.target.closest('.transaction-share-btn');
          var _transactionId3 = parseInt(_button6.getAttribute('data-transaction-id'));
          var transaction = (_this$transactions = _this.transactions) === null || _this$transactions === void 0 ? void 0 : _this$transactions.find(function (t) {
            return t.id === _transactionId3;
          });
          if (transaction) {
            _this.showShareExpenseModal(transaction);
          }
        } else if (e.target.classList.contains('transaction-match-btn') || e.target.closest('.transaction-match-btn')) {
          var _button7 = e.target.classList.contains('transaction-match-btn') ? e.target : e.target.closest('.transaction-match-btn');
          var _transactionId4 = parseInt(_button7.getAttribute('data-transaction-id'));
          _this.showMatchingModal(_transactionId4);
        } else if (e.target.classList.contains('transaction-unlink-btn') || e.target.closest('.transaction-unlink-btn')) {
          var _button8 = e.target.classList.contains('transaction-unlink-btn') ? e.target : e.target.closest('.transaction-unlink-btn');
          var _transactionId5 = parseInt(_button8.getAttribute('data-transaction-id'));
          _this.handleUnlinkTransaction(_transactionId5);
        } else if (e.target.classList.contains('linked-indicator')) {
          var _transactionId6 = parseInt(e.target.getAttribute('data-transaction-id'));
          _this.handleUnlinkTransaction(_transactionId6);
        } else if (e.target.classList.contains('link-match-btn')) {
          var sourceId = parseInt(e.target.getAttribute('data-source-id'));
          var targetId = parseInt(e.target.getAttribute('data-target-id'));
          _this.handleLinkMatch(sourceId, targetId);
        } else if (e.target.classList.contains('undo-match-btn')) {
          var _transactionId7 = parseInt(e.target.getAttribute('data-tx-id'));
          _this.handleBulkMatchUndo(_transactionId7);
        } else if (e.target.classList.contains('link-selected-btn')) {
          var _transactionId8 = parseInt(e.target.getAttribute('data-tx-id'));
          var index = parseInt(e.target.getAttribute('data-index'));
          _this.handleBulkMatchLink(_transactionId8, index);
        } else if (e.target.classList.contains('autocomplete-item')) {
          var bankName = e.target.getAttribute('data-bank-name');
          _this.selectInstitution(bankName);
        } else if (e.target.id === 'empty-categories-add-btn' || e.target.closest('#empty-categories-add-btn')) {
          _this.showAddCategoryModal();
        } else if (e.target.id === 'create-default-categories-btn' || e.target.closest('#create-default-categories-btn')) {
          _this.createDefaultCategories();
        }
      });

      // Bulk match radio button change handler (enable/disable link button)
      document.addEventListener('change', function (e) {
        if (e.target.type === 'radio' && e.target.name && e.target.name.startsWith('review-match-')) {
          var index = e.target.name.replace('review-match-', '');
          var linkBtn = document.querySelector(".link-selected-btn[data-index=\"".concat(index, "\"]"));
          if (linkBtn) {
            linkBtn.disabled = false;
          }
        }
      });

      // Import file handling
      var importDropzone = document.getElementById('import-dropzone');
      var importFileInput = document.getElementById('import-file-input');
      var importBrowseBtn = document.getElementById('import-browse-btn');
      if (importDropzone) {
        importDropzone.addEventListener('dragover', function (e) {
          e.preventDefault();
          importDropzone.classList.add('dragover');
        });
        importDropzone.addEventListener('dragleave', function () {
          importDropzone.classList.remove('dragover');
        });
        importDropzone.addEventListener('drop', function (e) {
          e.preventDefault();
          importDropzone.classList.remove('dragover');
          var files = e.dataTransfer.files;
          if (files.length > 0) {
            _this.handleImportFile(files[0]);
          }
        });
      }
      if (importBrowseBtn) {
        importBrowseBtn.addEventListener('click', function () {
          importFileInput.click();
        });
      }
      if (importFileInput) {
        importFileInput.addEventListener('change', function (e) {
          var file = e.target.files[0];
          if (file) {
            _this.handleImportFile(file);
          }
        });
      }

      // Enhanced Transaction Features
      this.setupTransactionEventListeners();
      this.setupInlineEditingListeners();

      // Enhanced Import System
      this.setupImportEventListeners();

      // Enhanced Forecast System
      this.setupForecastEventListeners();

      // Note: Generate report button event listener is handled by ReportsModule

      // Settings page event listeners
      this.setupSettingsEventListeners();

      // Dashboard customization
      this.setupDashboardCustomization();

      // Window resize handler for responsive dashboard layout
      var resizeTimeout;
      window.addEventListener('resize', function () {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function () {
          if (_this.currentView === 'dashboard') {
            _this.applyDashboardLayout();
          }
        }, 250);
      });

      // Tag modal listeners
      this.setupAddTagModalListeners();
      this.setupAddTagSetModalListeners();
    }
  }, {
    key: "setupNavigationSearch",
    value: function setupNavigationSearch() {
      var _this2 = this;
      var searchInput = document.getElementById('app-navigation-search-input');
      var clearButton = document.getElementById('app-navigation-search-clear');
      var navigationEntries = document.querySelectorAll('.app-navigation-entry');
      if (!searchInput || !clearButton) return;

      // Store original navigation entry data for filtering
      this.originalNavigationEntries = Array.from(navigationEntries).map(function (entry) {
        return {
          element: entry,
          text: entry.textContent.toLowerCase().trim(),
          id: entry.dataset.id
        };
      });

      // Search input event listener
      searchInput.addEventListener('input', function (e) {
        var query = e.target.value.toLowerCase().trim();
        _this2.filterNavigationEntries(query);

        // Show/hide clear button
        if (query) {
          clearButton.style.display = 'flex';
        } else {
          clearButton.style.display = 'none';
        }
      });

      // Clear button event listener
      clearButton.addEventListener('click', function () {
        searchInput.value = '';
        searchInput.focus();
        clearButton.style.display = 'none';
        _this2.filterNavigationEntries('');
      });

      // Support escape key to clear search
      searchInput.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
          searchInput.value = '';
          clearButton.style.display = 'none';
          _this2.filterNavigationEntries('');
          searchInput.blur();
        }
      });
    }
  }, {
    key: "setupSettingsToggle",
    value: function setupSettingsToggle() {
      var settingsToggle = document.querySelector('#app-settings-header .settings-toggle');
      var appSettings = document.getElementById('app-settings');
      if (!settingsToggle || !appSettings) return;

      // Load saved state from localStorage
      var isExpanded = localStorage.getItem('budget-settings-expanded') === 'true';
      if (isExpanded) {
        appSettings.classList.add('expanded');
        settingsToggle.setAttribute('aria-expanded', 'true');
      }
      settingsToggle.addEventListener('click', function () {
        var expanded = appSettings.classList.toggle('expanded');
        settingsToggle.setAttribute('aria-expanded', expanded.toString());

        // Save state to localStorage
        localStorage.setItem('budget-settings-expanded', expanded.toString());
      });
    }
  }, {
    key: "filterNavigationEntries",
    value: function filterNavigationEntries(query) {
      var _this3 = this;
      if (!this.originalNavigationEntries) return;
      this.originalNavigationEntries.forEach(function (entry) {
        var matches = !query || entry.text.includes(query);
        if (matches) {
          entry.element.style.display = '';
          // Highlight matching text if there's a query
          if (query) {
            _this3.highlightNavigationText(entry.element, query);
          } else {
            _this3.clearNavigationHighlight(entry.element);
          }
        } else {
          entry.element.style.display = 'none';
        }
      });
    }
  }, {
    key: "highlightNavigationText",
    value: function highlightNavigationText(element, query) {
      var textElement = element.querySelector('a');
      if (!textElement) return;
      var originalText = textElement.dataset.originalText || textElement.textContent;
      textElement.dataset.originalText = originalText;
      var regex = new RegExp("(".concat(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), ")"), 'gi');
      var highlightedText = originalText.replace(regex, '<mark>$1</mark>');

      // Only update if we have an icon span to preserve
      var iconSpan = textElement.querySelector('.app-navigation-entry-icon');
      if (iconSpan) {
        var iconHTML = iconSpan.outerHTML;
        textElement.innerHTML = iconHTML + highlightedText.replace(iconHTML, '');
      } else {
        textElement.innerHTML = highlightedText;
      }
    }
  }, {
    key: "clearNavigationHighlight",
    value: function clearNavigationHighlight(element) {
      var textElement = element.querySelector('a');
      if (!textElement || !textElement.dataset.originalText) return;
      var iconSpan = textElement.querySelector('.app-navigation-entry-icon');
      if (iconSpan) {
        var iconHTML = iconSpan.outerHTML;
        textElement.innerHTML = iconHTML + textElement.dataset.originalText.replace(/^[^>]*>/, '');
      } else {
        textElement.textContent = textElement.dataset.originalText;
      }
      delete textElement.dataset.originalText;
    }
  }, {
    key: "applyTheme",
    value: function applyTheme(themePreference) {
      var appContainer = document.getElementById('app-content-wrapper');
      if (!appContainer) return;

      // Remove existing theme classes
      appContainer.classList.remove('theme-light', 'theme-dark', 'theme-system');

      // Apply theme based on preference
      switch (themePreference) {
        case 'light':
          appContainer.classList.add('theme-light');
          appContainer.setAttribute('data-theme', 'light');
          break;
        case 'dark':
          appContainer.classList.add('theme-dark');
          appContainer.setAttribute('data-theme', 'dark');
          break;
        case 'system':
        default:
          // Follow Nextcloud's theme (remove overrides)
          appContainer.classList.add('theme-system');
          appContainer.removeAttribute('data-theme');
          break;
      }
    }
  }, {
    key: "loadInitialData",
    value: function () {
      var _loadInitialData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var _yield$Promise$all, _yield$Promise$all2, settingsResponse, accountsResponse, categoriesResponse, accountsData, categoriesData, _t;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _context2.n = 1;
              return Promise.all([fetch(OC.generateUrl('/apps/budget/api/settings'), {
                headers: this.getAuthHeaders()
              }), fetch(OC.generateUrl('/apps/budget/api/accounts'), {
                headers: this.getAuthHeaders()
              }), fetch(OC.generateUrl('/apps/budget/api/categories'), {
                headers: this.getAuthHeaders()
              })]);
            case 1:
              _yield$Promise$all = _context2.v;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);
              settingsResponse = _yield$Promise$all2[0];
              accountsResponse = _yield$Promise$all2[1];
              categoriesResponse = _yield$Promise$all2[2];
              if (!settingsResponse.ok) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return settingsResponse.json();
            case 2:
              this.settings = _context2.v;
              this.columnVisibility = this.parseColumnVisibility(this.settings.transaction_columns_visible);
              this.syncColumnConfigUI();

              // Parse dashboard config
              this.dashboardConfig.hero = this.parseDashboardConfig(this.settings.dashboard_hero_config, 'hero');
              this.dashboardConfig.widgets = this.parseDashboardConfig(this.settings.dashboard_widgets_config, 'widgets');

              // Apply theme preference on load
              if (this.settings.theme_preference) {
                this.applyTheme(this.settings.theme_preference);
              }
            case 3:
              if (accountsResponse.ok) {
                _context2.n = 4;
                break;
              }
              throw new Error("Failed to load accounts: ".concat(accountsResponse.status, " ").concat(accountsResponse.statusText));
            case 4:
              _context2.n = 5;
              return accountsResponse.json();
            case 5:
              accountsData = _context2.v;
              this.accounts = Array.isArray(accountsData) ? accountsData : [];
              _context2.n = 6;
              return categoriesResponse.json();
            case 6:
              categoriesData = _context2.v;
              this.categories = Array.isArray(categoriesData) ? categoriesData : [];

              // Populate dropdowns
              this.populateAccountDropdowns();
              this.populateCategoryDropdowns();
              _context2.n = 8;
              break;
            case 7:
              _context2.p = 7;
              _t = _context2.v;
              console.error('Failed to load initial data:', _t);
              OC.Notification.showTemporary('Failed to load data');
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 7]]);
      }));
      function loadInitialData() {
        return _loadInitialData.apply(this, arguments);
      }
      return loadInitialData;
    }() // ============================================
    // Dashboard Module Delegations
    // ============================================
  }, {
    key: "loadDashboard",
    value: function () {
      var _loadDashboard = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              return _context3.a(2, this.dashboardModule.loadDashboard());
          }
        }, _callee3, this);
      }));
      function loadDashboard() {
        return _loadDashboard.apply(this, arguments);
      }
      return loadDashboard;
    }()
  }, {
    key: "parseDashboardConfig",
    value: function parseDashboardConfig(config, type) {
      return this.dashboardModule.parseDashboardConfig(config, type);
    }
  }, {
    key: "applyDashboardLayout",
    value: function applyDashboardLayout() {
      return this.dashboardModule.applyDashboardLayout();
    }
  }, {
    key: "toggleDashboardLock",
    value: function toggleDashboardLock() {
      return this.dashboardModule.toggleDashboardLock();
    }
  }, {
    key: "applyDashboardVisibility",
    value: function () {
      var _applyDashboardVisibility = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              return _context4.a(2, this.dashboardModule.applyDashboardVisibility());
          }
        }, _callee4, this);
      }));
      function applyDashboardVisibility() {
        return _applyDashboardVisibility.apply(this, arguments);
      }
      return applyDashboardVisibility;
    }()
  }, {
    key: "applyDashboardOrder",
    value: function applyDashboardOrder() {
      return this.dashboardModule.applyDashboardOrder();
    }
  }, {
    key: "needsLazyLoad",
    value: function needsLazyLoad(widgetKey) {
      return this.dashboardModule.needsLazyLoad(widgetKey);
    }
  }, {
    key: "loadWidgetData",
    value: function () {
      var _loadWidgetData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(widgetKey) {
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this.dashboardModule.loadWidgetData(widgetKey));
          }
        }, _callee5, this);
      }));
      function loadWidgetData(_x) {
        return _loadWidgetData.apply(this, arguments);
      }
      return loadWidgetData;
    }()
  }, {
    key: "hideWidget",
    value: function () {
      var _hideWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(widgetId, category) {
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              return _context6.a(2, this.dashboardModule.hideWidget(widgetId, category));
          }
        }, _callee6, this);
      }));
      function hideWidget(_x2, _x3) {
        return _hideWidget.apply(this, arguments);
      }
      return hideWidget;
    }()
  }, {
    key: "showWidget",
    value: function () {
      var _showWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(widgetId, category) {
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              return _context7.a(2, this.dashboardModule.showWidget(widgetId, category));
          }
        }, _callee7, this);
      }));
      function showWidget(_x4, _x5) {
        return _showWidget.apply(this, arguments);
      }
      return showWidget;
    }()
  }, {
    key: "saveDashboardVisibility",
    value: function () {
      var _saveDashboardVisibility = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              return _context8.a(2, this.dashboardModule.saveDashboardVisibility());
          }
        }, _callee8, this);
      }));
      function saveDashboardVisibility() {
        return _saveDashboardVisibility.apply(this, arguments);
      }
      return saveDashboardVisibility;
    }()
  }, {
    key: "setupDashboardCustomization",
    value: function setupDashboardCustomization() {
      return this.dashboardModule.setupDashboardCustomization();
    }
  }, {
    key: "updateDashboardLockUI",
    value: function updateDashboardLockUI() {
      return this.dashboardModule.updateDashboardLockUI();
    }
  }, {
    key: "addRemoveButtons",
    value: function addRemoveButtons() {
      return this.dashboardModule.addRemoveButtons();
    }
  }, {
    key: "updateAddTilesMenu",
    value: function updateAddTilesMenu() {
      return this.dashboardModule.updateAddTilesMenu();
    }
  }, {
    key: "setupDashboardDragAndDrop",
    value: function setupDashboardDragAndDrop() {
      return this.dashboardModule.setupDashboardDragAndDrop();
    }
  }, {
    key: "showDashboardDropIndicator",
    value: function showDashboardDropIndicator(e, container) {
      return this.dashboardModule.showDashboardDropIndicator(e, container);
    }
  }, {
    key: "getDragAfterElement",
    value: function getDragAfterElement(container, y) {
      return this.dashboardModule.getDragAfterElement(container, y);
    }
  }, {
    key: "getDashboardDropTarget",
    value: function getDashboardDropTarget(e, container) {
      return this.dashboardModule.getDashboardDropTarget(e, container);
    }
  }, {
    key: "clearDashboardDropIndicators",
    value: function clearDashboardDropIndicators() {
      return this.dashboardModule.clearDashboardDropIndicators();
    }
  }, {
    key: "reorderDashboardWidget",
    value: function () {
      var _reorderDashboardWidget = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(draggedId, targetId, position, category) {
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              return _context9.a(2, this.dashboardModule.reorderDashboardWidget(draggedId, targetId, position, category));
          }
        }, _callee9, this);
      }));
      function reorderDashboardWidget(_x6, _x7, _x8, _x9) {
        return _reorderDashboardWidget.apply(this, arguments);
      }
      return reorderDashboardWidget;
    }() // ============================================
    // Accounts Module Delegations
    // ============================================
  }, {
    key: "loadAccounts",
    value: function () {
      var _loadAccounts = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              return _context0.a(2, this.accountsModule.loadAccounts());
          }
        }, _callee0, this);
      }));
      function loadAccounts() {
        return _loadAccounts.apply(this, arguments);
      }
      return loadAccounts;
    }()
  }, {
    key: "showAccountDetails",
    value: function () {
      var _showAccountDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(accountId) {
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.n) {
            case 0:
              return _context1.a(2, this.accountsModule.showAccountDetails(accountId));
          }
        }, _callee1, this);
      }));
      function showAccountDetails(_x0) {
        return _showAccountDetails.apply(this, arguments);
      }
      return showAccountDetails;
    }()
  }, {
    key: "hideAccountDetails",
    value: function hideAccountDetails() {
      return this.accountsModule.hideAccountDetails();
    }
  }, {
    key: "saveAccount",
    value: function () {
      var _saveAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.n) {
            case 0:
              return _context10.a(2, this.accountsModule.saveAccount());
          }
        }, _callee10, this);
      }));
      function saveAccount() {
        return _saveAccount.apply(this, arguments);
      }
      return saveAccount;
    }()
  }, {
    key: "showAccountModal",
    value: function showAccountModal() {
      var accountId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return this.accountsModule.showAccountModal(accountId);
    }
  }, {
    key: "editAccount",
    value: function () {
      var _editAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(id) {
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.n) {
            case 0:
              return _context11.a(2, this.accountsModule.editAccount(id));
          }
        }, _callee11, this);
      }));
      function editAccount(_x1) {
        return _editAccount.apply(this, arguments);
      }
      return editAccount;
    }()
  }, {
    key: "deleteAccount",
    value: function () {
      var _deleteAccount = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(id) {
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              return _context12.a(2, this.accountsModule.deleteAccount(id));
          }
        }, _callee12, this);
      }));
      function deleteAccount(_x10) {
        return _deleteAccount.apply(this, arguments);
      }
      return deleteAccount;
    }()
  }, {
    key: "viewAccountTransactions",
    value: function viewAccountTransactions(accountId) {
      return this.accountsModule.viewAccountTransactions(accountId);
    }

    // ==================== END ACCOUNTS MODULE ====================

    // ============================================
    // Categories Module Delegations
    // ============================================
  }, {
    key: "loadCategories",
    value: function () {
      var _loadCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              return _context13.a(2, this.categoriesModule.loadCategories());
          }
        }, _callee13, this);
      }));
      function loadCategories() {
        return _loadCategories.apply(this, arguments);
      }
      return loadCategories;
    }()
  }, {
    key: "setupCategoriesEventListeners",
    value: function setupCategoriesEventListeners() {
      return this.categoriesModule.setupCategoriesEventListeners();
    }
  }, {
    key: "switchCategoryType",
    value: function switchCategoryType(type) {
      return this.categoriesModule.switchCategoryType(type);
    }
  }, {
    key: "renderCategoriesTree",
    value: function renderCategoriesTree() {
      return this.categoriesModule.renderCategoriesTree();
    }
  }, {
    key: "selectCategory",
    value: function selectCategory(categoryId) {
      return this.categoriesModule.selectCategory(categoryId);
    }
  }, {
    key: "showAddCategoryModal",
    value: function showAddCategoryModal() {
      return this.categoriesModule.showAddCategoryModal();
    }
  }, {
    key: "editSelectedCategory",
    value: function editSelectedCategory() {
      return this.categoriesModule.editSelectedCategory();
    }
  }, {
    key: "deleteSelectedCategory",
    value: function deleteSelectedCategory() {
      return this.categoriesModule.deleteSelectedCategory();
    }
  }, {
    key: "deleteCategoryById",
    value: function () {
      var _deleteCategoryById = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(categoryId) {
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.n) {
            case 0:
              return _context14.a(2, this.categoriesModule.deleteCategoryById(categoryId));
          }
        }, _callee14, this);
      }));
      function deleteCategoryById(_x11) {
        return _deleteCategoryById.apply(this, arguments);
      }
      return deleteCategoryById;
    }()
  }, {
    key: "saveCategory",
    value: function () {
      var _saveCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
        return _regenerator().w(function (_context15) {
          while (1) switch (_context15.n) {
            case 0:
              return _context15.a(2, this.categoriesModule.saveCategory());
          }
        }, _callee15, this);
      }));
      function saveCategory() {
        return _saveCategory.apply(this, arguments);
      }
      return saveCategory;
    }()
  }, {
    key: "createDefaultCategories",
    value: function () {
      var _createDefaultCategories = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.n) {
            case 0:
              return _context16.a(2, this.categoriesModule.createDefaultCategories());
          }
        }, _callee16, this);
      }));
      function createDefaultCategories() {
        return _createDefaultCategories.apply(this, arguments);
      }
      return createDefaultCategories;
    }()
  }, {
    key: "loadBudgetView",
    value: function () {
      var _loadBudgetView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.n) {
            case 0:
              return _context17.a(2, this.categoriesModule.loadBudgetView());
          }
        }, _callee17, this);
      }));
      function loadBudgetView() {
        return _loadBudgetView.apply(this, arguments);
      }
      return loadBudgetView;
    }() // ==================== END CATEGORIES MODULE ====================
    // ============================================
    // Transactions Module Delegations
    // ============================================
  }, {
    key: "setupTransactionEventListeners",
    value: function setupTransactionEventListeners() {
      return this.transactionsModule.setupTransactionEventListeners();
    }
  }, {
    key: "setupInlineEditingListeners",
    value: function setupInlineEditingListeners() {
      return this.transactionsModule.setupInlineEditingListeners();
    }
  }, {
    key: "renderTransactionsTable",
    value: function renderTransactionsTable(transactions) {
      return this.transactionsModule.renderTransactionsTable(transactions);
    }
  }, {
    key: "renderEnhancedTransactionsTable",
    value: function renderEnhancedTransactionsTable() {
      var _this4 = this;
      var tbody = document.querySelector('#transactions-table tbody');
      if (!tbody || !this.transactions) return;
      tbody.innerHTML = this.transactions.map(function (transaction) {
        var _this4$accounts, _this4$categories, _this4$transactionsMo;
        var account = (_this4$accounts = _this4.accounts) === null || _this4$accounts === void 0 ? void 0 : _this4$accounts.find(function (a) {
          return a.id === transaction.accountId;
        });
        var category = (_this4$categories = _this4.categories) === null || _this4$categories === void 0 ? void 0 : _this4$categories.find(function (c) {
          return c.id === transaction.categoryId;
        });
        var currency = transaction.accountCurrency || (account === null || account === void 0 ? void 0 : account.currency) || _this4.getPrimaryCurrency();
        var typeClass = transaction.type === 'credit' ? 'positive' : 'negative';
        var formattedAmount = _this4.formatCurrency(transaction.amount, currency);
        var isLinked = transaction.linkedTransactionId != null;
        var linkedBadge = isLinked ? "<span class=\"linked-indicator\" data-transaction-id=\"".concat(transaction.id, "\" data-linked-id=\"").concat(transaction.linkedTransactionId, "\" title=\"Linked transfer - click to unlink\">&#x1F517; Transfer</span>") : '';
        var matchButton = !isLinked ? "<button class=\"action-btn match-btn transaction-match-btn\"\n                          data-transaction-id=\"".concat(transaction.id, "\"\n                          title=\"Find transfer matches\">\n                      <span class=\"icon-external\" aria-hidden=\"true\"></span>\n                  </button>") : "<button class=\"action-btn unlink-btn transaction-unlink-btn\"\n                          data-transaction-id=\"".concat(transaction.id, "\"\n                          title=\"Unlink transfer\">\n                      &#x2716;\n                  </button>");
        return "\n                <tr class=\"transaction-row ".concat(isLinked ? 'is-linked' : '', "\" data-transaction-id=\"").concat(transaction.id, "\">\n                    <td class=\"select-column\">\n                        <input type=\"checkbox\" class=\"transaction-checkbox\"\n                               data-transaction-id=\"").concat(transaction.id, "\"\n                               ").concat((_this4$transactionsMo = _this4.transactionsModule.selectedTransactions) !== null && _this4$transactionsMo !== void 0 && _this4$transactionsMo.has(transaction.id) ? 'checked' : '', ">\n                    </td>\n                    <td class=\"date-column editable-cell\"\n                        data-field=\"date\"\n                        data-value=\"").concat(transaction.date, "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"cell-display\">").concat(_this4.formatDate(transaction.date), "</span>\n                    </td>\n                    <td class=\"description-column editable-cell\"\n                        data-field=\"description\"\n                        data-value=\"").concat(_this4.escapeHtml(transaction.description), "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <div class=\"transaction-description\">\n                            <span class=\"primary-text cell-display\">").concat(_this4.escapeHtml(transaction.description) || 'No description', "</span>\n                            ").concat(transaction.reference ? "<span class=\"secondary-text\">".concat(_this4.escapeHtml(transaction.reference), "</span>") : '', "\n                            ").concat(linkedBadge, "\n                        </div>\n                    </td>\n                    <td class=\"vendor-column editable-cell\"\n                        data-field=\"vendor\"\n                        data-value=\"").concat(_this4.escapeHtml(transaction.vendor || ''), "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"cell-display\">").concat(_this4.escapeHtml(transaction.vendor) || '-', "</span>\n                    </td>\n                    <td class=\"category-column editable-cell\"\n                        data-field=\"categoryId\"\n                        data-value=\"").concat(transaction.categoryId || '', "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"category-badge cell-display ").concat(category ? 'categorized' : 'uncategorized', "\">\n                            ").concat(category ? _this4.escapeHtml(category.name) : 'Uncategorized', "\n                        </span>\n                    </td>\n                    <td class=\"tags-column editable-cell\"\n                        data-field=\"tags\"\n                        data-value=\"").concat(_this4.getTransactionTagIds(transaction.id).join(','), "\"\n                        data-category-id=\"").concat(transaction.categoryId || '', "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"cell-display\">\n                            ").concat(_this4.renderTransactionTags(transaction.id), "\n                        </span>\n                    </td>\n                    <td class=\"amount-column editable-cell\"\n                        data-field=\"amount\"\n                        data-value=\"").concat(transaction.amount, "\"\n                        data-type=\"").concat(transaction.type, "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"amount cell-display ").concat(typeClass, "\">").concat(formattedAmount, "</span>\n                    </td>\n                    <td class=\"account-column editable-cell\"\n                        data-field=\"accountId\"\n                        data-value=\"").concat(transaction.accountId, "\"\n                        data-transaction-id=\"").concat(transaction.id, "\">\n                        <span class=\"account-name cell-display\">").concat(account ? _this4.escapeHtml(account.name) : 'Unknown Account', "</span>\n                    </td>\n                    <td class=\"actions-column\">\n                        <div class=\"transaction-actions\">\n                            <button class=\"action-btn split-btn transaction-split-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Split into categories\">\n                                <span aria-hidden=\"true\">\u22EF</span>\n                            </button>\n                            <button class=\"action-btn share-btn transaction-share-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Share with contact\">\n                                <span aria-hidden=\"true\">\uD83D\uDC65</span>\n                            </button>\n                            ").concat(matchButton, "\n                            <button class=\"action-btn edit-btn transaction-edit-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Edit transaction (modal)\">\n                                <span class=\"icon-rename\" aria-hidden=\"true\"></span>\n                            </button>\n                            <button class=\"action-btn delete-btn transaction-delete-btn\"\n                                    data-transaction-id=\"").concat(transaction.id, "\"\n                                    title=\"Delete transaction\">\n                                <span class=\"icon-delete\" aria-hidden=\"true\"></span>\n                            </button>\n                        </div>\n                    </td>\n                </tr>\n            ");
      }).join('');
    }

    /**
     * Render tags for a transaction
     */
  }, {
    key: "renderTransactionTags",
    value: function renderTransactionTags(transactionId) {
      var _this5 = this;
      // Ensure transactionTags is initialized
      if (!this.transactionTags) {
        this.transactionTags = {};
      }
      var tags = this.transactionTags[transactionId];
      if (!tags || tags.length === 0) {
        return '<span style="color: var(--color-text-maxcontrast); font-size: 11px;">-</span>';
      }
      return tags.map(function (tag) {
        return "\n            <span class=\"tag-chip\"\n                  style=\"display: inline-flex; align-items: center; background-color: ".concat(_this5.escapeHtml(tag.color), "; color: white;\n                         padding: 2px 6px; border-radius: 10px; font-size: 10px; line-height: 14px; margin: 0 2px 2px 0;\">\n                ").concat(_this5.escapeHtml(tag.name), "\n            </span>\n        ");
      }).join('');
    }

    /**
     * Get tag IDs for a transaction
     */
  }, {
    key: "getTransactionTagIds",
    value: function getTransactionTagIds(transactionId) {
      if (!this.transactionTags) {
        this.transactionTags = {};
      }
      var tags = this.transactionTags[transactionId];
      if (!tags || tags.length === 0) {
        return [];
      }
      return tags.map(function (tag) {
        return tag.id;
      });
    }
  }, {
    key: "showTransactionModal",
    value: function showTransactionModal(transaction, preSelectedAccountId) {
      return this.transactionsModule.showTransactionModal(transaction, preSelectedAccountId);
    }
  }, {
    key: "editTransaction",
    value: function editTransaction(id) {
      return this.transactionsModule.editTransaction(id);
    }
  }, {
    key: "saveTransaction",
    value: function () {
      var _saveTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.n) {
            case 0:
              return _context18.a(2, this.transactionsModule.saveTransaction());
          }
        }, _callee18, this);
      }));
      function saveTransaction() {
        return _saveTransaction.apply(this, arguments);
      }
      return saveTransaction;
    }()
  }, {
    key: "deleteTransaction",
    value: function () {
      var _deleteTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(id) {
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.n) {
            case 0:
              return _context19.a(2, this.transactionsModule.deleteTransaction(id));
          }
        }, _callee19, this);
      }));
      function deleteTransaction(_x12) {
        return _deleteTransaction.apply(this, arguments);
      }
      return deleteTransaction;
    }() // Transaction matching/splits
  }, {
    key: "findTransactionMatches",
    value: // ============================================
    // ===== Transaction Matching Methods =====
    /**
     * Find potential transfer matches for a transaction
     */
    function () {
      var _findTransactionMatches = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(transactionId) {
        var response, _t2;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.p = _context20.n) {
            case 0:
              _context20.p = 0;
              _context20.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/matches")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context20.v;
              if (response.ok) {
                _context20.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context20.n = 3;
              return response.json();
            case 3:
              return _context20.a(2, _context20.v);
            case 4:
              _context20.p = 4;
              _t2 = _context20.v;
              console.error('Failed to find matches:', _t2);
              throw _t2;
            case 5:
              return _context20.a(2);
          }
        }, _callee20, null, [[0, 4]]);
      }));
      function findTransactionMatches(_x13) {
        return _findTransactionMatches.apply(this, arguments);
      }
      return findTransactionMatches;
    }()
    /**
     * Link two transactions as a transfer pair
     */
  }, {
    key: "getTransactionSplits",
    value: (
    /**
     * API call to get transaction splits
     */
    function () {
      var _getTransactionSplits = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(transactionId) {
        var response;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.n) {
            case 0:
              _context21.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context21.v;
              if (response.ok) {
                _context21.n = 2;
                break;
              }
              throw new Error("HTTP ".concat(response.status));
            case 2:
              _context21.n = 3;
              return response.json();
            case 3:
              return _context21.a(2, _context21.v);
          }
        }, _callee21);
      }));
      function getTransactionSplits(_x14) {
        return _getTransactionSplits.apply(this, arguments);
      }
      return getTransactionSplits;
    }()
    /**
     * Save transaction splits
     */
    )
  }, {
    key: "addSplitRow",
    value:
    /**
     * Add a split row to the splits container
     */
    function addSplitRow(container) {
      var _this$transactions2,
        _this6 = this;
      var split = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var isFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var modal = document.getElementById('split-modal');
      var currency = (modal === null || modal === void 0 ? void 0 : modal.dataset.currency) || this.getPrimaryCurrency();
      var rowIndex = container.children.length;

      // Get the transaction to determine its type
      var transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
      var transaction = (_this$transactions2 = this.transactions) === null || _this$transactions2 === void 0 ? void 0 : _this$transactions2.find(function (t) {
        return t.id === transactionId;
      });
      var transactionType = (transaction === null || transaction === void 0 ? void 0 : transaction.type) || 'debit';
      var row = document.createElement('div');
      row.className = 'split-row';
      row.dataset.index = rowIndex;
      row.innerHTML = "\n            <div class=\"split-field split-amount-field\">\n                <label>Amount</label>\n                <input type=\"number\" class=\"split-amount\" step=\"0.01\" min=\"0.01\"\n                       value=\"".concat(split ? split.amount : '', "\" placeholder=\"0.00\" required>\n            </div>\n            <div class=\"split-field split-category-field\">\n                <label>Category</label>\n                <select class=\"split-category\">\n                    <option value=\"\">Uncategorized</option>\n                    ").concat(this.getCategoryOptions(split === null || split === void 0 ? void 0 : split.categoryId, transactionType), "\n                </select>\n            </div>\n            <div class=\"split-field split-description-field\">\n                <label>Description</label>\n                <input type=\"text\" class=\"split-description\" maxlength=\"255\"\n                       value=\"").concat((split === null || split === void 0 ? void 0 : split.description) || '', "\" placeholder=\"Optional note\">\n            </div>\n            <div class=\"split-actions\">\n                <button type=\"button\" class=\"split-remove-btn ").concat(isFirst ? 'disabled' : '', "\"\n                        ").concat(isFirst ? 'disabled' : '', " title=\"Remove split\">\n                    <span class=\"icon-delete\"></span>\n                </button>\n            </div>\n        ");

      // Add event listeners
      row.querySelector('.split-amount').addEventListener('input', function () {
        return _this6.updateSplitRemaining();
      });
      row.querySelector('.split-remove-btn').addEventListener('click', function (e) {
        if (!e.currentTarget.classList.contains('disabled')) {
          row.remove();
          _this6.updateSplitRemaining();
        }
      });
      container.appendChild(row);
    }

    /**
     * Get category options HTML
     */
  }, {
    key: "bulkMatchTransactions",
    value: // ===== Bulk Transaction Matching Methods =====
    /**
     * API call to bulk match transactions
     */
    function () {
      var _bulkMatchTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22() {
        var response, error;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              _context22.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/transactions/bulk-match'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                }
              });
            case 1:
              response = _context22.v;
              if (response.ok) {
                _context22.n = 3;
                break;
              }
              _context22.n = 2;
              return response.json();
            case 2:
              error = _context22.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context22.n = 4;
              return response.json();
            case 4:
              return _context22.a(2, _context22.v);
          }
        }, _callee22);
      }));
      function bulkMatchTransactions() {
        return _bulkMatchTransactions.apply(this, arguments);
      }
      return bulkMatchTransactions;
    }()
    /**
     * Show the bulk match modal and execute bulk matching
     */
  }, {
    key: "handleBulkMatchUndo",
    value: (
    /**
     * Handle undo of an auto-matched pair from bulk match modal
     */
    function () {
      var _handleBulkMatchUndo = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23(transactionId) {
        var pairEl, countEl, currentCount, autoMatchedList, _t3;
        return _regenerator().w(function (_context23) {
          while (1) switch (_context23.p = _context23.n) {
            case 0:
              _context23.p = 0;
              _context23.n = 1;
              return this.unlinkTransaction(transactionId);
            case 1:
              // Remove the pair from the UI
              pairEl = document.querySelector(".bulk-match-pair[data-tx-id=\"".concat(transactionId, "\"]"));
              if (pairEl) {
                pairEl.remove();
              }

              // Update count
              countEl = document.getElementById('auto-matched-count');
              currentCount = parseInt(countEl.textContent);
              countEl.textContent = currentCount - 1;

              // Check if section is now empty
              autoMatchedList = document.getElementById('auto-matched-list');
              if (autoMatchedList.children.length === 0) {
                document.getElementById('auto-matched-section').style.display = 'none';
              }
              OC.Notification.showTemporary('Match undone');
              _context23.n = 3;
              break;
            case 2:
              _context23.p = 2;
              _t3 = _context23.v;
              OC.Notification.showTemporary(_t3.message || 'Failed to undo match');
            case 3:
              return _context23.a(2);
          }
        }, _callee23, this, [[0, 2]]);
      }));
      function handleBulkMatchUndo(_x15) {
        return _handleBulkMatchUndo.apply(this, arguments);
      }
      return handleBulkMatchUndo;
    }()
    /**
     * Handle linking a selected match from review section
     */
    )
  }, {
    key: "handleBulkMatchLink",
    value: (function () {
      var _handleBulkMatchLink = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee24(transactionId, index) {
        var reviewItem, selectedRadio, targetId, reviewCountEl, autoCountEl, currentReviewCount, currentAutoCount, needsReviewList, _t4;
        return _regenerator().w(function (_context24) {
          while (1) switch (_context24.p = _context24.n) {
            case 0:
              reviewItem = document.querySelector(".bulk-review-item[data-index=\"".concat(index, "\"]"));
              selectedRadio = reviewItem.querySelector("input[name=\"review-match-".concat(index, "\"]:checked"));
              if (selectedRadio) {
                _context24.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select a match first');
              return _context24.a(2);
            case 1:
              targetId = parseInt(selectedRadio.value);
              _context24.p = 2;
              _context24.n = 3;
              return this.linkTransactions(transactionId, targetId);
            case 3:
              // Remove the review item from the UI
              reviewItem.remove();

              // Update counts
              reviewCountEl = document.getElementById('needs-review-count');
              autoCountEl = document.getElementById('auto-matched-count');
              currentReviewCount = parseInt(reviewCountEl.textContent);
              currentAutoCount = parseInt(autoCountEl.textContent);
              reviewCountEl.textContent = currentReviewCount - 1;
              autoCountEl.textContent = currentAutoCount + 1;

              // Check if review section is now empty
              needsReviewList = document.getElementById('needs-review-list');
              if (needsReviewList.children.length === 0) {
                document.getElementById('needs-review-section').style.display = 'none';
              }
              OC.Notification.showTemporary('Transactions linked');
              _context24.n = 5;
              break;
            case 4:
              _context24.p = 4;
              _t4 = _context24.v;
              OC.Notification.showTemporary(_t4.message || 'Failed to link transactions');
            case 5:
              return _context24.a(2);
          }
        }, _callee24, this, [[2, 4]]);
      }));
      function handleBulkMatchLink(_x16, _x17) {
        return _handleBulkMatchLink.apply(this, arguments);
      }
      return handleBulkMatchLink;
    }()
    /**
     * Escape HTML to prevent XSS (utility method)
     */
    // =====================
    // Pensions Methods
    // =====================
    )
  }, {
    key: "loadTransactions",
    value: function () {
      var _loadTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee25() {
        var accountId,
          _this$transactionFilt,
          _this$transactionFilt2,
          _this$transactionFilt3,
          _this$transactionFilt4,
          url,
          params,
          response,
          result,
          tbody,
          _args25 = arguments,
          _t5;
        return _regenerator().w(function (_context25) {
          while (1) switch (_context25.p = _context25.n) {
            case 0:
              accountId = _args25.length > 0 && _args25[0] !== undefined ? _args25[0] : null;
              _context25.p = 1;
              // Initialize default values for enhanced features
              this.currentPage = this.currentPage || 1;
              this.rowsPerPage = this.rowsPerPage || 100;
              this.currentSort = this.currentSort || {
                field: 'date',
                direction: 'desc'
              };

              // Build query parameters - start with basic compatibility
              url = '/apps/budget/api/transactions?limit=' + this.rowsPerPage + '&page=' + this.currentPage; // Add account filter if provided
              if (accountId) {
                url += "&accountId=".concat(accountId);
              } else if ((_this$transactionFilt = this.transactionFilters) !== null && _this$transactionFilt !== void 0 && _this$transactionFilt.account) {
                url += "&accountId=".concat(this.transactionFilters.account);
              }

              // Try to add enhanced parameters, but don't break if backend doesn't support them
              params = new URLSearchParams(); // Basic parameters that should be safe
              if ((_this$transactionFilt2 = this.transactionFilters) !== null && _this$transactionFilt2 !== void 0 && _this$transactionFilt2.search) {
                params.append('search', this.transactionFilters.search);
              }
              if ((_this$transactionFilt3 = this.transactionFilters) !== null && _this$transactionFilt3 !== void 0 && _this$transactionFilt3.dateFrom) {
                params.append('dateFrom', this.transactionFilters.dateFrom);
              }
              if ((_this$transactionFilt4 = this.transactionFilters) !== null && _this$transactionFilt4 !== void 0 && _this$transactionFilt4.dateTo) {
                params.append('dateTo', this.transactionFilters.dateTo);
              }
              if (params.toString()) {
                url += '&' + params.toString();
              }
              _context25.n = 2;
              return fetch(OC.generateUrl(url), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context25.v;
              if (response.ok) {
                _context25.n = 3;
                break;
              }
              throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
            case 3:
              _context25.n = 4;
              return response.json();
            case 4:
              result = _context25.v;
              this.transactions = Array.isArray(result) ? result : result.transactions || result;

              // Load tags for all displayed transactions
              _context25.n = 5;
              return this.loadAllTransactionTags();
            case 5:
              // Apply client-side filtering if backend doesn't support it
              this.applyClientSideFilters();

              // Update UI with transaction data
              tbody = document.querySelector('#transactions-table tbody');
              if (tbody) {
                // Always use enhanced rendering for inline editing support
                this.renderEnhancedTransactionsTable();
                this.applyColumnVisibility();
              }

              // Update enhanced UI elements if they exist
              this.updateTransactionsSummary(result);
              this.updatePagination(result);
              _context25.n = 7;
              break;
            case 6:
              _context25.p = 6;
              _t5 = _context25.v;
              console.error('Failed to load transactions:', _t5);
              OC.Notification.showTemporary('Failed to load transactions');
            case 7:
              return _context25.a(2);
          }
        }, _callee25, this, [[1, 6]]);
      }));
      function loadTransactions() {
        return _loadTransactions.apply(this, arguments);
      }
      return loadTransactions;
    }()
  }, {
    key: "applyClientSideFilters",
    value: function applyClientSideFilters() {
      var _this7 = this,
        _this$currentSort;
      if (!this.transactions || !this.transactionFilters) return;
      var filtered = _toConsumableArray(this.transactions);

      // Apply filters that weren't handled by backend
      if (this.transactionFilters.category) {
        if (this.transactionFilters.category === 'uncategorized') {
          filtered = filtered.filter(function (t) {
            return !t.categoryId;
          });
        } else {
          filtered = filtered.filter(function (t) {
            return t.categoryId === parseInt(_this7.transactionFilters.category);
          });
        }
      }
      if (this.transactionFilters.type) {
        filtered = filtered.filter(function (t) {
          return t.type === _this7.transactionFilters.type;
        });
      }
      if (this.transactionFilters.amountMin) {
        var min = parseFloat(this.transactionFilters.amountMin);
        filtered = filtered.filter(function (t) {
          return t.amount >= min;
        });
      }
      if (this.transactionFilters.amountMax) {
        var max = parseFloat(this.transactionFilters.amountMax);
        filtered = filtered.filter(function (t) {
          return t.amount <= max;
        });
      }

      // Apply sorting
      if ((_this$currentSort = this.currentSort) !== null && _this$currentSort !== void 0 && _this$currentSort.field) {
        filtered.sort(function (a, b) {
          var aVal = a[_this7.currentSort.field];
          var bVal = b[_this7.currentSort.field];

          // Handle date sorting
          if (_this7.currentSort.field === 'date') {
            aVal = new Date(aVal);
            bVal = new Date(bVal);
          }

          // Handle amount sorting
          if (_this7.currentSort.field === 'amount') {
            aVal = parseFloat(aVal);
            bVal = parseFloat(bVal);
          }
          if (aVal < bVal) return _this7.currentSort.direction === 'asc' ? -1 : 1;
          if (aVal > bVal) return _this7.currentSort.direction === 'asc' ? 1 : -1;
          return 0;
        });
      }
      this.transactions = filtered;
    }
  }, {
    key: "updateTransactionsSummary",
    value: function updateTransactionsSummary(result) {
      var _this8 = this;
      var countElement = document.getElementById('transactions-count');
      var totalElement = document.getElementById('transactions-total');
      if (countElement && this.transactions) {
        var totalTransactions = result.total || this.transactions.length;
        var displayedTransactions = this.transactions.length;
        countElement.textContent = result.total ? "".concat(displayedTransactions, " of ").concat(totalTransactions, " transactions") : "".concat(displayedTransactions, " transactions");
      }
      if (totalElement && this.transactions) {
        var _Object$entries$sort$;
        var total = this.transactions.reduce(function (sum, t) {
          return sum + (t.type === 'credit' ? t.amount : -t.amount);
        }, 0);

        // Determine most common currency from displayed transactions
        var currencyCounts = {};
        this.transactions.forEach(function (t) {
          var currency = t.accountCurrency || _this8.getPrimaryCurrency();
          currencyCounts[currency] = (currencyCounts[currency] || 0) + 1;
        });
        var mostCommonCurrency = ((_Object$entries$sort$ = Object.entries(currencyCounts).sort(function (a, b) {
          return b[1] - a[1];
        })[0]) === null || _Object$entries$sort$ === void 0 ? void 0 : _Object$entries$sort$[0]) || this.getPrimaryCurrency();
        totalElement.textContent = "Total: ".concat(this.formatCurrency(total, mostCommonCurrency));
      }
    }
  }, {
    key: "updatePagination",
    value: function updatePagination(result) {
      // Top pagination controls
      var pageInfo = document.getElementById('page-info');
      var prevBtn = document.getElementById('prev-page-btn');
      var nextBtn = document.getElementById('next-page-btn');
      // Bottom pagination controls
      var pageInfoBottom = document.getElementById('page-info-bottom');
      var prevBtnBottom = document.getElementById('prev-page-btn-bottom');
      var nextBtnBottom = document.getElementById('next-page-btn-bottom');

      // Only update pagination if at least one set of elements exist
      if (!pageInfo && !prevBtn && !nextBtn && !pageInfoBottom && !prevBtnBottom && !nextBtnBottom) return;
      if (result && result.total && result.totalPages) {
        var currentPage = this.currentPage || 1;
        var pageText = "Page ".concat(currentPage, " of ").concat(result.totalPages);
        var atFirstPage = currentPage <= 1;
        var atLastPage = currentPage >= result.totalPages;

        // Update top controls
        if (pageInfo) pageInfo.textContent = pageText;
        if (prevBtn) prevBtn.disabled = atFirstPage;
        if (nextBtn) nextBtn.disabled = atLastPage;

        // Update bottom controls
        if (pageInfoBottom) pageInfoBottom.textContent = pageText;
        if (prevBtnBottom) prevBtnBottom.disabled = atFirstPage;
        if (nextBtnBottom) nextBtnBottom.disabled = atLastPage;
      } else {
        // Hide pagination if not needed or not supported
        if (pageInfo) pageInfo.textContent = '';
        if (prevBtn) prevBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = true;
        if (pageInfoBottom) pageInfoBottom.textContent = '';
        if (prevBtnBottom) prevBtnBottom.disabled = true;
        if (nextBtnBottom) nextBtnBottom.disabled = true;
      }
    }

    // ============================================
    // Import Module Delegations
    // ============================================
  }, {
    key: "setupImportEventListeners",
    value: function setupImportEventListeners() {
      return this.importModule.setupImportEventListeners();
    }
  }, {
    key: "handleImportFile",
    value: function () {
      var _handleImportFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee26(file) {
        return _regenerator().w(function (_context26) {
          while (1) switch (_context26.n) {
            case 0:
              return _context26.a(2, this.importModule.handleImportFile(file));
          }
        }, _callee26, this);
      }));
      function handleImportFile(_x18) {
        return _handleImportFile.apply(this, arguments);
      }
      return handleImportFile;
    }() // ============================================
    // Forecast Module Delegations
    // ============================================
  }, {
    key: "setupForecastEventListeners",
    value: function setupForecastEventListeners() {
      // This method may not exist in ForecastModule yet
      // For now, just return to prevent errors
      if (this.forecastModule.setupForecastEventListeners) {
        return this.forecastModule.setupForecastEventListeners();
      }
    }

    // ===========================
    // Reports Management - delegated to ReportsModule
    // ===========================
  }, {
    key: "loadReportsView",
    value: function () {
      var _loadReportsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee27() {
        return _regenerator().w(function (_context27) {
          while (1) switch (_context27.n) {
            case 0:
              return _context27.a(2, this.reportsModule.loadReportsView());
          }
        }, _callee27, this);
      }));
      function loadReportsView() {
        return _loadReportsView.apply(this, arguments);
      }
      return loadReportsView;
    }() // ==========================================
    // Forecast - delegated to ForecastModule
    // ==========================================
  }, {
    key: "loadForecastView",
    value: function () {
      var _loadForecastView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee28() {
        return _regenerator().w(function (_context28) {
          while (1) switch (_context28.n) {
            case 0:
              return _context28.a(2, this.forecastModule.loadForecastView());
          }
        }, _callee28, this);
      }));
      function loadForecastView() {
        return _loadForecastView.apply(this, arguments);
      }
      return loadForecastView;
    }() // Shared Expenses - delegated to SharedExpensesModule
    // ===========================
  }, {
    key: "loadSharedExpensesView",
    value: function () {
      var _loadSharedExpensesView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee29() {
        return _regenerator().w(function (_context29) {
          while (1) switch (_context29.n) {
            case 0:
              return _context29.a(2, this.sharedExpensesModule.loadSharedExpensesView());
          }
        }, _callee29, this);
      }));
      function loadSharedExpensesView() {
        return _loadSharedExpensesView.apply(this, arguments);
      }
      return loadSharedExpensesView;
    }()
  }, {
    key: "showShareExpenseModal",
    value: function () {
      var _showShareExpenseModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee30(transaction) {
        return _regenerator().w(function (_context30) {
          while (1) switch (_context30.n) {
            case 0:
              return _context30.a(2, this.sharedExpensesModule.showShareExpenseModal(transaction));
          }
        }, _callee30, this);
      }));
      function showShareExpenseModal(_x19) {
        return _showShareExpenseModal.apply(this, arguments);
      }
      return showShareExpenseModal;
    }() // Settings Management
    // ===========================
  }, {
    key: "setupSettingsEventListeners",
    value: function setupSettingsEventListeners() {
      var _this9 = this;
      // Save buttons (both top and bottom)
      var saveButtons = [document.getElementById('save-settings-btn'), document.getElementById('save-settings-btn-bottom')];
      saveButtons.forEach(function (btn) {
        if (btn) {
          btn.addEventListener('click', function () {
            return _this9.saveSettings();
          });
        }
      });

      // Reset buttons (both top and bottom)
      var resetButtons = [document.getElementById('reset-settings-btn'), document.getElementById('reset-settings-btn-bottom')];
      resetButtons.forEach(function (btn) {
        if (btn) {
          btn.addEventListener('click', function () {
            return _this9.resetSettings();
          });
        }
      });

      // Number format preview update
      var numberFormatInputs = ['setting-number-format-decimals', 'setting-number-format-decimal-sep', 'setting-number-format-thousands-sep'];
      numberFormatInputs.forEach(function (id) {
        var element = document.getElementById(id);
        if (element) {
          element.addEventListener('change', function () {
            return _this9.updateNumberFormatPreview();
          });
        }
      });

      // Password protection event listeners
      this.setupPasswordProtectionEventListeners();

      // Migration event listeners
      this.setupMigrationEventListeners();

      // Factory reset event listeners
      this.setupFactoryResetEventListeners();
    }
  }, {
    key: "setupPasswordProtectionEventListeners",
    value: function setupPasswordProtectionEventListeners() {
      var _this0 = this;
      var passwordToggle = document.getElementById('setting-password-protection-enabled');
      var setupPasswordBtn = document.getElementById('setup-password-btn');
      var changePasswordBtn = document.getElementById('change-password-btn');
      var disablePasswordBtn = document.getElementById('disable-password-btn');
      var passwordConfig = document.getElementById('password-protection-config');
      if (passwordToggle) {
        passwordToggle.addEventListener('change', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee31() {
          return _regenerator().w(function (_context31) {
            while (1) switch (_context31.n) {
              case 0:
                if (passwordToggle.checked) {
                  // Show password setup UI
                  if (passwordConfig) {
                    passwordConfig.style.display = 'block';
                    _this0.updatePasswordButtons(false);
                  }
                } else {
                  // Hide password config
                  if (passwordConfig) {
                    passwordConfig.style.display = 'none';
                  }
                }
              case 1:
                return _context31.a(2);
            }
          }, _callee31);
        })));
      }
      if (setupPasswordBtn) {
        setupPasswordBtn.addEventListener('click', function () {
          return _this0.showSetupPasswordModal();
        });
      }
      if (changePasswordBtn) {
        changePasswordBtn.addEventListener('click', function () {
          return _this0.showChangePasswordModal();
        });
      }
      if (disablePasswordBtn) {
        disablePasswordBtn.addEventListener('click', function () {
          return _this0.showDisablePasswordModal();
        });
      }
    }
  }, {
    key: "updatePasswordButtons",
    value: function updatePasswordButtons(hasPassword) {
      var setupBtn = document.getElementById('setup-password-btn');
      var changeBtn = document.getElementById('change-password-btn');
      var disableBtn = document.getElementById('disable-password-btn');
      if (setupBtn) setupBtn.style.display = hasPassword ? 'none' : 'inline-block';
      if (changeBtn) changeBtn.style.display = hasPassword ? 'inline-block' : 'none';
      if (disableBtn) disableBtn.style.display = hasPassword ? 'inline-block' : 'none';
    }
  }, {
    key: "showSetupPasswordModal",
    value: function showSetupPasswordModal() {
      var _this1 = this;
      var modal = document.createElement('div');
      modal.id = 'setup-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Set Up Password Protection</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <p>Enter a password to protect your budget app. You will need to enter this password when accessing the app.</p>\n                    <form id=\"setup-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"new-password\">New Password</label>\n                            <input type=\"password\" id=\"new-password\" class=\"budget-input\" required minlength=\"6\" autocomplete=\"new-password\">\n                            <small>Minimum 6 characters</small>\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"confirm-password\">Confirm Password</label>\n                            <input type=\"password\" id=\"confirm-password\" class=\"budget-input\" required autocomplete=\"new-password\">\n                        </div>\n                        <div id=\"setup-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Set Password</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('setup-password-form');
      var newPasswordInput = document.getElementById('new-password');
      var confirmPasswordInput = document.getElementById('confirm-password');
      var errorDiv = document.getElementById('setup-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee32(e) {
          var newPassword, confirmPassword, response, result, _t6;
          return _regenerator().w(function (_context32) {
            while (1) switch (_context32.p = _context32.n) {
              case 0:
                e.preventDefault();
                newPassword = newPasswordInput.value;
                confirmPassword = confirmPasswordInput.value;
                if (!(newPassword !== confirmPassword)) {
                  _context32.n = 1;
                  break;
                }
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.style.display = 'block';
                return _context32.a(2);
              case 1:
                _context32.p = 1;
                _context32.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/setup'), {
                  method: 'POST',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this1.getAuthHeaders()),
                  body: JSON.stringify({
                    password: newPassword
                  })
                });
              case 2:
                response = _context32.v;
                _context32.n = 3;
                return response.json();
              case 3:
                result = _context32.v;
                if (response.ok && result.success) {
                  // Store session token
                  _this1.sessionToken = result.sessionToken;
                  localStorage.setItem('budget_session_token', result.sessionToken);
                  OC.Notification.showTemporary('Password protection enabled');
                  modal.remove();

                  // Update UI
                  _this1.updatePasswordButtons(true);
                } else {
                  errorDiv.textContent = result.error || 'Failed to set password';
                  errorDiv.style.display = 'block';
                }
                _context32.n = 5;
                break;
              case 4:
                _context32.p = 4;
                _t6 = _context32.v;
                console.error('Failed to set password:', _t6);
                errorDiv.textContent = 'Failed to set password. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context32.a(2);
            }
          }, _callee32, null, [[1, 4]]);
        }));
        return function (_x20) {
          return _ref2.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      newPasswordInput.focus();
    }
  }, {
    key: "showChangePasswordModal",
    value: function showChangePasswordModal() {
      var _this10 = this;
      var modal = document.createElement('div');
      modal.id = 'change-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Change Password</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <form id=\"change-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"current-password\">Current Password</label>\n                            <input type=\"password\" id=\"current-password\" class=\"budget-input\" required autocomplete=\"current-password\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"new-password-change\">New Password</label>\n                            <input type=\"password\" id=\"new-password-change\" class=\"budget-input\" required minlength=\"6\" autocomplete=\"new-password\">\n                            <small>Minimum 6 characters</small>\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"confirm-password-change\">Confirm New Password</label>\n                            <input type=\"password\" id=\"confirm-password-change\" class=\"budget-input\" required autocomplete=\"new-password\">\n                        </div>\n                        <div id=\"change-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Change Password</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('change-password-form');
      var currentPasswordInput = document.getElementById('current-password');
      var newPasswordInput = document.getElementById('new-password-change');
      var confirmPasswordInput = document.getElementById('confirm-password-change');
      var errorDiv = document.getElementById('change-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee33(e) {
          var currentPassword, newPassword, confirmPassword, response, result, _t7;
          return _regenerator().w(function (_context33) {
            while (1) switch (_context33.p = _context33.n) {
              case 0:
                e.preventDefault();
                currentPassword = currentPasswordInput.value;
                newPassword = newPasswordInput.value;
                confirmPassword = confirmPasswordInput.value;
                if (!(newPassword !== confirmPassword)) {
                  _context33.n = 1;
                  break;
                }
                errorDiv.textContent = 'New passwords do not match';
                errorDiv.style.display = 'block';
                return _context33.a(2);
              case 1:
                _context33.p = 1;
                _context33.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/password'), {
                  method: 'PUT',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this10.getAuthHeaders()),
                  body: JSON.stringify({
                    currentPassword: currentPassword,
                    newPassword: newPassword
                  })
                });
              case 2:
                response = _context33.v;
                _context33.n = 3;
                return response.json();
              case 3:
                result = _context33.v;
                if (response.ok && result.success) {
                  OC.Notification.showTemporary('Password changed successfully');
                  modal.remove();
                } else {
                  errorDiv.textContent = result.error || 'Failed to change password';
                  errorDiv.style.display = 'block';
                }
                _context33.n = 5;
                break;
              case 4:
                _context33.p = 4;
                _t7 = _context33.v;
                console.error('Failed to change password:', _t7);
                errorDiv.textContent = 'Failed to change password. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context33.a(2);
            }
          }, _callee33, null, [[1, 4]]);
        }));
        return function (_x21) {
          return _ref3.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      currentPasswordInput.focus();
    }
  }, {
    key: "showDisablePasswordModal",
    value: function showDisablePasswordModal() {
      var _this11 = this;
      var modal = document.createElement('div');
      modal.id = 'disable-password-modal';
      modal.className = 'budget-modal-overlay';
      modal.innerHTML = "\n            <div class=\"budget-modal\">\n                <div class=\"budget-modal-header\">\n                    <h2>Disable Password Protection</h2>\n                    <button class=\"close-btn\">\xD7</button>\n                </div>\n                <div class=\"budget-modal-body\">\n                    <p>Enter your current password to disable password protection.</p>\n                    <form id=\"disable-password-form\">\n                        <div class=\"form-group\">\n                            <label for=\"disable-current-password\">Current Password</label>\n                            <input type=\"password\" id=\"disable-current-password\" class=\"budget-input\" required autocomplete=\"current-password\">\n                        </div>\n                        <div id=\"disable-password-error\" class=\"error-message\" style=\"display: none;\"></div>\n                        <div class=\"form-actions\">\n                            <button type=\"button\" class=\"budget-btn secondary close-btn\">Cancel</button>\n                            <button type=\"submit\" class=\"budget-btn primary\">Disable Protection</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        ";
      document.body.appendChild(modal);
      var form = document.getElementById('disable-password-form');
      var passwordInput = document.getElementById('disable-current-password');
      var errorDiv = document.getElementById('disable-password-error');
      form.addEventListener('submit', /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee34(e) {
          var password, response, result, passwordToggle, passwordConfig, _t8;
          return _regenerator().w(function (_context34) {
            while (1) switch (_context34.p = _context34.n) {
              case 0:
                e.preventDefault();
                password = passwordInput.value;
                _context34.p = 1;
                _context34.n = 2;
                return fetch(OC.generateUrl('/apps/budget/api/auth/disable'), {
                  method: 'DELETE',
                  headers: _objectSpread({
                    'Content-Type': 'application/json'
                  }, _this11.getAuthHeaders()),
                  body: JSON.stringify({
                    password: password
                  })
                });
              case 2:
                response = _context34.v;
                _context34.n = 3;
                return response.json();
              case 3:
                result = _context34.v;
                if (response.ok && result.success) {
                  // Update UI
                  passwordToggle = document.getElementById('setting-password-protection-enabled');
                  if (passwordToggle) passwordToggle.checked = false;
                  passwordConfig = document.getElementById('password-protection-config');
                  if (passwordConfig) passwordConfig.style.display = 'none';
                  OC.Notification.showTemporary('Password protection disabled');
                  modal.remove();
                } else {
                  errorDiv.textContent = result.error || 'Failed to disable password protection';
                  errorDiv.style.display = 'block';
                }
                _context34.n = 5;
                break;
              case 4:
                _context34.p = 4;
                _t8 = _context34.v;
                console.error('Failed to disable password protection:', _t8);
                errorDiv.textContent = 'Failed to disable password protection. Please try again.';
                errorDiv.style.display = 'block';
              case 5:
                return _context34.a(2);
            }
          }, _callee34, null, [[1, 4]]);
        }));
        return function (_x22) {
          return _ref4.apply(this, arguments);
        };
      }());

      // Close modal handlers
      modal.querySelectorAll('.close-btn').forEach(function (btn) {
        btn.addEventListener('click', function () {
          return modal.remove();
        });
      });
      modal.addEventListener('click', function (e) {
        if (e.target === modal) modal.remove();
      });
      passwordInput.focus();
    }
  }, {
    key: "setupFactoryResetEventListeners",
    value: function setupFactoryResetEventListeners() {
      var _this12 = this;
      var factoryResetBtn = document.getElementById('factory-reset-btn');
      var factoryResetModal = document.getElementById('factory-reset-modal');
      var factoryResetInput = document.getElementById('factory-reset-confirm-input');
      var factoryResetConfirmBtn = document.getElementById('factory-reset-confirm-btn');
      var modalCloseButtons = factoryResetModal ? factoryResetModal.querySelectorAll('.close-btn') : [];

      // Open modal
      if (factoryResetBtn) {
        factoryResetBtn.addEventListener('click', function () {
          _this12.openFactoryResetModal();
        });
      }

      // Enable/disable confirm button based on input value
      if (factoryResetInput && factoryResetConfirmBtn) {
        factoryResetInput.addEventListener('input', function (e) {
          // User must type exactly "DELETE" (case-sensitive)
          factoryResetConfirmBtn.disabled = e.target.value !== 'DELETE';
        });
      }

      // Confirm button
      if (factoryResetConfirmBtn) {
        factoryResetConfirmBtn.addEventListener('click', function () {
          _this12.executeFactoryReset();
        });
      }

      // Close modal buttons
      modalCloseButtons.forEach(function (btn) {
        btn.addEventListener('click', function () {
          _this12.closeFactoryResetModal();
        });
      });

      // Close modal on background click
      if (factoryResetModal) {
        factoryResetModal.addEventListener('click', function (e) {
          if (e.target === factoryResetModal) {
            _this12.closeFactoryResetModal();
          }
        });
      }
    }
  }, {
    key: "openFactoryResetModal",
    value: function openFactoryResetModal() {
      var modal = document.getElementById('factory-reset-modal');
      var input = document.getElementById('factory-reset-confirm-input');
      var confirmBtn = document.getElementById('factory-reset-confirm-btn');
      if (modal) {
        // Reset input and button state
        if (input) {
          input.value = '';
          input.focus(); // Auto-focus the input field
        }
        if (confirmBtn) confirmBtn.disabled = true;
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
      }
    }
  }, {
    key: "closeFactoryResetModal",
    value: function closeFactoryResetModal() {
      var modal = document.getElementById('factory-reset-modal');
      if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
      }
    }
  }, {
    key: "executeFactoryReset",
    value: function () {
      var _executeFactoryReset = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee35() {
        var confirmBtn, response, data, _confirmBtn, _t9;
        return _regenerator().w(function (_context35) {
          while (1) switch (_context35.p = _context35.n) {
            case 0:
              _context35.p = 0;
              // Show loading state
              confirmBtn = document.getElementById('factory-reset-confirm-btn');
              if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.innerHTML = '<span class="icon-loading-small" aria-hidden="true"></span> Deleting...';
              }
              _context35.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/setup/factory-reset'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  confirmed: true
                })
              });
            case 1:
              response = _context35.v;
              _context35.n = 2;
              return response.json();
            case 2:
              data = _context35.v;
              if (response.ok) {
                _context35.n = 3;
                break;
              }
              throw new Error(data.error || 'Factory reset failed');
            case 3:
              // Close modal
              this.closeFactoryResetModal();

              // Show success message
              OC.Notification.showTemporary('Factory reset completed successfully. All data has been deleted.');

              // Reload the page to show empty state
              setTimeout(function () {
                window.location.reload();
              }, 1500);
              _context35.n = 5;
              break;
            case 4:
              _context35.p = 4;
              _t9 = _context35.v;
              console.error('Factory reset error:', _t9);

              // Reset button state
              _confirmBtn = document.getElementById('factory-reset-confirm-btn');
              if (_confirmBtn) {
                _confirmBtn.disabled = false;
                _confirmBtn.innerHTML = '<span class="icon-delete" aria-hidden="true"></span> Delete Everything';
              }
              OC.Notification.showTemporary(_t9.message || 'Failed to perform factory reset');
            case 5:
              return _context35.a(2);
          }
        }, _callee35, this, [[0, 4]]);
      }));
      function executeFactoryReset() {
        return _executeFactoryReset.apply(this, arguments);
      }
      return executeFactoryReset;
    }()
  }, {
    key: "setupMigrationEventListeners",
    value: function setupMigrationEventListeners() {
      var _this13 = this;
      // Export button
      var exportBtn = document.getElementById('migration-export-btn');
      if (exportBtn) {
        exportBtn.addEventListener('click', function () {
          return _this13.handleMigrationExport();
        });
      }

      // Import dropzone
      var dropzone = document.getElementById('migration-import-dropzone');
      var fileInput = document.getElementById('migration-file-input');
      var browseBtn = document.getElementById('migration-browse-btn');
      if (dropzone) {
        dropzone.addEventListener('dragover', function (e) {
          e.preventDefault();
          dropzone.classList.add('dragover');
        });
        dropzone.addEventListener('dragleave', function () {
          dropzone.classList.remove('dragover');
        });
        dropzone.addEventListener('drop', function (e) {
          e.preventDefault();
          dropzone.classList.remove('dragover');
          var files = e.dataTransfer.files;
          if (files.length > 0) {
            _this13.handleMigrationFileSelect(files[0]);
          }
        });
      }
      if (browseBtn && fileInput) {
        browseBtn.addEventListener('click', function () {
          return fileInput.click();
        });
      }
      if (fileInput) {
        fileInput.addEventListener('change', function (e) {
          var file = e.target.files[0];
          if (file) {
            _this13.handleMigrationFileSelect(file);
          }
        });
      }

      // Import action buttons
      var cancelBtn = document.getElementById('migration-cancel-btn');
      var confirmBtn = document.getElementById('migration-confirm-btn');
      var doneBtn = document.getElementById('migration-done-btn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', function () {
          return _this13.cancelMigrationImport();
        });
      }
      if (confirmBtn) {
        confirmBtn.addEventListener('click', function () {
          return _this13.confirmMigrationImport();
        });
      }
      if (doneBtn) {
        doneBtn.addEventListener('click', function () {
          return _this13.resetMigrationUI();
        });
      }
    }
  }, {
    key: "handleMigrationExport",
    value: function () {
      var _handleMigrationExport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee36() {
        var exportBtn, originalText, response, contentDisposition, filename, match, blob, url, a, _t0;
        return _regenerator().w(function (_context36) {
          while (1) switch (_context36.p = _context36.n) {
            case 0:
              exportBtn = document.getElementById('migration-export-btn');
              originalText = exportBtn.innerHTML;
              _context36.p = 1;
              exportBtn.disabled = true;
              exportBtn.innerHTML = '<span class="icon-loading-small"></span> Exporting...';
              _context36.n = 2;
              return fetch(OC.generateUrl('/apps/budget/api/migration/export'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context36.v;
              if (response.ok) {
                _context36.n = 3;
                break;
              }
              throw new Error('Export failed');
            case 3:
              // Get filename from Content-Disposition header or use default
              contentDisposition = response.headers.get('Content-Disposition');
              filename = 'budget_export.zip';
              if (contentDisposition) {
                match = contentDisposition.match(/filename="([^"]+)"/);
                if (match) {
                  filename = match[1];
                }
              }

              // Download the file
              _context36.n = 4;
              return response.blob();
            case 4:
              blob = _context36.v;
              url = window.URL.createObjectURL(blob);
              a = document.createElement('a');
              a.href = url;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              OC.Notification.showTemporary('Export completed successfully');
              _context36.n = 6;
              break;
            case 5:
              _context36.p = 5;
              _t0 = _context36.v;
              console.error('Export error:', _t0);
              OC.Notification.showTemporary('Failed to export data: ' + _t0.message);
            case 6:
              _context36.p = 6;
              exportBtn.disabled = false;
              exportBtn.innerHTML = originalText;
              return _context36.f(6);
            case 7:
              return _context36.a(2);
          }
        }, _callee36, null, [[1, 5, 6, 7]]);
      }));
      function handleMigrationExport() {
        return _handleMigrationExport.apply(this, arguments);
      }
      return handleMigrationExport;
    }()
  }, {
    key: "handleMigrationFileSelect",
    value: function () {
      var _handleMigrationFileSelect = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee37(file) {
        var dropzone, preview, progress, _result$manifest, _result$manifest2, _result$counts, _result$counts2, _result$counts3, _result$counts4, _result$counts5, _result$counts6, formData, response, result, warningsDiv, _t1;
        return _regenerator().w(function (_context37) {
          while (1) switch (_context37.p = _context37.n) {
            case 0:
              if (file.name.endsWith('.zip')) {
                _context37.n = 1;
                break;
              }
              OC.Notification.showTemporary('Please select a ZIP file');
              return _context37.a(2);
            case 1:
              this.migrationFile = file;

              // Show preview
              dropzone = document.getElementById('migration-import-dropzone');
              preview = document.getElementById('migration-preview');
              progress = document.getElementById('migration-progress');
              dropzone.style.display = 'none';
              progress.style.display = 'block';
              document.getElementById('migration-progress-text').textContent = 'Validating file...';
              _context37.p = 2;
              formData = new FormData();
              formData.append('file', file);
              _context37.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/migration/preview'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                },
                body: formData
              });
            case 3:
              response = _context37.v;
              _context37.n = 4;
              return response.json();
            case 4:
              result = _context37.v;
              if (!(!response.ok || !result.valid)) {
                _context37.n = 5;
                break;
              }
              throw new Error(result.error || 'Invalid export file');
            case 5:
              // Populate preview
              document.getElementById('preview-version').textContent = ((_result$manifest = result.manifest) === null || _result$manifest === void 0 ? void 0 : _result$manifest.version) || 'Unknown';
              document.getElementById('preview-date').textContent = (_result$manifest2 = result.manifest) !== null && _result$manifest2 !== void 0 && _result$manifest2.exportedAt ? new Date(result.manifest.exportedAt).toLocaleString() : 'Unknown';
              document.getElementById('preview-categories').textContent = ((_result$counts = result.counts) === null || _result$counts === void 0 ? void 0 : _result$counts.categories) || 0;
              document.getElementById('preview-accounts').textContent = ((_result$counts2 = result.counts) === null || _result$counts2 === void 0 ? void 0 : _result$counts2.accounts) || 0;
              document.getElementById('preview-transactions').textContent = ((_result$counts3 = result.counts) === null || _result$counts3 === void 0 ? void 0 : _result$counts3.transactions) || 0;
              document.getElementById('preview-bills').textContent = ((_result$counts4 = result.counts) === null || _result$counts4 === void 0 ? void 0 : _result$counts4.bills) || 0;
              document.getElementById('preview-rules').textContent = ((_result$counts5 = result.counts) === null || _result$counts5 === void 0 ? void 0 : _result$counts5.importRules) || 0;
              document.getElementById('preview-settings').textContent = ((_result$counts6 = result.counts) === null || _result$counts6 === void 0 ? void 0 : _result$counts6.settings) || 0;

              // Show warnings if any
              warningsDiv = document.getElementById('migration-warnings');
              if (result.warnings && result.warnings.length > 0) {
                warningsDiv.innerHTML = result.warnings.map(function (w) {
                  return "<div class=\"warning-item\"><span class=\"icon-info\"></span> ".concat(w, "</div>");
                }).join('');
                warningsDiv.style.display = 'block';
              } else {
                warningsDiv.style.display = 'none';
              }
              progress.style.display = 'none';
              preview.style.display = 'block';
              _context37.n = 7;
              break;
            case 6:
              _context37.p = 6;
              _t1 = _context37.v;
              console.error('Preview error:', _t1);
              OC.Notification.showTemporary('Failed to preview file: ' + _t1.message);
              this.resetMigrationUI();
            case 7:
              return _context37.a(2);
          }
        }, _callee37, this, [[2, 6]]);
      }));
      function handleMigrationFileSelect(_x23) {
        return _handleMigrationFileSelect.apply(this, arguments);
      }
      return handleMigrationFileSelect;
    }()
  }, {
    key: "cancelMigrationImport",
    value: function cancelMigrationImport() {
      this.migrationFile = null;
      this.resetMigrationUI();
    }
  }, {
    key: "confirmMigrationImport",
    value: function () {
      var _confirmMigrationImport = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee38() {
        var preview, progress, result, formData, response, data, resultContent, _resultContent, _t10;
        return _regenerator().w(function (_context38) {
          while (1) switch (_context38.p = _context38.n) {
            case 0:
              if (this.migrationFile) {
                _context38.n = 1;
                break;
              }
              OC.Notification.showTemporary('No file selected');
              return _context38.a(2);
            case 1:
              if (confirm('This will PERMANENTLY DELETE all your existing data and replace it with the imported data.\n\nAre you absolutely sure you want to continue?')) {
                _context38.n = 2;
                break;
              }
              return _context38.a(2);
            case 2:
              preview = document.getElementById('migration-preview');
              progress = document.getElementById('migration-progress');
              result = document.getElementById('migration-result');
              preview.style.display = 'none';
              progress.style.display = 'block';
              document.getElementById('migration-progress-text').textContent = 'Importing data... This may take a moment.';
              _context38.p = 3;
              formData = new FormData();
              formData.append('file', this.migrationFile);
              formData.append('confirmed', 'true');
              _context38.n = 4;
              return fetch(OC.generateUrl('/apps/budget/api/migration/import'), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                },
                body: formData
              });
            case 4:
              response = _context38.v;
              _context38.n = 5;
              return response.json();
            case 5:
              data = _context38.v;
              progress.style.display = 'none';
              if (!(!response.ok || !data.success)) {
                _context38.n = 6;
                break;
              }
              throw new Error(data.error || 'Import failed');
            case 6:
              // Show success result
              resultContent = document.getElementById('migration-result-content');
              resultContent.innerHTML = "\n                <div class=\"result-success\">\n                    <span class=\"icon-checkmark-color\"></span>\n                    <h5>Import Successful!</h5>\n                    <p>Your data has been imported successfully.</p>\n                    <div class=\"result-counts\">\n                        <div class=\"result-count\"><strong>".concat(data.counts.categories, "</strong> categories</div>\n                        <div class=\"result-count\"><strong>").concat(data.counts.accounts, "</strong> accounts</div>\n                        <div class=\"result-count\"><strong>").concat(data.counts.transactions, "</strong> transactions</div>\n                        <div class=\"result-count\"><strong>").concat(data.counts.bills, "</strong> bills</div>\n                        <div class=\"result-count\"><strong>").concat(data.counts.importRules, "</strong> import rules</div>\n                        <div class=\"result-count\"><strong>").concat(data.counts.settings, "</strong> settings</div>\n                    </div>\n                </div>\n            ");
              result.style.display = 'block';

              // Reload application data
              this.loadInitialData();
              OC.Notification.showTemporary('Import completed successfully');
              _context38.n = 8;
              break;
            case 7:
              _context38.p = 7;
              _t10 = _context38.v;
              console.error('Import error:', _t10);
              _resultContent = document.getElementById('migration-result-content');
              _resultContent.innerHTML = "\n                <div class=\"result-error\">\n                    <span class=\"icon-error-color\"></span>\n                    <h5>Import Failed</h5>\n                    <p>".concat(_t10.message, "</p>\n                    <p class=\"result-hint\">Your existing data has not been modified.</p>\n                </div>\n            ");
              result.style.display = 'block';
              progress.style.display = 'none';
            case 8:
              return _context38.a(2);
          }
        }, _callee38, this, [[3, 7]]);
      }));
      function confirmMigrationImport() {
        return _confirmMigrationImport.apply(this, arguments);
      }
      return confirmMigrationImport;
    }()
  }, {
    key: "resetMigrationUI",
    value: function resetMigrationUI() {
      this.migrationFile = null;
      var dropzone = document.getElementById('migration-import-dropzone');
      var preview = document.getElementById('migration-preview');
      var progress = document.getElementById('migration-progress');
      var result = document.getElementById('migration-result');
      var fileInput = document.getElementById('migration-file-input');
      dropzone.style.display = 'block';
      preview.style.display = 'none';
      progress.style.display = 'none';
      result.style.display = 'none';
      if (fileInput) {
        fileInput.value = '';
      }
    }

    // Settings - delegated to SettingsModule
  }, {
    key: "loadSettingsView",
    value: function () {
      var _loadSettingsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee39() {
        return _regenerator().w(function (_context39) {
          while (1) switch (_context39.n) {
            case 0:
              return _context39.a(2, this.settingsModule.loadSettingsView());
          }
        }, _callee39, this);
      }));
      function loadSettingsView() {
        return _loadSettingsView.apply(this, arguments);
      }
      return loadSettingsView;
    }() // ==========================================
    // Bills Management - delegated to BillsModule
    // ==========================================
  }, {
    key: "loadBillsView",
    value: function () {
      var _loadBillsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee40() {
        return _regenerator().w(function (_context40) {
          while (1) switch (_context40.n) {
            case 0:
              return _context40.a(2, this.billsModule.loadBillsView());
          }
        }, _callee40, this);
      }));
      function loadBillsView() {
        return _loadBillsView.apply(this, arguments);
      }
      return loadBillsView;
    }()
  }, {
    key: "loadRulesView",
    value: function () {
      var _loadRulesView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee41() {
        return _regenerator().w(function (_context41) {
          while (1) switch (_context41.n) {
            case 0:
              return _context41.a(2, this.rulesModule.loadRulesView());
          }
        }, _callee41, this);
      }));
      function loadRulesView() {
        return _loadRulesView.apply(this, arguments);
      }
      return loadRulesView;
    }() // ============================================
    // RECURRING INCOME METHODS
    // ============================================
  }, {
    key: "loadIncomeView",
    value: function () {
      var _loadIncomeView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee42() {
        return _regenerator().w(function (_context42) {
          while (1) switch (_context42.n) {
            case 0:
              return _context42.a(2, this.incomeModule.loadIncomeView());
          }
        }, _callee42, this);
      }));
      function loadIncomeView() {
        return _loadIncomeView.apply(this, arguments);
      }
      return loadIncomeView;
    }()
  }, {
    key: "loadIncomeSummary",
    value: function () {
      var _loadIncomeSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee43() {
        return _regenerator().w(function (_context43) {
          while (1) switch (_context43.n) {
            case 0:
              return _context43.a(2, this.incomeModule.loadIncomeSummary());
          }
        }, _callee43, this);
      }));
      function loadIncomeSummary() {
        return _loadIncomeSummary.apply(this, arguments);
      }
      return loadIncomeSummary;
    }()
  }, {
    key: "renderRecurringIncome",
    value: function renderRecurringIncome(incomeItems) {
      return this.incomeModule.renderRecurringIncome(incomeItems);
    }
  }, {
    key: "isIncomeReceivedThisMonth",
    value: function isIncomeReceivedThisMonth(income) {
      return this.incomeModule.isIncomeReceivedThisMonth(income);
    }
  }, {
    key: "isExpectedSoon",
    value: function isExpectedSoon(dateStr) {
      return this.incomeModule.isExpectedSoon(dateStr);
    }
  }, {
    key: "filterIncome",
    value: function filterIncome(filter) {
      return this.incomeModule.filterIncome(filter);
    }
  }, {
    key: "setupIncomeEventListeners",
    value: function setupIncomeEventListeners() {
      return this.incomeModule.setupIncomeEventListeners();
    }
  }, {
    key: "showIncomeModal",
    value: function showIncomeModal() {
      var income = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return this.incomeModule.showIncomeModal(income);
    }
  }, {
    key: "hideIncomeModal",
    value: function hideIncomeModal() {
      return this.incomeModule.hideIncomeModal();
    }
  }, {
    key: "updateIncomeFormFields",
    value: function updateIncomeFormFields() {
      return this.incomeModule.updateIncomeFormFields();
    }
  }, {
    key: "renderDetectedIncome",
    value: function renderDetectedIncome(detected) {
      return this.incomeModule.renderDetectedIncome(detected);
    }
  }, {
    key: "addSelectedDetectedIncome",
    value: function () {
      var _addSelectedDetectedIncome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee44() {
        return _regenerator().w(function (_context44) {
          while (1) switch (_context44.n) {
            case 0:
              return _context44.a(2, this.incomeModule.addSelectedDetectedIncome());
          }
        }, _callee44, this);
      }));
      function addSelectedDetectedIncome() {
        return _addSelectedDetectedIncome.apply(this, arguments);
      }
      return addSelectedDetectedIncome;
    }() // ============================================
    // SAVINGS GOALS METHODS
    // ============================================
  }, {
    key: "loadSavingsGoalsView",
    value: function () {
      var _loadSavingsGoalsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee45() {
        return _regenerator().w(function (_context45) {
          while (1) switch (_context45.n) {
            case 0:
              return _context45.a(2, this.savingsModule.loadSavingsGoalsView());
          }
        }, _callee45, this);
      }));
      function loadSavingsGoalsView() {
        return _loadSavingsGoalsView.apply(this, arguments);
      }
      return loadSavingsGoalsView;
    }()
  }, {
    key: "updateGoalsSummary",
    value: function updateGoalsSummary() {
      return this.savingsModule.updateGoalsSummary();
    }
  }, {
    key: "renderGoals",
    value: function renderGoals(goals) {
      return this.savingsModule.renderGoals(goals);
    }
  }, {
    key: "setupGoalsEventListeners",
    value: function setupGoalsEventListeners() {
      return this.savingsModule.setupGoalsEventListeners();
    }
  }, {
    key: "populateGoalAccountDropdown",
    value: function populateGoalAccountDropdown() {
      return this.savingsModule.populateGoalAccountDropdown();
    }
  }, {
    key: "showGoalModal",
    value: function showGoalModal() {
      var goal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return this.savingsModule.showGoalModal(goal);
    }
  }, {
    key: "saveGoal",
    value: function () {
      var _saveGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee46() {
        return _regenerator().w(function (_context46) {
          while (1) switch (_context46.n) {
            case 0:
              return _context46.a(2, this.savingsModule.saveGoal());
          }
        }, _callee46, this);
      }));
      function saveGoal() {
        return _saveGoal.apply(this, arguments);
      }
      return saveGoal;
    }()
  }, {
    key: "editGoal",
    value: function editGoal(goalId) {
      return this.savingsModule.editGoal(goalId);
    }
  }, {
    key: "deleteGoal",
    value: function () {
      var _deleteGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee47(goalId) {
        return _regenerator().w(function (_context47) {
          while (1) switch (_context47.n) {
            case 0:
              return _context47.a(2, this.savingsModule.deleteGoal(goalId));
          }
        }, _callee47, this);
      }));
      function deleteGoal(_x24) {
        return _deleteGoal.apply(this, arguments);
      }
      return deleteGoal;
    }()
  }, {
    key: "showAddMoneyModal",
    value: function showAddMoneyModal(goalId) {
      return this.savingsModule.showAddMoneyModal(goalId);
    }
  }, {
    key: "addMoneyToGoal",
    value: function () {
      var _addMoneyToGoal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee48() {
        return _regenerator().w(function (_context48) {
          while (1) switch (_context48.n) {
            case 0:
              return _context48.a(2, this.savingsModule.addMoneyToGoal());
          }
        }, _callee48, this);
      }));
      function addMoneyToGoal() {
        return _addMoneyToGoal.apply(this, arguments);
      }
      return addMoneyToGoal;
    }() // ============================================
    // DEBT PAYOFF METHODS
    // ============================================
  }, {
    key: "loadDebtPayoffView",
    value: function () {
      var _loadDebtPayoffView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee49() {
        var summaryResponse, summary, debtsResponse, debts, currency, totalEl, rateEl, minEl, countEl, _t11, _t12, _t13;
        return _regenerator().w(function (_context49) {
          while (1) switch (_context49.p = _context49.n) {
            case 0:
              _context49.p = 0;
              _context49.n = 1;
              return fetch(OC.generateUrl('/apps/budget/api/debts/summary'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              summaryResponse = _context49.v;
              if (!summaryResponse.ok) {
                _context49.n = 3;
                break;
              }
              _context49.n = 2;
              return summaryResponse.json();
            case 2:
              _t11 = _context49.v;
              _context49.n = 4;
              break;
            case 3:
              _t11 = null;
            case 4:
              summary = _t11;
              _context49.n = 5;
              return fetch(OC.generateUrl('/apps/budget/api/debts'), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 5:
              debtsResponse = _context49.v;
              if (!debtsResponse.ok) {
                _context49.n = 7;
                break;
              }
              _context49.n = 6;
              return debtsResponse.json();
            case 6:
              _t12 = _context49.v;
              _context49.n = 8;
              break;
            case 7:
              _t12 = [];
            case 8:
              debts = _t12;
              // Update summary cards
              currency = this.getPrimaryCurrency();
              if (summary) {
                totalEl = document.getElementById('debt-view-total');
                rateEl = document.getElementById('debt-view-highest-rate');
                minEl = document.getElementById('debt-view-minimum');
                countEl = document.getElementById('debt-view-count');
                if (totalEl) totalEl.textContent = this.formatCurrency(summary.totalBalance, currency);
                if (rateEl) rateEl.textContent = summary.highestInterestRate > 0 ? "".concat(summary.highestInterestRate.toFixed(1), "%") : 'N/A';
                if (minEl) minEl.textContent = this.formatCurrency(summary.totalMinimumPayment, currency);
                if (countEl) countEl.textContent = summary.debtCount.toString();
              }

              // Update debt list
              this.renderDebtList(debts);

              // Setup event listeners
              this.setupDebtPayoffControls();
              _context49.n = 10;
              break;
            case 9:
              _context49.p = 9;
              _t13 = _context49.v;
              console.error('Failed to load debt payoff view:', _t13);
            case 10:
              return _context49.a(2);
          }
        }, _callee49, this, [[0, 9]]);
      }));
      function loadDebtPayoffView() {
        return _loadDebtPayoffView.apply(this, arguments);
      }
      return loadDebtPayoffView;
    }()
  }, {
    key: "renderDebtList",
    value: function renderDebtList(debts) {
      var _this14 = this;
      var container = document.getElementById('debt-list');
      if (!container) return;
      if (!Array.isArray(debts) || debts.length === 0) {
        container.innerHTML = '<div class="empty-state">No debt accounts found. Debts are pulled from liability accounts (credit cards, loans, mortgages).</div>';
        return;
      }
      var currency = this.getPrimaryCurrency();
      container.innerHTML = debts.map(function (debt) {
        var balance = Math.abs(parseFloat(debt.balance) || 0);
        var rate = parseFloat(debt.interestRate) || 0;
        var minPayment = parseFloat(debt.minimumPayment) || 0;
        return "\n                <div class=\"debt-item\" data-id=\"".concat(debt.id, "\">\n                    <div class=\"debt-item-header\">\n                        <div class=\"debt-item-name\">").concat(_this14.escapeHtml(debt.name), "</div>\n                        <div class=\"debt-item-type\">").concat(_this14.formatAccountType(debt.type), "</div>\n                    </div>\n                    <div class=\"debt-item-details\">\n                        <div class=\"debt-detail\">\n                            <span class=\"detail-label\">Balance</span>\n                            <span class=\"detail-value debt-balance\">").concat(_this14.formatCurrency(balance, currency), "</span>\n                        </div>\n                        <div class=\"debt-detail\">\n                            <span class=\"detail-label\">Interest Rate</span>\n                            <span class=\"detail-value\">").concat(rate > 0 ? rate.toFixed(1) + '%' : 'N/A', "</span>\n                        </div>\n                        <div class=\"debt-detail\">\n                            <span class=\"detail-label\">Min Payment</span>\n                            <span class=\"detail-value\">").concat(minPayment > 0 ? _this14.formatCurrency(minPayment, currency) : 'Not set', "</span>\n                        </div>\n                    </div>\n                </div>\n            ");
      }).join('');
    }
  }, {
    key: "setupDebtPayoffControls",
    value: function setupDebtPayoffControls() {
      var _this15 = this;
      var calculateBtn = document.getElementById('calculate-payoff-btn');
      var compareBtn = document.getElementById('compare-strategies-btn');
      if (calculateBtn) {
        calculateBtn.onclick = function () {
          return _this15.calculatePayoffPlan();
        };
      }
      if (compareBtn) {
        compareBtn.onclick = function () {
          return _this15.compareStrategies();
        };
      }
    }
  }, {
    key: "calculatePayoffPlan",
    value: function () {
      var _calculatePayoffPlan = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee50() {
        var _document$getElementB4, _document$getElementB5;
        var strategy, extraPayment, response, plan, comparisonEl, _t14;
        return _regenerator().w(function (_context50) {
          while (1) switch (_context50.p = _context50.n) {
            case 0:
              strategy = ((_document$getElementB4 = document.getElementById('debt-strategy-select')) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.value) || 'avalanche';
              extraPayment = parseFloat((_document$getElementB5 = document.getElementById('debt-extra-payment')) === null || _document$getElementB5 === void 0 ? void 0 : _document$getElementB5.value) || 0;
              _context50.p = 1;
              _context50.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/debts/payoff-plan?strategy=".concat(strategy, "&extraPayment=").concat(extraPayment)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context50.v;
              if (response.ok) {
                _context50.n = 3;
                break;
              }
              throw new Error('Failed to calculate payoff plan');
            case 3:
              _context50.n = 4;
              return response.json();
            case 4:
              plan = _context50.v;
              this.displayPayoffPlan(plan);

              // Hide comparison results when showing plan
              comparisonEl = document.getElementById('debt-comparison-results');
              if (comparisonEl) comparisonEl.style.display = 'none';
              _context50.n = 6;
              break;
            case 5:
              _context50.p = 5;
              _t14 = _context50.v;
              console.error('Failed to calculate payoff plan:', _t14);
              OC.Notification.showTemporary('Failed to calculate payoff plan');
            case 6:
              return _context50.a(2);
          }
        }, _callee50, this, [[1, 5]]);
      }));
      function calculatePayoffPlan() {
        return _calculatePayoffPlan.apply(this, arguments);
      }
      return calculatePayoffPlan;
    }()
  }, {
    key: "displayPayoffPlan",
    value: function displayPayoffPlan(plan) {
      var _this16 = this;
      var resultsEl = document.getElementById('debt-payoff-results');
      if (!resultsEl) return;
      resultsEl.style.display = '';
      var currency = this.getPrimaryCurrency();

      // Update summary cards
      var monthsEl = document.getElementById('payoff-months');
      var dateEl = document.getElementById('payoff-date');
      var interestEl = document.getElementById('payoff-total-interest');
      var totalEl = document.getElementById('payoff-total-paid');
      if (monthsEl) {
        var years = Math.floor(plan.totalMonths / 12);
        var months = plan.totalMonths % 12;
        if (years > 0) {
          monthsEl.textContent = "".concat(years, "y ").concat(months, "m");
        } else {
          monthsEl.textContent = "".concat(months, " months");
        }
      }
      if (dateEl && plan.payoffDate) {
        var date = new Date(plan.payoffDate);
        dateEl.textContent = date.toLocaleDateString('en-US', {
          month: 'long',
          year: 'numeric'
        });
      }
      if (interestEl) interestEl.textContent = this.formatCurrency(plan.totalInterest, currency);
      if (totalEl) totalEl.textContent = this.formatCurrency(plan.totalPaid, currency);

      // Update payoff order
      var orderEl = document.getElementById('debt-payoff-order');
      if (orderEl && plan.debts) {
        orderEl.innerHTML = plan.debts.map(function (debt, index) {
          return "\n                <div class=\"payoff-order-item\">\n                    <span class=\"payoff-order-number\">".concat(index + 1, "</span>\n                    <div class=\"payoff-order-details\">\n                        <div class=\"payoff-order-name\">").concat(_this16.escapeHtml(debt.name), "</div>\n                        <div class=\"payoff-order-meta\">\n                            <span>").concat(_this16.formatCurrency(debt.originalBalance, currency), "</span>\n                            <span class=\"meta-separator\">\u2022</span>\n                            <span>").concat(debt.interestRate, "% APR</span>\n                            <span class=\"meta-separator\">\u2022</span>\n                            <span>Paid off month ").concat(debt.payoffMonth, "</span>\n                        </div>\n                    </div>\n                    <div class=\"payoff-order-interest\">\n                        <span class=\"interest-label\">Interest</span>\n                        <span class=\"interest-value\">").concat(_this16.formatCurrency(debt.interestPaid, currency), "</span>\n                    </div>\n                </div>\n            ");
        }).join('');
      }
    }
  }, {
    key: "compareStrategies",
    value: function () {
      var _compareStrategies = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee51() {
        var _document$getElementB6;
        var extraPayment, response, comparison, planEl, _t15;
        return _regenerator().w(function (_context51) {
          while (1) switch (_context51.p = _context51.n) {
            case 0:
              extraPayment = parseFloat((_document$getElementB6 = document.getElementById('debt-extra-payment')) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.value) || 0;
              _context51.p = 1;
              _context51.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/debts/compare?extraPayment=".concat(extraPayment)), {
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context51.v;
              if (response.ok) {
                _context51.n = 3;
                break;
              }
              throw new Error('Failed to compare strategies');
            case 3:
              _context51.n = 4;
              return response.json();
            case 4:
              comparison = _context51.v;
              this.displayComparison(comparison);

              // Hide plan results when showing comparison
              planEl = document.getElementById('debt-payoff-results');
              if (planEl) planEl.style.display = 'none';
              _context51.n = 6;
              break;
            case 5:
              _context51.p = 5;
              _t15 = _context51.v;
              console.error('Failed to compare strategies:', _t15);
              OC.Notification.showTemporary('Failed to compare strategies');
            case 6:
              return _context51.a(2);
          }
        }, _callee51, this, [[1, 5]]);
      }));
      function compareStrategies() {
        return _compareStrategies.apply(this, arguments);
      }
      return compareStrategies;
    }()
  }, {
    key: "displayComparison",
    value: function displayComparison(comparison) {
      var _comparison$compariso, _comparison$compariso2;
      var resultsEl = document.getElementById('debt-comparison-results');
      if (!resultsEl) return;
      resultsEl.style.display = '';
      var currency = this.getPrimaryCurrency();

      // Update avalanche stats
      var avalancheMonths = document.getElementById('avalanche-months');
      var avalancheInterest = document.getElementById('avalanche-interest');
      if (avalancheMonths) avalancheMonths.textContent = "".concat(comparison.avalanche.totalMonths, " months");
      if (avalancheInterest) avalancheInterest.textContent = this.formatCurrency(comparison.avalanche.totalInterest, currency);

      // Update snowball stats
      var snowballMonths = document.getElementById('snowball-months');
      var snowballInterest = document.getElementById('snowball-interest');
      if (snowballMonths) snowballMonths.textContent = "".concat(comparison.snowball.totalMonths, " months");
      if (snowballInterest) snowballInterest.textContent = this.formatCurrency(comparison.snowball.totalInterest, currency);

      // Update recommendation
      var recommendationEl = document.getElementById('comparison-recommendation');
      if (recommendationEl && comparison.comparison) {
        var c = comparison.comparison;
        var recClass = c.recommendation === 'avalanche' ? 'recommend-avalanche' : c.recommendation === 'snowball' ? 'recommend-snowball' : 'recommend-either';
        recommendationEl.innerHTML = "\n                <div class=\"recommendation-box ".concat(recClass, "\">\n                    <div class=\"recommendation-title\">\n                        ").concat(c.recommendation === 'avalanche' ? 'Avalanche Recommended' : c.recommendation === 'snowball' ? 'Snowball Recommended' : 'Either Works', "\n                    </div>\n                    <div class=\"recommendation-text\">").concat(this.escapeHtml(c.explanation), "</div>\n                    ").concat(c.interestSavedByAvalanche > 0 ? "<div class=\"recommendation-savings\">Avalanche saves ".concat(this.formatCurrency(c.interestSavedByAvalanche, currency), " in interest</div>") : '', "\n                </div>\n            ");
      }

      // Highlight recommended card
      var avalancheCard = document.getElementById('avalanche-comparison');
      var snowballCard = document.getElementById('snowball-comparison');
      if (avalancheCard) avalancheCard.classList.toggle('recommended', ((_comparison$compariso = comparison.comparison) === null || _comparison$compariso === void 0 ? void 0 : _comparison$compariso.recommendation) === 'avalanche');
      if (snowballCard) snowballCard.classList.toggle('recommended', ((_comparison$compariso2 = comparison.comparison) === null || _comparison$compariso2 === void 0 ? void 0 : _comparison$compariso2.recommendation) === 'snowball');
    }
  }, {
    key: "formatAccountType",
    value: function formatAccountType(type) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__.formatAccountType(type);
    }
  }, {
    key: "linkTransactions",
    value: (function () {
      var _linkTransactions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee52(transactionId, targetId) {
        var response, error, _t16;
        return _regenerator().w(function (_context52) {
          while (1) switch (_context52.p = _context52.n) {
            case 0:
              _context52.p = 0;
              _context52.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/link/").concat(targetId)), {
                method: 'POST',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context52.v;
              if (response.ok) {
                _context52.n = 3;
                break;
              }
              _context52.n = 2;
              return response.json();
            case 2:
              error = _context52.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context52.n = 4;
              return response.json();
            case 4:
              return _context52.a(2, _context52.v);
            case 5:
              _context52.p = 5;
              _t16 = _context52.v;
              console.error('Failed to link transactions:', _t16);
              throw _t16;
            case 6:
              return _context52.a(2);
          }
        }, _callee52, null, [[0, 5]]);
      }));
      function linkTransactions(_x25, _x26) {
        return _linkTransactions.apply(this, arguments);
      }
      return linkTransactions;
    }()
    /**
     * Unlink a transaction from its transfer partner
     */
    )
  }, {
    key: "unlinkTransaction",
    value: (function () {
      var _unlinkTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee53(transactionId) {
        var response, error, _t17;
        return _regenerator().w(function (_context53) {
          while (1) switch (_context53.p = _context53.n) {
            case 0:
              _context53.p = 0;
              _context53.n = 1;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/link")), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 1:
              response = _context53.v;
              if (response.ok) {
                _context53.n = 3;
                break;
              }
              _context53.n = 2;
              return response.json();
            case 2:
              error = _context53.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 3:
              _context53.n = 4;
              return response.json();
            case 4:
              return _context53.a(2, _context53.v);
            case 5:
              _context53.p = 5;
              _t17 = _context53.v;
              console.error('Failed to unlink transaction:', _t17);
              throw _t17;
            case 6:
              return _context53.a(2);
          }
        }, _callee53, null, [[0, 5]]);
      }));
      function unlinkTransaction(_x27) {
        return _unlinkTransaction.apply(this, arguments);
      }
      return unlinkTransaction;
    }()
    /**
     * Show the matching modal for a transaction
     */
    )
  }, {
    key: "showMatchingModal",
    value: (function () {
      var _showMatchingModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee54(transactionId) {
        var _this$transactions3,
          _this$accounts,
          _this17 = this;
        var transaction, modal, sourceDetails, loadingEl, emptyEl, listEl, account, currency, typeClass, result, _t18;
        return _regenerator().w(function (_context54) {
          while (1) switch (_context54.p = _context54.n) {
            case 0:
              transaction = (_this$transactions3 = this.transactions) === null || _this$transactions3 === void 0 ? void 0 : _this$transactions3.find(function (t) {
                return t.id === transactionId;
              });
              if (transaction) {
                _context54.n = 1;
                break;
              }
              OC.Notification.showTemporary('Transaction not found');
              return _context54.a(2);
            case 1:
              modal = document.getElementById('matching-modal');
              sourceDetails = modal.querySelector('.source-details');
              loadingEl = document.getElementById('matching-loading');
              emptyEl = document.getElementById('matching-empty');
              listEl = document.getElementById('matching-list'); // Populate source transaction info
              account = (_this$accounts = this.accounts) === null || _this$accounts === void 0 ? void 0 : _this$accounts.find(function (a) {
                return a.id === transaction.accountId;
              });
              currency = transaction.accountCurrency || (account === null || account === void 0 ? void 0 : account.currency) || this.getPrimaryCurrency();
              typeClass = transaction.type === 'credit' ? 'positive' : 'negative';
              sourceDetails.querySelector('.source-date').textContent = this.formatDate(transaction.date);
              sourceDetails.querySelector('.source-description').textContent = transaction.description;
              sourceDetails.querySelector('.source-amount').textContent = this.formatCurrency(transaction.amount, currency);
              sourceDetails.querySelector('.source-amount').className = "source-amount ".concat(typeClass);
              sourceDetails.querySelector('.source-account').textContent = (account === null || account === void 0 ? void 0 : account.name) || 'Unknown Account';

              // Show modal and loading state
              modal.style.display = 'flex';
              loadingEl.style.display = 'flex';
              emptyEl.style.display = 'none';
              listEl.innerHTML = '';
              _context54.p = 2;
              _context54.n = 3;
              return this.findTransactionMatches(transactionId);
            case 3:
              result = _context54.v;
              loadingEl.style.display = 'none';
              if (!(!result.matches || result.matches.length === 0)) {
                _context54.n = 4;
                break;
              }
              emptyEl.style.display = 'flex';
              return _context54.a(2);
            case 4:
              // Render matches
              listEl.innerHTML = result.matches.map(function (match) {
                var _this17$accounts;
                var matchAccount = (_this17$accounts = _this17.accounts) === null || _this17$accounts === void 0 ? void 0 : _this17$accounts.find(function (a) {
                  return a.id === match.accountId;
                });
                var matchCurrency = match.accountCurrency || (matchAccount === null || matchAccount === void 0 ? void 0 : matchAccount.currency) || _this17.getPrimaryCurrency();
                var matchTypeClass = match.type === 'credit' ? 'positive' : 'negative';
                return "\n                    <div class=\"match-item\" data-match-id=\"".concat(match.id, "\">\n                        <span class=\"match-date\">").concat(_this17.formatDate(match.date), "</span>\n                        <span class=\"match-description\">").concat(_this17.escapeHtml(match.description), "</span>\n                        <span class=\"match-amount ").concat(matchTypeClass, "\">").concat(_this17.formatCurrency(match.amount, matchCurrency), "</span>\n                        <span class=\"match-account\">").concat((matchAccount === null || matchAccount === void 0 ? void 0 : matchAccount.name) || 'Unknown', "</span>\n                        <button class=\"link-match-btn\" data-source-id=\"").concat(transactionId, "\" data-target-id=\"").concat(match.id, "\">\n                            Link as Transfer\n                        </button>\n                    </div>\n                ");
              }).join('');
              _context54.n = 6;
              break;
            case 5:
              _context54.p = 5;
              _t18 = _context54.v;
              loadingEl.style.display = 'none';
              emptyEl.style.display = 'flex';
              emptyEl.querySelector('p').textContent = 'Failed to search for matches. Please try again.';
            case 6:
              return _context54.a(2);
          }
        }, _callee54, this, [[2, 5]]);
      }));
      function showMatchingModal(_x28) {
        return _showMatchingModal.apply(this, arguments);
      }
      return showMatchingModal;
    }()
    /**
     * Handle linking a match from the modal
     */
    )
  }, {
    key: "handleLinkMatch",
    value: (function () {
      var _handleLinkMatch = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee55(sourceId, targetId) {
        var _t19;
        return _regenerator().w(function (_context55) {
          while (1) switch (_context55.p = _context55.n) {
            case 0:
              _context55.p = 0;
              _context55.n = 1;
              return this.linkTransactions(sourceId, targetId);
            case 1:
              OC.Notification.showTemporary('Transactions linked as transfer');

              // Close modal and refresh transactions
              document.getElementById('matching-modal').style.display = 'none';
              _context55.n = 2;
              return this.loadTransactions();
            case 2:
              _context55.n = 4;
              break;
            case 3:
              _context55.p = 3;
              _t19 = _context55.v;
              OC.Notification.showTemporary(_t19.message || 'Failed to link transactions');
            case 4:
              return _context55.a(2);
          }
        }, _callee55, this, [[0, 3]]);
      }));
      function handleLinkMatch(_x29, _x30) {
        return _handleLinkMatch.apply(this, arguments);
      }
      return handleLinkMatch;
    }()
    /**
     * Handle unlinking a transaction
     */
    )
  }, {
    key: "handleUnlinkTransaction",
    value: (function () {
      var _handleUnlinkTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee56(transactionId) {
        var _t20;
        return _regenerator().w(function (_context56) {
          while (1) switch (_context56.p = _context56.n) {
            case 0:
              if (confirm('Are you sure you want to unlink this transaction from its transfer pair?')) {
                _context56.n = 1;
                break;
              }
              return _context56.a(2);
            case 1:
              _context56.p = 1;
              _context56.n = 2;
              return this.unlinkTransaction(transactionId);
            case 2:
              OC.Notification.showTemporary('Transaction unlinked');
              _context56.n = 3;
              return this.loadTransactions();
            case 3:
              _context56.n = 5;
              break;
            case 4:
              _context56.p = 4;
              _t20 = _context56.v;
              OC.Notification.showTemporary(_t20.message || 'Failed to unlink transaction');
            case 5:
              return _context56.a(2);
          }
        }, _callee56, this, [[1, 4]]);
      }));
      function handleUnlinkTransaction(_x31) {
        return _handleUnlinkTransaction.apply(this, arguments);
      }
      return handleUnlinkTransaction;
    }() // ===== Transaction Split Methods =====
    /**
     * Show the split modal for a transaction
     */
    )
  }, {
    key: "showSplitModal",
    value: function () {
      var _showSplitModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee57(transactionId) {
        var _this$transactions4,
          _this$accounts2,
          _this18 = this;
        var transaction, modal, isSplit, titleEl, transactionInfoEl, splitsContainer, account, currency, splits, _t21;
        return _regenerator().w(function (_context57) {
          while (1) switch (_context57.p = _context57.n) {
            case 0:
              transaction = (_this$transactions4 = this.transactions) === null || _this$transactions4 === void 0 ? void 0 : _this$transactions4.find(function (t) {
                return t.id === transactionId;
              });
              if (transaction) {
                _context57.n = 1;
                break;
              }
              OC.Notification.showTemporary('Transaction not found');
              return _context57.a(2);
            case 1:
              modal = document.getElementById('split-modal');
              if (modal) {
                _context57.n = 2;
                break;
              }
              console.error('Split modal not found');
              return _context57.a(2);
            case 2:
              isSplit = transaction.isSplit || transaction.is_split;
              titleEl = document.getElementById('split-modal-title');
              transactionInfoEl = document.getElementById('split-transaction-info');
              splitsContainer = document.getElementById('splits-container'); // Set title and store transaction id
              titleEl.textContent = isSplit ? 'Edit Transaction Splits' : 'Split Transaction';
              modal.dataset.transactionId = transactionId;

              // Display transaction info
              account = (_this$accounts2 = this.accounts) === null || _this$accounts2 === void 0 ? void 0 : _this$accounts2.find(function (a) {
                return a.id === transaction.accountId;
              });
              currency = transaction.accountCurrency || (account === null || account === void 0 ? void 0 : account.currency) || this.getPrimaryCurrency();
              transactionInfoEl.innerHTML = "\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Date:</span>\n                <span>".concat(this.formatDate(transaction.date), "</span>\n            </div>\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Description:</span>\n                <span>").concat(this.escapeHtml(transaction.description), "</span>\n            </div>\n            <div class=\"split-info-row\">\n                <span class=\"split-info-label\">Total Amount:</span>\n                <span class=\"split-total-amount\">").concat(this.formatCurrency(transaction.amount, currency), "</span>\n            </div>\n        ");

              // Store transaction data for later
              modal.dataset.totalAmount = transaction.amount;
              modal.dataset.currency = currency;

              // Clear and set up splits container
              splitsContainer.innerHTML = '';
              if (!isSplit) {
                _context57.n = 7;
                break;
              }
              _context57.p = 3;
              _context57.n = 4;
              return this.getTransactionSplits(transactionId);
            case 4:
              splits = _context57.v;
              splits.forEach(function (split, index) {
                _this18.addSplitRow(splitsContainer, split, index === 0);
              });
              _context57.n = 6;
              break;
            case 5:
              _context57.p = 5;
              _t21 = _context57.v;
              console.error('Failed to load splits:', _t21);
              // Add two empty rows as fallback
              this.addSplitRow(splitsContainer, null, true);
              this.addSplitRow(splitsContainer, null, false);
            case 6:
              _context57.n = 8;
              break;
            case 7:
              // Start with two empty split rows
              this.addSplitRow(splitsContainer, null, true);
              this.addSplitRow(splitsContainer, null, false);
            case 8:
              this.updateSplitRemaining();
              modal.style.display = 'flex';
            case 9:
              return _context57.a(2);
          }
        }, _callee57, this, [[3, 5]]);
      }));
      function showSplitModal(_x32) {
        return _showSplitModal.apply(this, arguments);
      }
      return showSplitModal;
    }()
  }, {
    key: "getCategoryOptions",
    value: function getCategoryOptions() {
      var _this19 = this;
      var selectedId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var transactionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!this.categories) return '';

      // Determine category type based on transaction type
      // credit = income categories, debit = expense categories
      var categoryType = transactionType === 'credit' ? 'income' : 'expense';
      return this.categories.filter(function (c) {
        return c.type === categoryType;
      }).map(function (c) {
        return "<option value=\"".concat(c.id, "\" ").concat(c.id === selectedId ? 'selected' : '', ">").concat(_this19.escapeHtml(c.name), "</option>");
      }).join('');
    }

    /**
     * Update the remaining amount display in split modal
     */
  }, {
    key: "updateSplitRemaining",
    value: function updateSplitRemaining() {
      var modal = document.getElementById('split-modal');
      var totalAmount = parseFloat((modal === null || modal === void 0 ? void 0 : modal.dataset.totalAmount) || 0);
      var currency = (modal === null || modal === void 0 ? void 0 : modal.dataset.currency) || this.getPrimaryCurrency();
      var remainingEl = document.getElementById('split-remaining');
      var remainingAmountEl = document.getElementById('split-remaining-amount');
      var allocatedAmount = Array.from(document.querySelectorAll('.split-amount')).reduce(function (sum, input) {
        return sum + (parseFloat(input.value) || 0);
      }, 0);
      var remaining = totalAmount - allocatedAmount;
      if (remainingEl && remainingAmountEl) {
        remainingAmountEl.textContent = this.formatCurrency(Math.abs(remaining), currency);
        remainingEl.classList.toggle('over', remaining < -0.01);
        remainingEl.classList.toggle('balanced', Math.abs(remaining) < 0.01);
      }
    }
  }, {
    key: "saveSplits",
    value: (function () {
      var _saveSplits = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee58() {
        var modal, transactionId, totalAmount, splits, splitTotal, response, error, _t22;
        return _regenerator().w(function (_context58) {
          while (1) switch (_context58.p = _context58.n) {
            case 0:
              modal = document.getElementById('split-modal');
              transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
              totalAmount = parseFloat((modal === null || modal === void 0 ? void 0 : modal.dataset.totalAmount) || 0); // Collect splits data
              splits = Array.from(document.querySelectorAll('.split-row')).map(function (row) {
                return {
                  amount: parseFloat(row.querySelector('.split-amount').value) || 0,
                  categoryId: parseInt(row.querySelector('.split-category').value) || null,
                  description: row.querySelector('.split-description').value.trim() || null
                };
              }).filter(function (split) {
                return split.amount > 0;
              }); // Validate
              if (!(splits.length < 2)) {
                _context58.n = 1;
                break;
              }
              OC.Notification.showTemporary('A split transaction must have at least 2 parts');
              return _context58.a(2);
            case 1:
              splitTotal = splits.reduce(function (sum, s) {
                return sum + s.amount;
              }, 0);
              if (!(Math.abs(splitTotal - totalAmount) > 0.01)) {
                _context58.n = 2;
                break;
              }
              OC.Notification.showTemporary("Split amounts (".concat(splitTotal.toFixed(2), ") must equal transaction amount (").concat(totalAmount.toFixed(2), ")"));
              return _context58.a(2);
            case 2:
              _context58.p = 2;
              _context58.n = 3;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'requesttoken': OC.requestToken
                },
                body: JSON.stringify({
                  splits: splits
                })
              });
            case 3:
              response = _context58.v;
              if (response.ok) {
                _context58.n = 5;
                break;
              }
              _context58.n = 4;
              return response.json();
            case 4:
              error = _context58.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 5:
              this.hideSplitModal();
              OC.Notification.showTemporary('Transaction split successfully');
              _context58.n = 6;
              return this.loadTransactions();
            case 6:
              _context58.n = 8;
              break;
            case 7:
              _context58.p = 7;
              _t22 = _context58.v;
              console.error('Failed to save splits:', _t22);
              OC.Notification.showTemporary(_t22.message || 'Failed to save splits');
            case 8:
              return _context58.a(2);
          }
        }, _callee58, this, [[2, 7]]);
      }));
      function saveSplits() {
        return _saveSplits.apply(this, arguments);
      }
      return saveSplits;
    }()
    /**
     * Remove splits from a transaction (unsplit)
     */
    )
  }, {
    key: "unsplitTransaction",
    value: (function () {
      var _unsplitTransaction = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee59() {
        var modal, transactionId, response, error, _t23;
        return _regenerator().w(function (_context59) {
          while (1) switch (_context59.p = _context59.n) {
            case 0:
              modal = document.getElementById('split-modal');
              transactionId = parseInt(modal === null || modal === void 0 ? void 0 : modal.dataset.transactionId);
              if (confirm('Are you sure you want to remove the split and revert to a single transaction?')) {
                _context59.n = 1;
                break;
              }
              return _context59.a(2);
            case 1:
              _context59.p = 1;
              _context59.n = 2;
              return fetch(OC.generateUrl("/apps/budget/api/transactions/".concat(transactionId, "/splits")), {
                method: 'DELETE',
                headers: {
                  'requesttoken': OC.requestToken
                }
              });
            case 2:
              response = _context59.v;
              if (response.ok) {
                _context59.n = 4;
                break;
              }
              _context59.n = 3;
              return response.json();
            case 3:
              error = _context59.v;
              throw new Error(error.error || "HTTP ".concat(response.status));
            case 4:
              this.hideSplitModal();
              OC.Notification.showTemporary('Transaction unsplit successfully');
              _context59.n = 5;
              return this.loadTransactions();
            case 5:
              _context59.n = 7;
              break;
            case 6:
              _context59.p = 6;
              _t23 = _context59.v;
              console.error('Failed to unsplit transaction:', _t23);
              OC.Notification.showTemporary(_t23.message || 'Failed to unsplit transaction');
            case 7:
              return _context59.a(2);
          }
        }, _callee59, this, [[1, 6]]);
      }));
      function unsplitTransaction() {
        return _unsplitTransaction.apply(this, arguments);
      }
      return unsplitTransaction;
    }()
    /**
     * Hide the split modal
     */
    )
  }, {
    key: "hideSplitModal",
    value: function hideSplitModal() {
      var modal = document.getElementById('split-modal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    /**
     * Hide all modals
     */
  }, {
    key: "hideModals",
    value: function hideModals() {
      var modalIds = ['transaction-modal', 'account-modal', 'category-modal', 'split-modal', 'matching-modal', 'bulk-match-modal', 'add-tag-set-modal', 'add-tag-modal', 'edit-tag-set-modal', 'factory-reset-modal'];
      modalIds.forEach(function (modalId) {
        var modal = document.getElementById(modalId);
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
        }
      });
    }
  }, {
    key: "showBulkMatchModal",
    value: (function () {
      var _showBulkMatchModal = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee60() {
        var _this20 = this;
        var modal, loadingEl, resultsEl, emptyEl, autoMatchedSection, needsReviewSection, autoMatchedList, needsReviewList, result, _t24;
        return _regenerator().w(function (_context60) {
          while (1) switch (_context60.p = _context60.n) {
            case 0:
              modal = document.getElementById('bulk-match-modal');
              loadingEl = document.getElementById('bulk-match-loading');
              resultsEl = document.getElementById('bulk-match-results');
              emptyEl = document.getElementById('bulk-match-empty');
              autoMatchedSection = document.getElementById('auto-matched-section');
              needsReviewSection = document.getElementById('needs-review-section');
              autoMatchedList = document.getElementById('auto-matched-list');
              needsReviewList = document.getElementById('needs-review-list'); // Reset state
              loadingEl.style.display = 'flex';
              resultsEl.style.display = 'none';
              emptyEl.style.display = 'none';
              autoMatchedSection.style.display = 'none';
              needsReviewSection.style.display = 'none';
              autoMatchedList.innerHTML = '';
              needsReviewList.innerHTML = '';

              // Show modal
              modal.style.display = 'flex';
              _context60.p = 1;
              _context60.n = 2;
              return this.bulkMatchTransactions();
            case 2:
              result = _context60.v;
              loadingEl.style.display = 'none';
              resultsEl.style.display = 'block';

              // Update summary counts
              document.getElementById('auto-matched-count').textContent = result.stats.autoMatchedCount;
              document.getElementById('needs-review-count').textContent = result.stats.needsReviewCount;

              // Check if no results
              if (!(result.stats.autoMatchedCount === 0 && result.stats.needsReviewCount === 0)) {
                _context60.n = 3;
                break;
              }
              emptyEl.style.display = 'flex';
              return _context60.a(2);
            case 3:
              // Render auto-matched pairs
              if (result.autoMatched && result.autoMatched.length > 0) {
                autoMatchedSection.style.display = 'block';
                autoMatchedList.innerHTML = result.autoMatched.map(function (pair) {
                  return _this20.renderAutoMatchedPair(pair);
                }).join('');
              }

              // Render needs review items
              if (result.needsReview && result.needsReview.length > 0) {
                needsReviewSection.style.display = 'block';
                needsReviewList.innerHTML = result.needsReview.map(function (item, index) {
                  return _this20.renderNeedsReviewItem(item, index);
                }).join('');
              }
              _context60.n = 5;
              break;
            case 4:
              _context60.p = 4;
              _t24 = _context60.v;
              loadingEl.style.display = 'none';
              resultsEl.style.display = 'block';
              emptyEl.style.display = 'flex';
              emptyEl.querySelector('p').textContent = _t24.message || 'Failed to match transactions. Please try again.';
            case 5:
              return _context60.a(2);
          }
        }, _callee60, this, [[1, 4]]);
      }));
      function showBulkMatchModal() {
        return _showBulkMatchModal.apply(this, arguments);
      }
      return showBulkMatchModal;
    }()
    /**
     * Render an auto-matched pair in the bulk match modal
     */
    )
  }, {
    key: "renderAutoMatchedPair",
    value: function renderAutoMatchedPair(pair) {
      var tx = pair.transaction;
      var linked = pair.linkedTo;
      var txCurrency = tx.account_currency || this.getPrimaryCurrency();
      var linkedCurrency = linked.accountCurrency || this.getPrimaryCurrency();
      var txTypeClass = tx.type === 'credit' ? 'positive' : 'negative';
      var linkedTypeClass = linked.type === 'credit' ? 'positive' : 'negative';
      return "\n            <div class=\"bulk-match-pair\" data-tx-id=\"".concat(tx.id, "\" data-linked-id=\"").concat(linked.id, "\">\n                <div class=\"pair-transaction\">\n                    <span class=\"pair-date\">").concat(this.formatDate(tx.date), "</span>\n                    <span class=\"pair-description\">").concat(this.escapeHtml(tx.description), "</span>\n                    <div class=\"pair-details\">\n                        <span class=\"pair-amount ").concat(txTypeClass, "\">").concat(this.formatCurrency(tx.amount, txCurrency), "</span>\n                        <span class=\"pair-account\">").concat(this.escapeHtml(tx.account_name), "</span>\n                    </div>\n                </div>\n                <span class=\"pair-arrow\">\u2194</span>\n                <div class=\"pair-transaction\">\n                    <span class=\"pair-date\">").concat(this.formatDate(linked.date), "</span>\n                    <span class=\"pair-description\">").concat(this.escapeHtml(linked.description), "</span>\n                    <div class=\"pair-details\">\n                        <span class=\"pair-amount ").concat(linkedTypeClass, "\">").concat(this.formatCurrency(linked.amount, linkedCurrency), "</span>\n                        <span class=\"pair-account\">").concat(this.escapeHtml(linked.accountName), "</span>\n                    </div>\n                </div>\n                <button class=\"undo-match-btn\" data-tx-id=\"").concat(tx.id, "\">Undo</button>\n            </div>\n        ");
    }

    /**
     * Render a needs-review item in the bulk match modal
     */
  }, {
    key: "renderNeedsReviewItem",
    value: function renderNeedsReviewItem(item, index) {
      var _this21 = this;
      var tx = item.transaction;
      var txCurrency = tx.account_currency || this.getPrimaryCurrency();
      var txTypeClass = tx.type === 'credit' ? 'positive' : 'negative';
      var matchesHtml = item.matches.map(function (match) {
        var matchCurrency = match.accountCurrency || _this21.getPrimaryCurrency();
        var matchTypeClass = match.type === 'credit' ? 'positive' : 'negative';
        return "\n                <label class=\"review-match-option\">\n                    <input type=\"radio\" name=\"review-match-".concat(index, "\" value=\"").concat(match.id, "\">\n                    <div class=\"match-info\">\n                        <div class=\"match-info-main\">\n                            <span class=\"match-date\">").concat(_this21.formatDate(match.date), "</span>\n                            <span class=\"match-description\">").concat(_this21.escapeHtml(match.description), "</span>\n                        </div>\n                        <span class=\"pair-amount ").concat(matchTypeClass, "\">").concat(_this21.formatCurrency(match.amount, matchCurrency), "</span>\n                        <span class=\"pair-account\">").concat(_this21.escapeHtml(match.accountName), "</span>\n                    </div>\n                </label>\n            ");
      }).join('');
      return "\n            <div class=\"bulk-review-item\" data-tx-id=\"".concat(tx.id, "\" data-index=\"").concat(index, "\">\n                <div class=\"review-source\">\n                    <div class=\"review-source-info\">\n                        <span class=\"review-source-date\">").concat(this.formatDate(tx.date), "</span>\n                        <span class=\"review-source-description\">").concat(this.escapeHtml(tx.description), "</span>\n                        <div class=\"review-source-details\">\n                            <span class=\"pair-amount ").concat(txTypeClass, "\">").concat(this.formatCurrency(tx.amount, txCurrency), "</span>\n                            <span class=\"pair-account\">").concat(this.escapeHtml(tx.account_name), "</span>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"review-matches-label\">Select a match (").concat(item.matchCount, " options):</div>\n                <div class=\"review-matches\">\n                    ").concat(matchesHtml, "\n                </div>\n                <button class=\"link-selected-btn\" data-tx-id=\"").concat(tx.id, "\" data-index=\"").concat(index, "\" disabled>Link Selected</button>\n            </div>\n        ");
    }
  }, {
    key: "loadPensionsView",
    value: (function () {
      var _loadPensionsView = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee61() {
        return _regenerator().w(function (_context61) {
          while (1) switch (_context61.n) {
            case 0:
              return _context61.a(2, this.pensionsModule.loadPensionsView());
          }
        }, _callee61, this);
      }));
      function loadPensionsView() {
        return _loadPensionsView.apply(this, arguments);
      }
      return loadPensionsView;
    }())
  }, {
    key: "loadPensions",
    value: function () {
      var _loadPensions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee62() {
        return _regenerator().w(function (_context62) {
          while (1) switch (_context62.n) {
            case 0:
              return _context62.a(2, this.pensionsModule.loadPensions());
          }
        }, _callee62, this);
      }));
      function loadPensions() {
        return _loadPensions.apply(this, arguments);
      }
      return loadPensions;
    }()
  }, {
    key: "loadPensionSummary",
    value: function () {
      var _loadPensionSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee63() {
        return _regenerator().w(function (_context63) {
          while (1) switch (_context63.n) {
            case 0:
              return _context63.a(2, this.pensionsModule.loadPensionSummary());
          }
        }, _callee63, this);
      }));
      function loadPensionSummary() {
        return _loadPensionSummary.apply(this, arguments);
      }
      return loadPensionSummary;
    }()
  }, {
    key: "loadPensionProjection",
    value: function () {
      var _loadPensionProjection = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee64() {
        return _regenerator().w(function (_context64) {
          while (1) switch (_context64.n) {
            case 0:
              return _context64.a(2, this.pensionsModule.loadPensionProjection());
          }
        }, _callee64, this);
      }));
      function loadPensionProjection() {
        return _loadPensionProjection.apply(this, arguments);
      }
      return loadPensionProjection;
    }()
  }, {
    key: "renderPensions",
    value: function renderPensions() {
      return this.pensionsModule.renderPensions();
    }
  }, {
    key: "renderPensionCard",
    value: function renderPensionCard(pension) {
      return this.pensionsModule.renderPensionCard(pension);
    }
  }, {
    key: "updatePensionsSummary",
    value: function updatePensionsSummary(summary) {
      return this.pensionsModule.updatePensionsSummary(summary);
    }
  }, {
    key: "updatePensionsProjection",
    value: function updatePensionsProjection(projection) {
      return this.pensionsModule.updatePensionsProjection(projection);
    }
  }, {
    key: "setupPensionEventListeners",
    value: function setupPensionEventListeners() {
      return this.pensionsModule.setupPensionEventListeners();
    }
  }, {
    key: "togglePensionFields",
    value: function togglePensionFields() {
      return this.pensionsModule.togglePensionFields();
    }
  }, {
    key: "showPensionModal",
    value: function showPensionModal() {
      var pensionId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return this.pensionsModule.showPensionModal(pensionId);
    }
  }, {
    key: "closePensionModal",
    value: function closePensionModal() {
      return this.pensionsModule.closePensionModal();
    }
  }, {
    key: "savePension",
    value: function () {
      var _savePension = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee65() {
        return _regenerator().w(function (_context65) {
          while (1) switch (_context65.n) {
            case 0:
              return _context65.a(2, this.pensionsModule.savePension());
          }
        }, _callee65, this);
      }));
      function savePension() {
        return _savePension.apply(this, arguments);
      }
      return savePension;
    }()
  }, {
    key: "deletePension",
    value: function () {
      var _deletePension = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee66(pensionId) {
        return _regenerator().w(function (_context66) {
          while (1) switch (_context66.n) {
            case 0:
              return _context66.a(2, this.pensionsModule.deletePension(pensionId));
          }
        }, _callee66, this);
      }));
      function deletePension(_x33) {
        return _deletePension.apply(this, arguments);
      }
      return deletePension;
    }()
  }, {
    key: "showPensionDetails",
    value: function () {
      var _showPensionDetails = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee67(pensionId) {
        return _regenerator().w(function (_context67) {
          while (1) switch (_context67.n) {
            case 0:
              return _context67.a(2, this.pensionsModule.showPensionDetails(pensionId));
          }
        }, _callee67, this);
      }));
      function showPensionDetails(_x34) {
        return _showPensionDetails.apply(this, arguments);
      }
      return showPensionDetails;
    }()
  }, {
    key: "closePensionDetails",
    value: function closePensionDetails() {
      return this.pensionsModule.closePensionDetails();
    }
  }, {
    key: "loadPensionBalanceChart",
    value: function () {
      var _loadPensionBalanceChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee68(pensionId) {
        return _regenerator().w(function (_context68) {
          while (1) switch (_context68.n) {
            case 0:
              return _context68.a(2, this.pensionsModule.loadPensionBalanceChart(pensionId));
          }
        }, _callee68, this);
      }));
      function loadPensionBalanceChart(_x35) {
        return _loadPensionBalanceChart.apply(this, arguments);
      }
      return loadPensionBalanceChart;
    }()
  }, {
    key: "loadPensionProjectionChart",
    value: function () {
      var _loadPensionProjectionChart = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee69(pensionId) {
        return _regenerator().w(function (_context69) {
          while (1) switch (_context69.n) {
            case 0:
              return _context69.a(2, this.pensionsModule.loadPensionProjectionChart(pensionId));
          }
        }, _callee69, this);
      }));
      function loadPensionProjectionChart(_x36) {
        return _loadPensionProjectionChart.apply(this, arguments);
      }
      return loadPensionProjectionChart;
    }()
  }, {
    key: "loadPensionActivity",
    value: function () {
      var _loadPensionActivity = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee70(pensionId) {
        return _regenerator().w(function (_context70) {
          while (1) switch (_context70.n) {
            case 0:
              return _context70.a(2, this.pensionsModule.loadPensionActivity(pensionId));
          }
        }, _callee70, this);
      }));
      function loadPensionActivity(_x37) {
        return _loadPensionActivity.apply(this, arguments);
      }
      return loadPensionActivity;
    }()
  }, {
    key: "showBalanceModal",
    value: function showBalanceModal() {
      return this.pensionsModule.showBalanceModal();
    }
  }, {
    key: "closeBalanceModal",
    value: function closeBalanceModal() {
      return this.pensionsModule.closeBalanceModal();
    }
  }, {
    key: "saveSnapshot",
    value: function () {
      var _saveSnapshot = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee71() {
        return _regenerator().w(function (_context71) {
          while (1) switch (_context71.n) {
            case 0:
              return _context71.a(2, this.pensionsModule.saveSnapshot());
          }
        }, _callee71, this);
      }));
      function saveSnapshot() {
        return _saveSnapshot.apply(this, arguments);
      }
      return saveSnapshot;
    }()
  }, {
    key: "showContributionModal",
    value: function showContributionModal() {
      return this.pensionsModule.showContributionModal();
    }
  }, {
    key: "closeContributionModal",
    value: function closeContributionModal() {
      return this.pensionsModule.closeContributionModal();
    }
  }, {
    key: "saveContribution",
    value: function () {
      var _saveContribution = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee72() {
        return _regenerator().w(function (_context72) {
          while (1) switch (_context72.n) {
            case 0:
              return _context72.a(2, this.pensionsModule.saveContribution());
          }
        }, _callee72, this);
      }));
      function saveContribution() {
        return _saveContribution.apply(this, arguments);
      }
      return saveContribution;
    }()
  }, {
    key: "loadDashboardPensionSummary",
    value: function () {
      var _loadDashboardPensionSummary = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee73() {
        return _regenerator().w(function (_context73) {
          while (1) switch (_context73.n) {
            case 0:
              return _context73.a(2, this.pensionsModule.loadDashboardPensionSummary());
          }
        }, _callee73, this);
      }));
      function loadDashboardPensionSummary() {
        return _loadDashboardPensionSummary.apply(this, arguments);
      }
      return loadDashboardPensionSummary;
    }()
  }, {
    key: "parseColumnVisibility",
    value: function parseColumnVisibility(settingValue) {
      var defaults = {
        date: true,
        description: true,
        vendor: true,
        category: true,
        amount: true,
        account: true
      };
      if (!settingValue) return defaults;
      try {
        return Object.assign({}, defaults, JSON.parse(settingValue));
      } catch (e) {
        console.error('Failed to parse column visibility settings', e);
        return defaults;
      }
    }

    // Duplicate parseDashboardConfig removed - using delegation to dashboardModule
  }, {
    key: "applyColumnVisibility",
    value: function applyColumnVisibility() {
      var table = document.getElementById('transactions-table');
      if (!table) return;
      var columnMap = {
        date: 'date-column',
        description: 'description-column',
        vendor: 'vendor-column',
        category: 'category-column',
        amount: 'amount-column',
        account: 'account-column'
      };
      Object.entries(this.columnVisibility).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
          key = _ref6[0],
          visible = _ref6[1];
        var className = columnMap[key];
        if (!className) return;

        // Apply to all cells with this class (header and body)
        var cells = table.querySelectorAll("th.".concat(className, ", td.").concat(className));
        cells.forEach(function (cell) {
          cell.style.display = visible ? '' : 'none';
        });
      });
    }
  }, {
    key: "toggleColumnVisibility",
    value: function () {
      var _toggleColumnVisibility = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee74(columnKey, visible) {
        var visibleCount, settings, response, _t25;
        return _regenerator().w(function (_context74) {
          while (1) switch (_context74.p = _context74.n) {
            case 0:
              // Prevent hiding all columns (enforce minimum 1 visible)
              visibleCount = Object.values(this.columnVisibility).filter(function (v) {
                return v;
              }).length;
              if (!(!visible && visibleCount <= 1)) {
                _context74.n = 1;
                break;
              }
              OC.Notification.showTemporary('At least one column must remain visible');
              document.getElementById("col-toggle-".concat(columnKey)).checked = true;
              return _context74.a(2);
            case 1:
              // Update local state
              this.columnVisibility[columnKey] = visible;

              // Apply to DOM immediately
              this.applyColumnVisibility();

              // Persist to backend
              _context74.p = 2;
              settings = {
                transaction_columns_visible: JSON.stringify(this.columnVisibility)
              };
              _context74.n = 3;
              return fetch(OC.generateUrl('/apps/budget/api/settings'), {
                method: 'PUT',
                headers: {
                  'requesttoken': OC.requestToken,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
              });
            case 3:
              response = _context74.v;
              if (response.ok) {
                _context74.n = 4;
                break;
              }
              throw new Error('Failed to save column visibility');
            case 4:
              this.settings.transaction_columns_visible = JSON.stringify(this.columnVisibility);
              _context74.n = 6;
              break;
            case 5:
              _context74.p = 5;
              _t25 = _context74.v;
              console.error('Failed to save column visibility:', _t25);
              OC.Notification.showTemporary('Failed to save column preferences');

              // Revert on failure
              this.columnVisibility[columnKey] = !visible;
              this.applyColumnVisibility();
              document.getElementById("col-toggle-".concat(columnKey)).checked = !visible;
            case 6:
              return _context74.a(2);
          }
        }, _callee74, this, [[2, 5]]);
      }));
      function toggleColumnVisibility(_x38, _x39) {
        return _toggleColumnVisibility.apply(this, arguments);
      }
      return toggleColumnVisibility;
    }()
  }, {
    key: "syncColumnConfigUI",
    value: function syncColumnConfigUI() {
      Object.entries(this.columnVisibility).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
          key = _ref8[0],
          visible = _ref8[1];
        var checkbox = document.getElementById("col-toggle-".concat(key));
        if (checkbox) {
          checkbox.checked = visible;
        }
      });
    }

    // Dashboard customization methods moved to DashboardModule

    // ============================================
    // Tag Sets Module Delegations
    // ============================================
  }, {
    key: "loadTagSetsForCategory",
    value: function () {
      var _loadTagSetsForCategory = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee75(categoryId) {
        return _regenerator().w(function (_context75) {
          while (1) switch (_context75.n) {
            case 0:
              return _context75.a(2, this.tagSetsModule.loadTagSetsForCategory(categoryId));
          }
        }, _callee75, this);
      }));
      function loadTagSetsForCategory(_x40) {
        return _loadTagSetsForCategory.apply(this, arguments);
      }
      return loadTagSetsForCategory;
    }()
  }, {
    key: "loadTransactionTags",
    value: function () {
      var _loadTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee76(transactionId) {
        return _regenerator().w(function (_context76) {
          while (1) switch (_context76.n) {
            case 0:
              return _context76.a(2, this.tagSetsModule.loadTransactionTags(transactionId));
          }
        }, _callee76, this);
      }));
      function loadTransactionTags(_x41) {
        return _loadTransactionTags.apply(this, arguments);
      }
      return loadTransactionTags;
    }()
  }, {
    key: "saveTransactionTags",
    value: function () {
      var _saveTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee77(transactionId, tagIds) {
        return _regenerator().w(function (_context77) {
          while (1) switch (_context77.n) {
            case 0:
              return _context77.a(2, this.tagSetsModule.saveTransactionTags(transactionId, tagIds));
          }
        }, _callee77, this);
      }));
      function saveTransactionTags(_x42, _x43) {
        return _saveTransactionTags.apply(this, arguments);
      }
      return saveTransactionTags;
    }()
  }, {
    key: "renderTagChips",
    value: function renderTagChips(tags) {
      return this.tagSetsModule.renderTagChips(tags);
    }
  }, {
    key: "renderCategoryTagSetsUI",
    value: function () {
      var _renderCategoryTagSetsUI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee78(categoryId) {
        return _regenerator().w(function (_context78) {
          while (1) switch (_context78.n) {
            case 0:
              return _context78.a(2, this.tagSetsModule.renderCategoryTagSetsUI(categoryId));
          }
        }, _callee78, this);
      }));
      function renderCategoryTagSetsUI(_x44) {
        return _renderCategoryTagSetsUI.apply(this, arguments);
      }
      return renderCategoryTagSetsUI;
    }()
  }, {
    key: "renderTransactionTagSelectors",
    value: function () {
      var _renderTransactionTagSelectors = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee79(categoryId, transactionId) {
        return _regenerator().w(function (_context79) {
          while (1) switch (_context79.n) {
            case 0:
              return _context79.a(2, this.tagSetsModule.renderTransactionTagSelectors(categoryId, transactionId));
          }
        }, _callee79, this);
      }));
      function renderTransactionTagSelectors(_x45, _x46) {
        return _renderTransactionTagSelectors.apply(this, arguments);
      }
      return renderTransactionTagSelectors;
    }()
  }, {
    key: "loadAndDisplayTransactionTags",
    value: function () {
      var _loadAndDisplayTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee80() {
        return _regenerator().w(function (_context80) {
          while (1) switch (_context80.n) {
            case 0:
              return _context80.a(2, this.tagSetsModule.loadAndDisplayTransactionTags());
          }
        }, _callee80, this);
      }));
      function loadAndDisplayTransactionTags() {
        return _loadAndDisplayTransactionTags.apply(this, arguments);
      }
      return loadAndDisplayTransactionTags;
    }()
  }, {
    key: "renderCategoryTagSetsList",
    value: function () {
      var _renderCategoryTagSetsList = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee81(categoryId) {
        return _regenerator().w(function (_context81) {
          while (1) switch (_context81.n) {
            case 0:
              return _context81.a(2, this.tagSetsModule.renderCategoryTagSetsList(categoryId));
          }
        }, _callee81, this);
      }));
      function renderCategoryTagSetsList(_x47) {
        return _renderCategoryTagSetsList.apply(this, arguments);
      }
      return renderCategoryTagSetsList;
    }()
  }, {
    key: "loadAllTransactionTags",
    value: function () {
      var _loadAllTransactionTags = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee82() {
        return _regenerator().w(function (_context82) {
          while (1) switch (_context82.n) {
            case 0:
              return _context82.a(2, this.tagSetsModule.loadAllTransactionTags());
          }
        }, _callee82, this);
      }));
      function loadAllTransactionTags() {
        return _loadAllTransactionTags.apply(this, arguments);
      }
      return loadAllTransactionTags;
    }()
  }, {
    key: "setupAddTagModalListeners",
    value: function setupAddTagModalListeners() {
      return this.tagSetsModule.setupAddTagModalListeners();
    }
  }, {
    key: "setupAddTagSetModalListeners",
    value: function setupAddTagSetModalListeners() {
      // Check if method exists in TagSetsModule
      if (this.tagSetsModule.setupAddTagSetModalListeners) {
        return this.tagSetsModule.setupAddTagSetModalListeners();
      }
    }

    // ============================================
    // Helper Methods
    // ============================================
  }, {
    key: "formatCurrency",
    value: function formatCurrency(amount) {
      var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__.formatCurrency(amount, currency, this.settings);
    }
  }, {
    key: "getPrimaryCurrency",
    value: function getPrimaryCurrency() {
      var _this$settings;
      // Get default currency from settings
      var defaultCurrency = ((_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : _this$settings.default_currency) || 'GBP';

      // Return cached value if accounts and settings haven't changed
      var currentHash = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__.getAccountsHash(this.accounts);
      if (this._primaryCurrencyCache && this._accountsHash === currentHash && this._settingsCurrencyCache === defaultCurrency) {
        return this._primaryCurrencyCache;
      }

      // Get primary currency from utility
      var primaryCurrency = _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__.getPrimaryCurrency(this.accounts, this.settings);

      // Cache the result
      this._primaryCurrencyCache = primaryCurrency;
      this._accountsHash = currentHash;
      this._settingsCurrencyCache = defaultCurrency;
      return primaryCurrency;
    }
  }, {
    key: "formatDate",
    value: function formatDate(dateStr) {
      return _utils_formatters_js__WEBPACK_IMPORTED_MODULE_1__.formatDate(dateStr, this.settings);
    }
  }, {
    key: "escapeHtml",
    value: function escapeHtml(text) {
      return _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__.escapeHtml(text);
    }
  }, {
    key: "populateAccountDropdowns",
    value: function populateAccountDropdowns() {
      // Stub method - dropdowns are populated by individual modules as needed
      // This is called from loadInitialData but doesn't need to do anything
    }
  }, {
    key: "populateCategoryDropdowns",
    value: function populateCategoryDropdowns() {
      // Stub method - dropdowns are populated by individual modules as needed
      // This is called from loadInitialData but doesn't need to do anything
    }
  }]);
}(); // Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', function () {
  window.budgetApp = new BudgetApp();
});
})();

/******/ })()
;
//# sourceMappingURL=budget-main.js.map